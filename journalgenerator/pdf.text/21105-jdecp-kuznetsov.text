dx
dt
6
 
-
?
DIFFERENTIAL EQUATIONS
AND
CONTROL PROCESSES
N. 1, 2021
Electronic Journal,
reg. N  C77-39410 at 15.04.2010
ISSN 1817-2172
http:// diffjournal.spbu.ru/
e-mail: jodiff@mail.ru
Computer software for the investigation of differential
equations, dynamical systems, and control processes
Stochastic differential equations
Numerical methods
Computer modeling in dynamical and control systems
SDE-MATH: A software package for the implementation of strong
high-order numerical methods for It^ o SDEs with multidimensional
non-commutative noise based on multiple Fourier{Legendre series
Mikhail D. Kuznetsov
1
, Dmitriy F. Kuznetsov
2
1
Faculty of Computer Technologies and Informatics, St. Petersburg
Electrotechnical University, Saint-Petersburg, Russia
2
Institute of Applied Mathematics and Mechanics, Peter the Great St.
Petersburg Polytechnic University
e-mail: sde kuznetsov@inbox.ru
Abstract. The article is devoted to the implementation of strong numeri-
cal methods with convergence orders 0:5; 1:0; 1:5; 2:0; 2:5; and 3:0 for It^ o
stochastic differential equations with multidimensional non-commutative noise
based on multiple Fourier{Legendre series and uni ed Taylor{It^ o and Taylor{
Stratonovich expansions. Algorithms for the implementation of these methods
are constructed and a package of programs in the Python programming lan-
guage is presented. An important part of this software package concerning theDifferential Equations and Control Processes, N. 1, 2021
mean-square approximation of iterated It^ o and Stratonovich stochastic inte-
grals of multiplicities 1 to 6 with respect to components of the multidimensional
Wiener process is based on the method of generalized multiple Fourier series.
More precisely, we used multiple Fourier{Legendre series converging in the sense
of norm in Hilbert space for the mean-square approximation of iterated It^ o and
Stratonovich stochastic integrals.
Key words: Software package, Python programming language, numerical
method, strong convergence, It^ o stochastic differential equation, multidimen-
sional Wiener process, non-commutative noise, uni ed Taylor{It^ o expansion,
uni ed Taylor{Stratonovich expansion, Milstein scheme, high-order strong nu-
merical scheme, iterated It^ o stochastic integral, iterated Stratonovich stochastic
integral, mean-square approximation, generalized multiple Fourier series, mul-
tiple Fourier{Legendre series, Legendre polynomial.
Contents
1 Introduction 94
2 Theoretical Results Underlying the SDE-MATH Software Package 98
2.1 Strong Numerical Methods with Convergence Orders 0:5; 1:0; 1:5; 2:0; 2:5; and
3:0 for It^ o SDEs Based on the Uni ed Taylor{It^ o Expansion . . . . . . . . . . . 98
2.2 Strong Numerical Methods with Convergence Orders 1:0; 1:5; 2:0; 2:5; and 3:0
for It^ o SDEs Based on the Uni ed Taylor{Stratonovich Expansion . . . . . . . . 106
2.3 Method of Expansion and Approximation of Iterated It^ o and Stratonovich
Stochastic Integrals Based on Generalized Multiple Fourier Series . . . . . . . . 113
2.4 Approximations of Iterated It^ o Stochastic Integrals from the Numerical Schemes
(11){(16) Using Legendre Polynomials . . . . . . . . . . . . . . . . . . . . . . . 123
2.5 Optimization of Approximations of Iterated It^ o Stochastic Integrals from the
Numerical Schemes (12){(16) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
2.6 Approximations of Iterated Stratonovich Stochastic Integrals from the Numerical
Schemes (24){(28) Using Legendre Polynomials . . . . . . . . . . . . . . . . . . 141
2.7 Numerical Algorithm for Linear Stationary Systems of It^ o SDEs Based on Spec-
tral Decomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
Electronic Journal. http://diffjournal.spbu.ru/ 94Differential Equations and Control Processes, N. 1, 2021
3 The Structure of the SDE-MATH Software Package 148
3.1 Development Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
3.2 Dependency Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
3.3 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
3.3.1 Integration with SymPy . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
3.3.2 Purpose of NumPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
3.3.3 Purpose of SQLite Database . . . . . . . . . . . . . . . . . . . . . . . . . 152
3.3.4 Purpose of Matplotlib . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
3.4 Implementation Plan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
3.4.1 Calculation of the Fourier{Legendre Coe cients . . . . . . . . . . . . . . 153
3.4.2 Differential Operators L;
 
L; G
(i)
0
; i = 1;:::;m . . . . . . . . . . . . . . . 154
3.4.3 Approximations of Iterated Stochastic Integrals . . . . . . . . . . . . . . 154
3.4.4 Strong Numerical Schemes for It^ o SDEs . . . . . . . . . . . . . . . . . . 154
3.4.5 Graphical User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
4 Software Package Graphical User Interface 154
4.1 Information Model of The Graphical User Interface . . . . . . . . . . . . . . . . 154
4.1.1 Processing Screens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.1.2 Greetings Dialog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.1.3 Main Menu Dialog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.1.4 Visualization Tool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.1.5 Data Input Dialogs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.2 The User Experience and Implementation Results . . . . . . . . . . . . . . . . . 157
5 The Results Obtained Using the SDE-MATH Software Package 175
5.1 The Calculated Fourier{Legendre Coe cients . . . . . . . . . . . . . . . . . . . 175
5.2 Accuracy Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
5.3 Testing Example (Nonlinear System of It^ o SDEs) . . . . . . . . . . . . . . . . . 179
5.4 Visualization and Numerical Results for Nonlinear System of It^ o SDEs Obtained
via the SDE-MATH Software Package . . . . . . . . . . . . . . . . . . . . . . . . 180
5.5 Example of Linear System of It^ o SDEs (Solar Activity) . . . . . . . . . . . . . . 211
Electronic Journal. http://diffjournal.spbu.ru/ 95Differential Equations and Control Processes, N. 1, 2021
5.6 Visualization and Numerical Results for Solar Activity Model . . . . . . . . . . 211
5.7 Example of Abstract Linear System of It^ o SDEs . . . . . . . . . . . . . . . . . . 214
5.8 Visualization and Numerical Results for Abstract Linear System of It^ o SDEs
Obtained via the SDE-MATH Software Package . . . . . . . . . . . . . . . . . . 215
6 Source Codes of the SDE-MATH Software Package in the Python Program-
ming Language 217
6.1 Source Codes of Graphical User Interface . . . . . . . . . . . . . . . . . . . . . . 217
6.1.1 Source Codes of Main Menu . . . . . . . . . . . . . . . . . . . . . . . . . 217
6.1.2 Source Codes of Charts Window . . . . . . . . . . . . . . . . . . . . . . . 230
6.1.3 Source Codes of Input for Nonlinear Systems of It^ o SDEs . . . . . . . . . 240
6.1.4 Source Codes of Input for Linear Systems of It^ o SDEs . . . . . . . . . . . 255
6.2 Source Codes for Nonlinear Systems of It^ o SDEs . . . . . . . . . . . . . . . . . . 275
6.2.1 Source Codes for Calculation of the Fourier{Legendre Coe cients . . . . 275
6.2.2 Source Codes for Supplementary Differential Operators and Functions . . 299
6.2.3 Source Codes for Iterated It^ o Stochastic Integrals Approximations Sub-
programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
6.2.4 Source Codes for Iterated Stratonovich Stochastic Integrals Approxima-
tions Subprograms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
6.2.5 Source Codes for Calculation of the Numbers q; q
1
,:::, q
15
. . . . . . . . 351
6.2.6 Source Codes for Strong Taylor{It^ o Numerical Schemes with Convergence
Orders 0:5, 1:0, 1:5, 2:0, 2:5, and 3:0 for It^ o SDEs . . . . . . . . . . . . . 359
6.2.7 Source Codes for Strong Taylor{Stratonovich Numerical Schemes with
Convergence Orders 1:0, 1:5, 2:0, 2:5, and 3:0 for It^ o SDEs . . . . . . . . 381
6.3 Source Codes for Linear Stationary Systems of It^ o SDEs . . . . . . . . . . . . . 400
6.4 Source Codes for Utilities and Initialization . . . . . . . . . . . . . . . . . . . . 407
7 Future Work 412
References 413
Electronic Journal. http://diffjournal.spbu.ru/ 96Differential Equations and Control Processes, N. 1, 2021
1 Introduction
As known, It^ o stochastic differential equations (SDEs) have appeared in the
theory of random processes relatively recently [1] (1951). Nevertheless, to date,
a large number of mathematical models for dynamical systems of different phys-
ical nature under the inuence of random perturbations have been built on the
basis of such equations [2]-[16]. Among them we note mathematical models
in stochastic  nancial mathematics [5]-[7], [10]-[12], geophysics [2], [4], genetics
[13], hydrology [2], epidemiology [9], chemical kinetics [2], [9], biology [8], [15],
seismology [2], electrodynamics [16] and many other  elds [2], [9], [14]. In ad-
dition, It^ o SDEs arise when solving a number of mathematical problems, such
as  ltration [2], [3], [17]-[21], stochastic control [2], [17], stochastic stability [2],
parameter estimation of stochastic systems [2], [3], [22].
Exact solutions of It^ o SDEs are known in rare cases. For this reason, it
becomes necessary to construct numerical methods for It^ o SDEs. Moreover,
the problem of numerical solution of It^ o SDEs often occurs even in cases when
the exact solution of It^ o SDE is known. This means that in some cases, knowing
the exact solution of the It^ o SDE does not allow us to simulate it numerically
in a simple way.
This article is devoted to the implementation of high-order strong numeri-
cal methods for systems of It^ o SDEs with multidimensional non-commutative
noise. More precisely, we consider strong numerical methods with convergence
orders 1:0; 1:5; 2:0; 2:5; and 3:0. The article also considers the Euler method,
which under suitable conditions [2] has the order 0:5 of strong convergence. To
construct the mentioned numerical methods in this article, we use the so-called
uni ed Taylor{It^ o and Taylor{Stratonovich expansions [24], [25] (also see [26],
Chapter 4). The important components of these expansions are the iterated
It^ o and Stratonovich stochastic integrals, which are functionals of a complex
structure with respect to the components of a multidimensional Wiener process.
It should be noted that it is impossible to construct a numerical method
for It^ o SDE in a general case (multidimensional non-commutative noise) that
includes only increments of the multidimensional Wiener processes, but has a
higher order of convergence (in the mean-square sense) than the Euler method
(simplest numerical method for It^ o SDEs). This result is known as the "Clark{
Cameron paradox" [23] (1980) and well explains the need to use high-order
numerical methods for It^ o SDEs, since the accuracy of the Euler method is
insu cient for solving a number of practical problems related to It^ o SDEs [2].
Electronic Journal. http://diffjournal.spbu.ru/ 97Differential Equations and Control Processes, N. 1, 2021
According to the "Clark{Cameron paradox" [23], avoidance of the problem of
mean-square approximation of the mentioned iterated stochastic integrals is
impossible in the general case when constructing high-order strong numerical
methods for It^ o SDEs.
The problem of mean-square approximation of iterated It^ o and Stratonovich
stochastic integrals in the context of the numerical integration of It^ o SDEs was
considered in a number of works [2], [3], [7], [8], [27]-[39].
It should be explained why the results of these works are insu cient for
constructing effective procedures for the implementation of strong numerical
methods of order 1:5 and higher for It^ o SDEs.
There exists an approach to the mean-square approximation of iterated
stochastic integrals based on integral sums [27], [34], [35]. Note that one of
the variants of this method is based on reducing the problem of mean-square
approximation of iterated stochastic integrals to the numerical integration of
systems of linear It^ o SDEs by the Euler method [39]. However, this approach
[27], [34], [35], [39] implies the partitioning of the interval of integration for
iterated stochastic integrals. It should be noted that the length of this interval is
an integration step for numerical methods for It^ o SDEs, which is already a fairly
small value even without additional partitioning. Computational experiments
show that the numerical modeling of iterated stochastic integrals by the method
of integral sums [27], [34], [35], [39] leads to unacceptably high computational
cost and accumulation of computation errors [42].
More e cient approach of the mean-square approximation of iterated
stochastic integrals is based on the expansion of the so-called Brownian bridge
process into the trigonometric Fourier series with random terms (version of the
so-called Karhunen{Lo  eve expansion) [2], [3], [7], [27], [28], [33], [34], [37], [38].
However, in [27], [33], [34], [38], this approach was used to approximate only
iterated stochastic integrals of multiplicities 1 and 2, which makes it possible
to implement numerical method with order 1:0 of strong convergence for It^ o
SDEs (Milstein method [27]). In papers [2], [3], [7], [28], the approximation of
iterated stochastic integrals of multiplicities 1 to 3 was considered by the above
approach, which makes it possible to implement numerical methods with orders
1:0 and 1:5 of strong convergence for It^ o SDEs. However, formulas concerning
integrals of multiplicity 3 turned out to be too complicated and did not  nd
wide application in practice. Moreover, these formulas (for iterated stochastic
integrals of multiplicity 3) were obtained without strict theoretical justi cation
and exclude the possibility of effective estimation of the mean-square error of
Electronic Journal. http://diffjournal.spbu.ru/ 98Differential Equations and Control Processes, N. 1, 2021
approximation (see discussion in [26] (Sections 2.6.2, 6.2) for details).
It should be noted that in papers [29], [30], a similar approach was used to
approximate iterated stochastic integrals of multiplicities 1 to 3 based on the
series expansion of the Wiener process using trigonometric functions and Haar
functions. In [40] orthonormal expansions of functions in terms of Walsh series
were used to represent the iterated stochastic integrals.
Note that the iterated stochastic integrals under consideration are the ran-
dom variables with unknown density functions. The only exception is the iter-
ated It^ o stochastic integral with multiplicity 2 [31]. However, the knowledge of
density function of the mentioned stochastic integral gives no simple way of its
approximation [31].
In this work, we use a more e cient method of the mean-square approxi-
mation of iterated It^ o and Stratonovich stochastic integrals than the methods
considered above. This method (the so-called method of generalized multiple
Fourier series) is based on the theory constructed in Chapters 1, 2, and 5 of
monograph [26] (also see bibliography therein). The method of generalized mul-
tiple Fourier series made it possible in this work to successfully implement the
procedures for the mean-square approximation of iterated It^ o and Stratonovich
stochastic integrals of multiplicities 1 to 6. In this case, we use multiple Fourier{
Legendre series, that is, we have chosen Legendre polynomials as a basis system
of functions for approximating iterated stochastic integrals. It is important to
note that the Legendre polynomials were  rst applied in the context of this
problem in [43] (1997), while in the works of other authors Legendre polynomi-
als were not considered as a system of basis functions for approximating iterated
stochastic integrals (an exception is work [36]). As shown in [44], the Legendre
polynomials are an optimal system of basis functions for approximating iterated
It^ o and Stratonovich stochastic integrals.
In this article, to build the SDE-MATH software package in the Python pro-
gramming language, we use a database with 270,000 exactly calculated Fourier{
Legendre coe cients to approximate iterated It^ o and Stratonovich stochastic
integrals of multiplicities 1 to 6. It should be noted that the procedures for
the mean-square approximation of iterated stochastic integrals of multiplicities
4, 5, and 6 constructed in this work have no analogues in the literature. At
the same time, we propose a much more convenient procedure for the mean-
square approximation of iterated stochastic integrals of multiplicity 3 than in
works [2], [3], [7], [28]. This procedure provides an accurate calculation of the
mean-square error of approximation of the mentioned stochastic integrals.
Electronic Journal. http://diffjournal.spbu.ru/ 99Differential Equations and Control Processes, N. 1, 2021
Another important feature of the presented software package is the use of
uni ed Taylor{It^ o and Taylor{Stratonovich expansions [24], [25] (also see [26],
Chapter 4) for constructing strong numerical methods with convergence orders
1:5; 2:0, 2:5, and 3:0 for It^ o SDEs. Uni ed Taylor{It^ o and Taylor|Stratonovich
expansions make it possible (in contrast with its classical analogues [2]) to use
the minimal sets of iterated It^ o and Stratonovich stochastic integrals. This
property well explains the motive for using the mentioned uni ed expansions.
The results of this work on the approximation of iterated stochastic inte-
grals can be used to numerically solve various types of SDEs. For example, for
semilinear SPDEs with multiplicative trace class noise [26] (Chapter 7), [45],
[46]. This is due to the fact that iterated stochastic integrals are a universal
tool for constructing high-order strong numerical methods for various types
of SDEs. In recent years, the mentioned numerical methods have been con-
structed for SDEs with jumps [7], SPDEs with multiplicative trace class noise
[47]-[49], McKean SDEs [50], SDEs with switchings [51], mean- eld SDEs [52],
It^ o{Volterra stochastic integral equations [49], etc.
There are many publications in which codes of programs in various pro-
gramming languages are given for the numerical solution of SDEs [3], [9], [14],
[53]-[61]. Among them, we note the software described in [3], [54], [56], [60].
Some of the mentioned works [3], [54], [56], [57], [60] are based on the results of
monograph [2] on the approximation of iterated stochastic integrals (see above
discusson on the disadvantages of approach [2]). Other publications [9], [14],
[53], [55] do not use the modeling of iterated stochastic integrals for the case of
multidimensional non-commutative noise at all.
In this article, we develop software for the numerical integration of It^ o
SDEs based on theoretical results and MATLAB codes from monographs [58],
[61] for modeling iterated stochastic integrals of multiplicities 1 to 6 (the case
of multidimensional non-commutative noise). In addition, we provide software
(as a part of the SDE-MATH software package) for the numerical integration
of linear stationary systems of It^ o SDEs based on the results of article [62] and
MATLAB codes from monographs [58], [61].
In Section 7 we discuss possible directions for the development of the SDE-
MATH software package. In particular, the parallelization of computations, the
implementation of methods of the Runge{Kutta type [2], [7], [42], [61] and mul-
tistep numerical methods for It^ o SDEs [2], [7], [42], [61], the development of a
part of the software package for solving  ltering problem and stochastic optimal
control problem [2], as well as improvement of the graphical user interface.
Electronic Journal. http://diffjournal.spbu.ru/ 100Differential Equations and Control Processes, N. 1, 2021
2 Theoretical Results Underlying the SDE-MATH Soft-
ware Package
2.1 Strong Numerical Methods with Convergence Orders 0:5; 1:0;
1:5; 2:0; 2:5; and 3:0 for It^ o SDEs Based on the Uni ed Taylor{
It^ o Expansion
Let (
; F; P) be a complete probability space and letfF
t
;t2 [0;T ]g be a
nondecreasing right-continuous family of -algebras of F: Let w
t
be a standard
m-dimensional Wiener stochastic process with independent components w
(i)
t
(i = 1;:::;m), which is F
t
-measurable for any t2 [0;T ]: Consider an It^ o SDE
in the integral form
x
t
= x
0
+
t
Z
0
a(x
 
; )d  +
m
X
i=1
t
Z
0
B
i
(x
 
; )dw
(i)
 
; x
0
= x(0;!); (1)
where x
t
2 R
n
is a solution of the It^ o SDE (1), the nonrandom functions
a(x;t) : R
n
  [0;T ]! R
n
, B(x;t) : R
n
  [0;T ]! R
n m
guarantee the exis-
tence and uniqueness up to stochastic equivalence of a solution of (1) [63], the
second integral on the right-hand side of (1) is interpreted as an It^ o stochas-
tic integral, B
i
(x;t) is the ith colomn of the matrix function B(x;t); x
0
is an
n-dimensional and F
0
-measurable random variable, M
 
jx
0
j
2
	
<1 (M is an
expectation operator). We assume that x
0
and w
t
  w
0
are independent when
t> 0:
It is well known that one of the effective approaches to the numerical in-
tegration of It^ o SDEs is an approach based on the Taylor{It^ o and Taylor{
Stratonovich expansions [2], [7], [42]. The essential feature of such expansions
are the so-called iterated It^ o and Stratonovich stochastic integrals, which have
the form
J[ 
(k)
]
T;t
=
T
Z
t
 
k
(t
k
):::
t
2
Z
t
 
1
(t
1
)dw
(i
1
)
t
1
:::dw
(i
k
)
t
k
; (2)
J
 
[ 
(k)
]
T;t
=
 T
Z
t
 
k
(t
k
):::
 t
2
Z
t
 
1
(t
1
)dw
(i
1
)
t
1
:::dw
(i
k
)
t
k
; (3)
where every 
l
( ) (l = 1;:::;k) is a continuous nonrandom function on [t;T ];
Electronic Journal. http://diffjournal.spbu.ru/ 101Differential Equations and Control Processes, N. 1, 2021
w
(i)
 
(i = 1;:::;m) are independent standard Wiener processes and w
(0)
 
def
=  ;
Z
and
 
Z
denote It^ o and Stratonovich stochastic integrals, respectively; i
1
;:::;i
k
=
0; 1;:::;m:
Note that 
l
( )  1 (l = 1;:::;k) andi
1
;:::;i
k
= 0; 1;:::;m in the classical
Taylor{It^ o and Taylor{Stratonovich expansions [2]. At the same time 
l
( ) 
(t  )
q
l
(l = 1;:::;k; q
1
;:::;q
k
= 0; 1; 2;:::) and i
1
;:::;i
k
= 1;:::;m in the
uni ed Taylor{It^ o and Taylor{Stratonovich expansions [24], [25] (also see [26],
Chapter 4).
LetC
2;1
(R
n
 [0;T ]) be the space of functionsR(x;t) :R
n
 [0;T ]!R
1
with
the following property: these functions are twice continuously differentiable in x
and have one continuous derivative int. Let us consider the following differential
operators on the space C
2;1
(R
n
  [0;T ])
L =
@
@t
+
n
X
i=1
a
(i)
(x;t)
@
@x
(i)
+
1
2
m
X
j=1
n
X
l;i=1
B
(lj)
(x;t)B
(ij)
(x;t)
@
2
@x
(l)
@x
(i)
; (4)
G
(i)
0
=
n
X
j=1
B
(ji)
(x;t)
@
@x
(j)
; i = 1;:::;m; (5)
wherea
(i)
(x;t) is theith component of the vector functiona(x;t) andB
(ij)
(x;t)
is the ijth component of the matrix function B(x;t).
Consider the following sequence of differential operators
G
(i)
p
=
1
p
 
G
(i)
p 1
L LG
(i)
p 1
 
; p = 1; 2;:::; i = 1;:::;m;
where L and G
(i)
0
; i = 1;:::;m are de ned by (4), (5).
For the further consideration, we need to introduce the following set of
iterated It^ o stochastic integrals
I
(i
1
:::i
k
)
(l
1
:::l
k
)s;t
=
s
Z
t
(t t
k
)
l
k
:::
t
2
Z
t
(t t
1
)
l
1
dw
(i
1
)
t
1
:::dw
(i
k
)
t
k
; (6)
where l
1
;:::;l
k
= 0; 1;::: and i
1
;:::;i
k
= 1;:::;m:
Electronic Journal. http://diffjournal.spbu.ru/ 102Differential Equations and Control Processes, N. 1, 2021
Assume that R(x;t), a(x;t); and B
i
(x;t); i = 1;:::;m are enough smooth
functions with respect to the variables x and t. Then for all s;t2 [0;T ] such
thats>t we can write the following uni ed Taylor{It^ o expansion [24] (also see
[26], Chapter 4)
R(x
s
;s) =
=R(x
t
;t) +
r
X
q=1
X
(k;j;l
1
;:::;l
k
)2D
q
(s t)
j
j!
m
X
i
1
;:::;i
k
=1
G
(i
1
)
l
1
:::G
(i
k
)
l
k
L
j
R(x
t
;t) I
(i
1
:::i
k
)
(l
1
:::l
k
)s;t
+
+ (H
r+1
)
s;t
w. p. 1; (7)
where
L
j
R(x;t)
def
=
8
>
>
>
<
>
>
>
:
L:::L
| {z }
j
R(x;t) for j  1
R(x;t) for j = 0
;
D
q
=
(
(k;j;l
1
;:::;l
k
) : k + 2
 
j +
k
X
p=1
l
p
!
=q; k;j;l
1
;:::;l
k
= 0; 1;:::
)
;
(8)
and (H
r+1
)
s;t
is the remainder term in integral form [26].
Consider the partitionf 
p
g
N
p=0
of the interval [0;T ] such that
0 = 
0
< 
1
<:::< 
N
=T;  
N
= max
0 j N 1
j 
j+1
  
j
j: (9)
Let y
 
j
def
= y
j
; j = 0; 1;:::;N be a time discrete approximation of the
process x
t
; t2 [0;T ]; which is a solution of the It^ o SDE (1).
De niton 1 [2]. We will say that a time discrete approximation y
j
; j =
0; 1;:::;N; corresponding to the maximal step of discretization  
N
; converges
strongly with order  > 0 at time moment T to the process x
t
; t2 [0;T ], if
there exists a constant C > 0; which does not depend on  
N
; and a  > 0 such
thatMfjx
T
  y
T
jg C( 
N
)

for each  
N
2 (0; ):
From (7) for s = 
p+1
and t = 
p
we obtain the following representation of
explicit one-step strong numerical scheme for the It^ o SDE (1)
y
p+1
= y
p
+
r
X
q=1
X
(k;j;l
1
;:::;l
k
)2D
q
( 
p+1
  
p
)
j
j!
m
X
i
1
;:::;i
k
=1
G
(i
1
)
l
1
:::G
(i
k
)
l
k
L
j
y
p
^
I
(i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
+
Electronic Journal. http://diffjournal.spbu.ru/ 103Differential Equations and Control Processes, N. 1, 2021
+ 1
fr=2d 1;d2Ng
( 
p+1
  
p
)
(r+1)=2
((r + 1)=2)!
L
(r+1)=2
y
p
; (10)
where
^
I
(i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
is an approximation of the iterated It^ o stochastic integral (6)
and 1
A
is the indicator of the setA: Note that we understand the equality (10)
componentwise with respect to the components y
(i)
p
of the column y
p
: Also for
simplicity we put  
p
=p ,   =T=N; p = 0; 1;:::;N:
Under the appropriate conditions [2] the numerical scheme (10) has strong
order r=2 (r2N) of convergence.
Below we consider particular cases of the numerical scheme (10) for r =
1; 2; 3; 4; 5; and 6; i.e. explicit one-step strong numerical schemes with conver-
gence orders 0:5; 1:0; 1:5; 2:0; 2:5; and 3:0 for the It^ o SDE (1) [26], [64], [65].
At that for simplicity we will write a; La; B
i
; G
(i)
0
B
j
etc. instead of a(y
p
; 
p
);
La(y
p
; 
p
);B
i
(y
p
; 
p
);G
(i)
0
B
j
(y
p
; 
p
) etc. correspondingly. Moreover, the opera-
tors L and G
(i)
0
; i = 1;:::;m are de ned by (4), (5).
Scheme with strong order 0.5 (Euler scheme)
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
(i
1
)
(0) 
p+1
; 
p
+  a: (11)
Scheme with strong order 1.0 (Milstein scheme)
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
(i
1
)
(0) 
p+1
; 
p
+  a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
: (12)
Scheme with strong order 1.5
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
(i
1
)
(0) 
p+1
; 
p
+  a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
a
 
 
^
I
(i
1
)
(0) 
p+1
; 
p
+
^
I
(i
1
)
(1) 
p+1
; 
p
 
 LB
i
1
^
I
(i
1
)
(1) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
(i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
La: (13)
Electronic Journal. http://diffjournal.spbu.ru/ 104Differential Equations and Control Processes, N. 1, 2021
Scheme with strong order 2.0
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
(i
1
)
(0) 
p+1
; 
p
+  a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
a
 
 
^
I
(i
1
)
(0) 
p+1
; 
p
+
^
I
(i
1
)
(1) 
p+1
; 
p
 
 LB
i
1
^
I
(i
1
)
(1) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
(i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
La+
+
m
X
i
1
;i
2
=1
h
G
(i
1
)
0
LB
i
2
 
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
 
 LG
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
+
+G
(i
1
)
0
G
(i
2
)
0
a
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
+  
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
 i
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
(i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
: (14)
Scheme with strong order 2.5
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
(i
1
)
(0) 
p+1
; 
p
+  a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
a
 
 
^
I
(i
1
)
(0) 
p+1
; 
p
+
^
I
(i
1
)
(1) 
p+1
; 
p
 
 LB
i
1
^
I
(i
1
)
(1) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
(i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
La+
+
m
X
i
1
;i
2
=1
h
G
(i
1
)
0
LB
i
2
 
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
 
 LG
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
+
+G
(i
1
)
0
G
(i
2
)
0
a
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
+  
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
 i
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
(i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
+
Electronic Journal. http://diffjournal.spbu.ru/ 105Differential Equations and Control Processes, N. 1, 2021
+
m
X
i
1
=1
"
G
(i
1
)
0
La
 
1
2
^
I
(i
1
)
(2) 
p+1
; 
p
+  
^
I
(i
1
)
(1) 
p+1
; 
p
+
 
2
2
^
I
(i
1
)
(0) 
p+1
; 
p
 
+
+
1
2
LLB
i
1
^
I
(i
1
)
(2) 
p+1
; 
p
 LG
(i
1
)
0
a
 
^
I
(i
1
)
(2) 
p+1
; 
p
+  
^
I
(i
1
)
(1) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
=1
h
G
(i
1
)
0
LG
(i
2
)
0
B
i
3
 
^
I
(i
1
i
2
i
3
)
(100) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
LB
i
3
 
^
I
(i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
a
 
 
^
I
(i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
^
I
(i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
 
 LG
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
(i
1
i
2
i
3
)
(100) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
;i
4
;i
5
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
B
i
5
^
I
(i
1
i
2
i
3
i
4
i
5
)
(00000) 
p+1
; 
p
+
+
 
3
6
LLa: (15)
Scheme with strong order 3.0
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
(i
1
)
(0) 
p+1
; 
p
+  a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
a
 
 
^
I
(i
1
)
(0) 
p+1
; 
p
+
^
I
(i
1
)
(1) 
p+1
; 
p
 
 LB
i
1
^
I
(i
1
)
(1) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
(i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
La+
+
m
X
i
1
;i
2
=1
h
G
(i
1
)
0
LB
i
2
 
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
 
 LG
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
+
+G
(i
1
)
0
G
(i
2
)
0
a
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
+  
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
 i
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
(i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
+ q
p+1;p
+ r
p+1;p
; (16)
Electronic Journal. http://diffjournal.spbu.ru/ 106Differential Equations and Control Processes, N. 1, 2021
where
q
p+1;p
=
m
X
i
1
=1
"
G
(i
1
)
0
La
 
1
2
^
I
(i
1
)
(2) 
p+1
; 
p
+  
^
I
(i
1
)
(1) 
p+1
; 
p
+
 
2
2
^
I
(i
1
)
(0) 
p+1
; 
p
 
+
+
1
2
LLB
i
1
^
I
(i
1
)
(2) 
p+1
; 
p
 LG
(i
1
)
0
a
 
^
I
(i
1
)
(2) 
p+1
; 
p
+  
^
I
(i
1
)
(1) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
=1
h
G
(i
1
)
0
LG
(i
2
)
0
B
i
3
 
^
I
(i
1
i
2
i
3
)
(100) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
LB
i
3
 
^
I
(i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
a
 
 
^
I
(i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
^
I
(i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
 
 LG
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
(i
1
i
2
i
3
)
(100) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
;i
4
;i
5
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
B
i
5
^
I
(i
1
i
2
i
3
i
4
i
5
)
(00000) 
p+1
; 
p
+
+
 
3
6
LLa;
and
r
p+1;p
=
m
X
i
1
;i
2
=1
"
G
(i
1
)
0
G
(i
2
)
0
La
 
1
2
^
I
(i
1
i
2
)
(02) 
p+1
; 
p
+  
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
+
 
2
2
^
I
(i
1
i
2
)
(00) 
p+1
; 
p
!
+
+
1
2
LLG
(i
1
)
0
B
i
2
^
I
(i
1
i
2
)
(20) 
p+1
; 
p
+
+G
(i
1
)
0
LG
(i
2
)
0
a
 
^
I
(i
1
i
2
)
(11) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(02) 
p+1
; 
p
+  
 
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(01) 
p+1
; 
p
  
+
+LG
(i
1
)
0
LB
i
2
 
^
I
(i
1
i
2
)
(11) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(20) 
p+1
; 
p
 
+
+G
(i
1
)
0
LLB
i
2
 
1
2
^
I
(i
1
i
2
)
(02) 
p+1
; 
p
+
1
2
^
I
(i
1
i
2
)
(20) 
p+1
; 
p
 
^
I
(i
1
i
2
)
(11) 
p+1
; 
p
!
 
 LG
(i
1
)
0
G
(i
2
)
0
a
 
 
^
I
(i
1
i
2
)
(10) 
p+1
; 
p
+
^
I
(i
1
i
2
)
(11) 
p+1
; 
p
 
#
+
Electronic Journal. http://diffjournal.spbu.ru/ 107Differential Equations and Control Processes, N. 1, 2021
+
m
X
i
1
;i
2
;i
3
;i
4
=1
"
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
a
 
 
^
I
(i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
+
^
I
(i
1
i
2
i
3
i
4
)
(0001) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
LG
(i
3
)
0
B
i
4
 
^
I
(i
1
i
2
i
3
i
4
)
(0100) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
i
4
)
(0010) 
p+1
; 
p
 
 
 LG
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
(i
1
i
2
i
3
i
4
)
(1000) 
p+1
; 
p
+
+G
(i
1
)
0
LG
(i
2
)
0
G
(i
3
)
0
B
i
4
 
^
I
(i
1
i
2
i
3
i
4
)
(1000) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
i
4
)
(0100) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
LB
i
4
 
^
I
(i
1
i
2
i
3
i
4
)
(0010) 
p+1
; 
p
 
^
I
(i
1
i
2
i
3
i
4
)
(0001) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
;i
4
;i
5
;i
6
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
G
(i
5
)
0
B
i
6
^
I
(i
1
i
2
i
3
i
4
i
5
i
6
)
(000000) 
p+1
; 
p
:
Under the suitable conditions [2] the numerical schemes (12){(16) have
strong orders 1.0, 1.5, 2.0, 2.5, and 3.0 of convergence correspondingly. Among
these conditions we consider only the condition for approximations of iterated
It^ o stochastic integrals from (12){(16) [2] (also see [42])
M
8
<
:
 
I
(i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
 
^
I
(i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
!
2
9
=
;
 C 
r+1
; (17)
where constantC is independent of   andr=2 are the strong convergence orders
for the numerical schemes (12){(16), i.e. r=2 = 1:0; 1:5; 2:0; 2:5; and 3:0:
Note that the numerical schemes (12){(16) are unrealizable in practice with-
out procedures for the numerical simulation of iterated It^ o stochastic integrals
from (10). In Section 2.3 we give a brief overview of the effective method of the
mean-square approximation of iterated It^ o and Stratonovich stochastic integrals
of arbitrary multiplicity k (k2N).
2.2 Strong Numerical Methods with Convergence Orders 1:0; 1:5;
2:0; 2:5; and 3:0 for It^ o SDEs Based on the Uni ed Taylor{Stra-
tonovich Expansion
Let us consider the following differential operator on the spaceC
2;1
(R
n
  [0;T ])
Electronic Journal. http://diffjournal.spbu.ru/ 108Differential Equations and Control Processes, N. 1, 2021
 
L =L 
1
2
m
X
i=1
G
(i)
0
G
(i)
0
; (18)
where operators L and G
(i)
0
; i = 1;:::;m are de ned by (4), (5).
De ne the following sequence of differential operators
 
G
(i)
p
def
=
1
p
 
 
G
(i)
p 1
 
L 
 
L
 
G
(i)
p 1
 
; p = 1; 2;:::; i = 1;:::;m; (19)
where
 
G
(i)
0
def
= G
(i)
0
; i = 1;:::;m: The operators
 
L and G
(i)
0
; i = 1;:::;m are
de ned by (18) and (5) correspondingly.
For the further consideration, we need to introduce the following set of
iterated Stratonovich stochastic integrals
I
 (i
1
:::i
k
)
(l
1
:::l
k
)s;t
=
 s
Z
t
(t t
k
)
l
k
:::
 t
2
Z
t
(t t
1
)
l
1
dw
(i
1
)
t
1
:::dw
(i
k
)
t
k
; (20)
where l
1
;:::;l
k
= 0; 1;::: and i
1
;:::;i
k
= 1;:::;m:
Assume that R(x;t), a(x;t); and B
i
(x;t); i = 1;:::;m are enough smooth
functions with respect to the variables x and t. Then for all s;t2 [0;T ] such
that s > t we can write the following uni ed Taylor{Stratonovich expansion
[25] (also see [26], Chapter 4)
R(x
s
;s) =
=R(x
t
;t) +
r
X
q=1
X
(k;j;l
1
;:::;l
k
)2D
q
(s t)
j
j!
m
X
i
1
;:::;i
k
=1
 
G
(i
1
)
l
1
:::
 
G
(i
k
)
l
k
 
L
j
R(x
t
;t) I
 (i
1
:::i
k
)
(l
1
:::l
k
)s;t
+
+
 
 
H
r+1
 
s;t
w. p. 1; (21)
where
 
L
j
R(x;t)
def
=
8
>
>
>
<
>
>
>
:
 
L:::
 
L
| {z }
j
R(x;t) for j  1
R(x;t) for j = 0
;
the set D
q
is de ned by the equality (8) and
 
 
H
r+1
 
s;t
is the remainder term in
integral form [25] (also see [26], Chapter 4).
Electronic Journal. http://diffjournal.spbu.ru/ 109Differential Equations and Control Processes, N. 1, 2021
Consider the partition (9) of the interval [0;T ]: From (21) for s =  
p+1
and t =  
p
we obtain the following representation of explicit one-step strong
numerical scheme for the It^ o SDE (1)
y
p+1
= y
p
+
r
X
q=1
X
(k;j;l
1
;:::;l
k
)2D
q
( 
p+1
  
p
)
j
j!
m
X
i
1
;:::;i
k
=1
 
G
(i
1
)
l
1
:::
 
G
(i
k
)
l
k
 
L
j
y
p
^
I
 (i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
+
+ 1
fr=2d 1;d2Ng
( 
p+1
  
p
)
(r+1)=2
((r + 1)=2)!
L
(r+1)=2
y
p
; (22)
where
^
I
 (i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
is an approximation of the iterated Stratonovich stochastic
integral (20) and 1
A
is the indicator of the setA: Note that we understand the
equality (22) componentwise with respect to the components y
(i)
p
of the column
y
p
: Also for simplicity we put  
p
=p ,   =T=N; p = 0; 1;:::;N:
Under the appropriate conditions [2] the numerical scheme (22) has strong
order r=2 (r2N) of convergence.
Denote
  a(x;t) = a(x;t) 
1
2
m
X
j=1
G
(j)
0
B
j
(x;t);
where B
j
(x;t) is the jth column of the matrix function B(x;t):
It is not di cult to show that (see (18))
 
L =
@
@t
+
n
X
i=1
  a
(i)
(x;t)
@
@x
(i)
; (23)
where   a
(i)
(x;t) is the ith component of the vector function   a(x;t):
Below we consider particular cases of the numerical scheme (22) for r =
2; 3; 4; 5; and 6; i.e. explicit one-step strong numerical schemes with convergence
orders 1:0; 1:5; 2:0; 2:5; and 3:0 for the It^ o SDE (1) [26], [66], [67]. At that for
simplicity we will write   a;
 
L  a;La;B
i
;G
(i)
0
B
j
etc. instead of   a(y
p
; 
p
);
 
L  a(y
p
; 
p
);
La(y
p
; 
p
); B
i
(y
p
; 
p
); G
(i)
0
B
j
(y
p
; 
p
) etc. correspondingly.
Scheme with strong order 1.0
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
 (i
1
)
(0) 
p+1
; 
p
+    a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
: (24)
Electronic Journal. http://diffjournal.spbu.ru/ 110Differential Equations and Control Processes, N. 1, 2021
Scheme with strong order 1.5
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
 (i
1
)
(0) 
p+1
; 
p
+    a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
  a
 
 
^
I
 (i
1
)
(0) 
p+1
; 
p
+
^
I
 (i
1
)
(1) 
p+1
; 
p
 
 
 
LB
i
1
^
I
 (i
1
)
(1) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
 (i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
La: (25)
Scheme with strong order 2.0
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
 (i
1
)
(0) 
p+1
; 
p
+    a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
  a
 
 
^
I
 (i
1
)
(0) 
p+1
; 
p
+
^
I
 (i
1
)
(1) 
p+1
; 
p
 
 
 
LB
i
1
^
I
 (i
1
)
(1) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
 (i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
 
L  a+
+
m
X
i
1
;i
2
=1
h
G
(i
1
)
0
 
LB
i
2
 
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
 
 
 
LG
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
+
+G
(i
1
)
0
G
(i
2
)
0
  a
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
+  
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
 i
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
 (i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
: (26)
Scheme with strong order 2.5
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
 (i
1
)
(0) 
p+1
; 
p
+    a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
  a
 
 
^
I
 (i
1
)
(0) 
p+1
; 
p
+
^
I
 (i
1
)
(1) 
p+1
; 
p
 
 
 
LB
i
1
^
I
 (i
1
)
(1) 
p+1
; 
p
i
+
Electronic Journal. http://diffjournal.spbu.ru/ 111Differential Equations and Control Processes, N. 1, 2021
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
 (i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
 
L  a+
+
m
X
i
1
;i
2
=1
h
G
(i
1
)
0
 
LB
i
2
 
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
 
 
 
LG
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
+
+G
(i
1
)
0
G
(i
2
)
0
  a
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
+  
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
 i
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
 (i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
+
+
m
X
i
1
=1
"
G
(i
1
)
0
 
L  a
 
1
2
^
I
 (i
1
)
(2) 
p+1
; 
p
+  
^
I
 (i
1
)
(1) 
p+1
; 
p
+
 
2
2
^
I
 (i
1
)
(0) 
p+1
; 
p
 
+
+
1
2
 
L
 
LB
i
1
^
I
 (i
1
)
(2) 
p+1
; 
p
 
 
LG
(i
1
)
0
  a
 
^
I
 (i
1
)
(2) 
p+1
; 
p
+  
^
I
 (i
1
)
(1) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
=1
h
G
(i
1
)
0
 
LG
(i
2
)
0
B
i
3
 
^
I
 (i
1
i
2
i
3
)
(100) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
 
LB
i
3
 
^
I
 (i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
  a
 
 
^
I
 (i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
^
I
 (i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
 
 
 
LG
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
 (i
1
i
2
i
3
)
(100) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
;i
4
;i
5
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
B
i
5
^
I
 (i
1
i
2
i
3
i
4
i
5
)
(00000) 
p+1
; 
p
+
+
 
3
6
LLa: (27)
Scheme with strong order 3.0
y
p+1
= y
p
+
m
X
i
1
=1
B
i
1
^
I
 (i
1
)
(0) 
p+1
; 
p
+    a +
m
X
i
1
;i
2
=1
G
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
+
+
m
X
i
1
=1
h
G
(i
1
)
0
  a
 
 
^
I
 (i
1
)
(0) 
p+1
; 
p
+
^
I
 (i
1
)
(1) 
p+1
; 
p
 
 
 
LB
i
1
^
I
 (i
1
)
(1) 
p+1
; 
p
i
+
Electronic Journal. http://diffjournal.spbu.ru/ 112Differential Equations and Control Processes, N. 1, 2021
+
m
X
i
1
;i
2
;i
3
=1
G
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
 (i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
 
2
2
 
L  a+
+
m
X
i
1
;i
2
=1
h
G
(i
1
)
0
 
LB
i
2
 
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
 
 
 
LG
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
+
+G
(i
1
)
0
G
(i
2
)
0
  a
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
+  
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
 i
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
 (i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
+ q
p+1;p
+ r
p+1;p
; (28)
where
q
p+1;p
=
m
X
i
1
=1
"
G
(i
1
)
0
 
L  a
 
1
2
^
I
 (i
1
)
(2) 
p+1
; 
p
+  
^
I
 (i
1
)
(1) 
p+1
; 
p
+
 
2
2
^
I
 (i
1
)
(0) 
p+1
; 
p
 
+
+
1
2
 
L
 
LB
i
1
^
I
 (i
1
)
(2) 
p+1
; 
p
 
 
LG
(i
1
)
0
  a
 
^
I
 (i
1
)
(2) 
p+1
; 
p
+  
^
I
 (i
1
)
(1) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
=1
h
G
(i
1
)
0
 
LG
(i
2
)
0
B
i
3
 
^
I
 (i
1
i
2
i
3
)
(100) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
 
LB
i
3
 
^
I
 (i
1
i
2
i
3
)
(010) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
  a
 
 
^
I
 (i
1
i
2
i
3
)
(000) 
p+1
; 
p
+
^
I
 (i
1
i
2
i
3
)
(001) 
p+1
; 
p
 
 
 
 
LG
(i
1
)
0
G
(i
2
)
0
B
i
3
^
I
 (i
1
i
2
i
3
)
(100) 
p+1
; 
p
i
+
+
m
X
i
1
;i
2
;i
3
;i
4
;i
5
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
B
i
5
^
I
 (i
1
i
2
i
3
i
4
i
5
)
(00000) 
p+1
; 
p
+
+
 
3
6
 
L
 
L  a;
and
r
p+1;p
=
m
X
i
1
;i
2
=1
"
G
(i
1
)
0
G
(i
2
)
0
 
L  a
 
1
2
^
I
 (i
1
i
2
)
(02) 
p+1
; 
p
+  
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
+
 
2
2
^
I
 (i
1
i
2
)
(00) 
p+1
; 
p
!
+
+
1
2
 
L
 
LG
(i
1
)
0
B
i
2
^
I
 (i
1
i
2
)
(20) 
p+1
; 
p
+
Electronic Journal. http://diffjournal.spbu.ru/ 113Differential Equations and Control Processes, N. 1, 2021
+G
(i
1
)
0
 
LG
(i
2
)
0
  a
 
^
I
 (i
1
i
2
)
(11) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(02) 
p+1
; 
p
+  
 
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(01) 
p+1
; 
p
  
+
+
 
LG
(i
1
)
0
 
LB
i
2
 
^
I
 (i
1
i
2
)
(11) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(20) 
p+1
; 
p
 
+
+G
(i
1
)
0
 
L
 
LB
i
2
 
1
2
^
I
 (i
1
i
2
)
(02) 
p+1
; 
p
+
1
2
^
I
 (i
1
i
2
)
(20) 
p+1
; 
p
 
^
I
 (i
1
i
2
)
(11) 
p+1
; 
p
!
 
 
 
LG
(i
1
)
0
G
(i
2
)
0
  a
 
 
^
I
 (i
1
i
2
)
(10) 
p+1
; 
p
+
^
I
 (i
1
i
2
)
(11) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
;i
4
=1
"
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
  a
 
 
^
I
 (i
1
i
2
i
3
i
4
)
(0000) 
p+1
; 
p
+
^
I
 (i
1
i
2
i
3
i
4
)
(0001) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
 
LG
(i
3
)
0
B
i
4
 
^
I
 (i
1
i
2
i
3
i
4
)
(0100) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
i
4
)
(0010) 
p+1
; 
p
 
 
 
 
LG
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
B
i
4
^
I
 (i
1
i
2
i
3
i
4
)
(1000) 
p+1
; 
p
+
+G
(i
1
)
0
 
LG
(i
2
)
0
G
(i
3
)
0
B
i
4
 
^
I
 (i
1
i
2
i
3
i
4
)
(1000) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
i
4
)
(0100) 
p+1
; 
p
 
+
+G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
 
LB
i
4
 
^
I
 (i
1
i
2
i
3
i
4
)
(0010) 
p+1
; 
p
 
^
I
 (i
1
i
2
i
3
i
4
)
(0001) 
p+1
; 
p
 
#
+
+
m
X
i
1
;i
2
;i
3
;i
4
;i
5
;i
6
=1
G
(i
1
)
0
G
(i
2
)
0
G
(i
3
)
0
G
(i
4
)
0
G
(i
5
)
0
B
i
6
^
I
 (i
1
i
2
i
3
i
4
i
5
i
6
)
(000000) 
p+1
; 
p
:
Under the suitable conditions [2] the numerical schemes (24){(28) have
strong orders 1.0, 1.5, 2.0, 2.5, and 3.0 of convergence correspondingly. Among
these conditions we consider only the condition for approximations of iterated
Stratonovich stochastic integrals from (24){(28) [2] (also see [42])
M
8
<
:
 
I
 (i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
 
^
I
 (i
1
:::i
k
)
(l
1
:::l
k
) 
p+1
; 
p
!
2
9
=
;
 C 
r+1
; (29)
where constantC is independent of   andr=2 are the strong convergence orders
for the numerical schemes (24){(28), i.e. r=2 = 1:0; 1:5; 2:0; 2:5; and 3:0:
Note that the numerical schemes (24){(28) are unrealizable in practice with-
out procedures for the numerical simulation of iterated Stratonovich stochastic
Electronic Journal. http://diffjournal.spbu.ru/ 114Differential Equations and Control Processes, N. 1, 2021
integrals from (22). The next section is devoted to the effective method of the
mean-square approximation of iterated It^ o and Stratonovich stochastic integrals
of arbitrary multiplicity k (k2N).
2.3 Method of Expansion and Approximation of Iterated It^ o and
Stratonovich Stochastic Integrals Based on Generalized Multi-
ple Fourier Series
Let us consider the effective approach to expansion of iterated It^ o stochastic
integrals [42] (2006) (also see [26], [44]-[46], [58], [61], [67], [68]). This method
is reffered to as the method of generalized multiple Fourier series.
Suppose that every 
l
( ) (l = 1;:::;k) is a continuous nonrandom function
on [t;T ]. De ne the following function on the hypercube [t;T ]
k
K(t
1
;:::;t
k
) =
8
>
<
>
:
 
1
(t
1
)::: 
k
(t
k
) for t
1
<:::<t
k
0 otherwise
; t
1
;:::;t
k
2 [t;T ];
(30)
where k  2 and K(t
1
)  
1
(t
1
) for t
1
2 [t;T ]:
Suppose thatf 
j
(x)g
1
j=0
is a complete orthonormal system of functions in
the space L
2
([t;T ]).
The function K(t
1
;:::;t
k
) is piecewise continuous in the hypercube [t;T ]
k
:
At this situation it is well known that the generalized multiple Fourier series of
K(t
1
;:::;t
k
)2L
2
([t;T ]
k
) is converging toK(t
1
;:::;t
k
) in the hypercube [t;T ]
k
in the mean-square sense, i.e.
lim
p
1
;:::;p
k
!1





K(t
1
;:::;t
k
) 
p
1
X
j
1
=0
:::
p
k
X
j
k
=0
C
j
k
:::j
1
k
Y
l=1
 
j
l
(t
l
)





L
2
([t;T ]
k
)
= 0;
where
C
j
k
:::j
1
=
Z
[t;T ]
k
K(t
1
;:::;t
k
)
k
Y
l=1
 
j
l
(t
l
)dt
1
:::dt
k
(31)
is the Fourier coe cient and
kfk
L
2
([t;T ]
k
)
=
0
B
@
Z
[t;T ]
k
f
2
(t
1
;:::;t
k
)dt
1
:::dt
k
1
C
A
1=2
:
Electronic Journal. http://diffjournal.spbu.ru/ 115Differential Equations and Control Processes, N. 1, 2021
Consider the partitionf 
j
g
N
j=0
of the interval [t;T ] such that
t = 
0
<:::< 
N
=T;  
N
= max
0 j N 1
  
j
! 0 if N!1;   
j
= 
j+1
  
j
:
(32)
Theorem 1 [42] (2006) (also see [26],[44]-[46], [58], [61], [67], [68]). Suppose
that every 
l
( ) (l = 1;:::;k) is a continuous nonrandom function on [t;T ]
andf 
j
(x)g
1
j=0
is a complete orthonormal system of continuous functions in
the space L
2
([t;T ]): Then
J[ 
(k)
]
T;t
= l.i.m.
p
1
;:::;p
k
!1
p
1
X
j
1
=0
:::
p
k
X
j
k
=0
C
j
k
:::j
1
 
k
Y
l=1
 
(i
l
)
j
l
 
  l.i.m.
N!1
X
(l
1
;:::;l
k
)2G
k
 
j
1
( 
l
1
) w
(i
1
)
 
l
1
::: 
j
k
( 
l
k
) w
(i
k
)
 
l
k
!
; (33)
where J[ 
(k)
]
T;t
is de ned by (2),
G
k
= H
k
nL
k
; H
k
=f(l
1
;:::;l
k
) : l
1
;:::;l
k
= 0; 1;:::;N  1g;
L
k
=f(l
1
;:::;l
k
) : l
1
;:::;l
k
= 0; 1;:::;N  1; l
g
6=l
r
(g6=r); g;r = 1;:::;kg;
l:i:m: is a limit in the mean-square sense; i
1
;:::;i
k
= 0; 1;:::;m;
 
(i)
j
=
T
Z
t
 
j
(s)dw
(i)
s
(34)
are independent standard Gaussian random variables for various i or j (in the
case when i6= 0), C
j
k
:::j
1
is the Fourier coe cient (31),  w
(i)
 
j
= w
(i)
 
j+1
  w
(i)
 
j
(i = 0; 1;:::;m);f 
j
g
N
j=0
is a partition of the interval [t;T ]; which satis es the
condition (32).
Note that a number of modi cations and generalizations of Theorem 1 can
be found in [26], [67].
Consider transformed particular cases of (33) fork = 1;:::; 6 [26], [58], [61],
[67], [68]
J[ 
(1)
]
T;t
= l.i.m.
p
1
!1
p
1
X
j
1
=0
C
j
1
 
(i
1
)
j
1
; (35)
Electronic Journal. http://diffjournal.spbu.ru/ 116Differential Equations and Control Processes, N. 1, 2021
J[ 
(2)
]
T;t
= l.i.m.
p
1
;p
2
!1
p
1
X
j
1
=0
p
2
X
j
2
=0
C
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
  1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
!
; (36)
J[ 
(3)
]
T;t
= l.i.m.
p
1
;:::;p
3
!1
p
1
X
j
1
=0
p
2
X
j
2
=0
p
3
X
j
3
=0
C
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
 1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
3
)
j
3
  1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
1
)
j
1
  1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
2
)
j
2
!
; (37)
J[ 
(4)
]
T;t
= l.i.m.
p
1
;:::;p
4
!1
p
1
X
j
1
=0
:::
p
4
X
j
4
=0
C
j
4
:::j
1
 
4
Y
l=1
 
(i
l
)
j
l
 
 1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
 1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
 1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
  1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
+ 1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
+
+ 1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
!
; (38)
J[ 
(5)
]
T;t
= l.i.m.
p
1
;:::;p
5
!1
p
1
X
j
1
=0
:::
p
5
X
j
5
=0
C
j
5
:::j
1
 
5
Y
l=1
 
(i
l
)
j
l
 
 1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
5
)
j
5
 
 1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
5
)
j
5
  1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
5
)
j
5
 
 1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
5
)
j
5
 
 1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
4
)
j
4
  1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
+
+1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
5
)
j
5
+ 1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
4
)
j
4
+
+1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
3
)
j
3
+ 1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
5
)
j
5
+
+1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
4
)
j
4
+ 1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
2
)
j
2
+
+1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
5
)
j
5
+ 1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
3
)
j
3
+
Electronic Journal. http://diffjournal.spbu.ru/ 117Differential Equations and Control Processes, N. 1, 2021
+1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
2
)
j
2
+ 1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
4
)
j
4
+
+1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
3
)
j
3
+ 1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
2
)
j
2
+
+1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
1
)
j
1
+ 1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
1
)
j
1
+
+ 1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
!
; (39)
J[ 
(6)
]
T;t
= l.i.m.
p
1
;:::;p
6
!1
p
1
X
j
1
=0
:::
p
6
X
j
6
=0
C
j
6
:::j
1
 
6
Y
l=1
 
(i
l
)
j
l
 
 1
fi
1
=i
6
6=0g
1
fj
1
=j
6
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fi
2
=i
6
6=0g
1
fj
2
=j
6
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
 
 1
fi
3
=i
6
6=0g
1
fj
3
=j
6
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fi
4
=i
6
6=0g
1
fj
4
=j
6
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
5
)
j
5
 
 1
fi
5
=i
6
6=0g
1
fj
5
=j
6
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
 
 1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
  1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
5
)
j
5
 
(i
6
)
j
6
 
 1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
6
)
j
6
  1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
 
 1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
5
)
j
5
 
(i
6
)
j
6
  1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
6
)
j
6
 
 1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
5
)
j
5
 
(i
6
)
j
6
  1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
6
)
j
6
 
 1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
6
)
j
6
+
+1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
5
)
j
5
 
(i
6
)
j
6
+
+1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
4
)
j
4
 
(i
6
)
j
6
+
+1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
3
)
j
3
 
(i
6
)
j
6
+
+1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
5
)
j
5
 
(i
6
)
j
6
+
+1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
4
)
j
4
 
(i
6
)
j
6
+
+1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
2
)
j
2
 
(i
6
)
j
6
+
+1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
5
)
j
5
 
(i
6
)
j
6
+
+1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
3
)
j
3
 
(i
6
)
j
6
+
+1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
2
)
j
2
 
(i
6
)
j
6
+
Electronic Journal. http://diffjournal.spbu.ru/ 118Differential Equations and Control Processes, N. 1, 2021
+1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
4
)
j
4
 
(i
6
)
j
6
+
+1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
3
)
j
3
 
(i
6
)
j
6
+
+1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
2
)
j
2
 
(i
6
)
j
6
+
+1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
1
)
j
1
 
(i
6
)
j
6
+
+1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
1
)
j
1
 
(i
6
)
j
6
+
+1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
6
)
j
6
+
+1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
2
)
j
2
 
(i
5
)
j
5
+
+1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
2
)
j
2
 
(i
4
)
j
4
+
+1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
3
)
j
3
 
(i
4
)
j
4
+
+1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
3
)
j
3
 
(i
5
)
j
5
+
+1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
+
+1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
4
)
j
4
 
(i
5
)
j
5
+
+1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
1
)
j
1
 
(i
4
)
j
4
+
+1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
+
+1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
5
)
j
5
+
+1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
 
(i
3
)
j
3
 
(i
4
)
j
4
+
+1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
 
(i
3
)
j
3
 
(i
5
)
j
5
+
+1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
4
)
j
4
 
(i
5
)
j
5
+
+1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
1
)
j
1
 
(i
4
)
j
4
+
+1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
5
)
j
5
+
+1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
 
(i
2
)
j
2
 
(i
4
)
j
4
+
+1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
5
)
j
5
+
+1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
4
)
j
4
 
(i
5
)
j
5
+
+1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
Electronic Journal. http://diffjournal.spbu.ru/ 119Differential Equations and Control Processes, N. 1, 2021
+1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
+
+1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
5
)
j
5
+
+1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
+
+1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
5
)
j
5
+
+1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
5
)
j
5
+
+1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
+
+1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
+
+1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
+
+1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
+
+1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
 1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
 1
fi
6
=i
1
6=0g
1
fj
6
=j
1
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
 1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
 1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
 1
fi
6
=i
2
6=0g
1
fj
6
=j
2
g
1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
 1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
 
 1
fi
6
=i
3
6=0g
1
fj
6
=j
3
g
1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
 1
fi
3
=i
6
6=0g
1
fj
3
=j
6
g
1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
4
=i
5
6=0g
1
fj
4
=j
5
g
 
 1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
1
=i
5
6=0g
1
fj
1
=j
5
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
 1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
5
6=0g
1
fj
2
=j
5
g
 
 1
fi
6
=i
4
6=0g
1
fj
6
=j
4
g
1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
5
6=0g
1
fj
3
=j
5
g
 
 1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
1
=i
4
6=0g
1
fj
1
=j
4
g
1
fi
2
=i
3
6=0g
1
fj
2
=j
3
g
 
 1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
1
=i
2
6=0g
1
fj
1
=j
2
g
1
fi
3
=i
4
6=0g
1
fj
3
=j
4
g
 
 1
fi
6
=i
5
6=0g
1
fj
6
=j
5
g
1
fi
1
=i
3
6=0g
1
fj
1
=j
3
g
1
fi
2
=i
4
6=0g
1
fj
2
=j
4
g
!
; (40)
Electronic Journal. http://diffjournal.spbu.ru/ 120Differential Equations and Control Processes, N. 1, 2021
where 1
A
is the indicator of the set A.
A detailed discussion of advantages of the method based on Theorem 1 over
the approximation methods from works [2], [3], [7], [8], [27]-[35], [37]-[39] can
be found in [26] (Section 1.1.10) or in [67].
As it turned out, Theorem 1 can be adapted for the iterated Stratonovich
stochastic integrals (3) of multiplicities 1 to 5 [26], [67]-[69] (also see bibliogra-
phy therein). Let as collect some of these results in the following theorem.
Theorem 2 [26], [67]-[69]. Suppose thatf 
j
(x)g
1
j=0
is a complete orthonor-
mal system of Legendre polynomials or trigonometric functions in the space
L
2
([t;T ]): At the same time 
2
(s) is a continuously differentiable function on
[t;T ] and 
1
(s); 
3
(s) are twice continuously differentiable functions on [t;T ].
Then
J
 
[ 
(2)
]
T;t
= l.i.m.
p
1
;p
2
!1
p
1
X
j
1
=0
p
2
X
j
2
=0
C
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
(i
1
;i
2
= 1;:::;m); (41)
J
 
[ 
(3)
]
T;t
= l.i.m.
p
1
;p
2
;p
3
!1
p
1
X
j
1
=0
p
2
X
j
2
=0
p
3
X
j
3
=0
C
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
(i
1
;i
2
;i
3
= 0; 1;:::;m);
(42)
J
 
[ 
(3)
]
T;t
= l.i.m.
p!1
p
X
j
1
;j
2
;j
3
=0
C
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
(i
1
;i
2
;i
3
= 1;:::;m); (43)
J
 
[ 
(4)
]
T;t
= l.i.m.
p!1
p
X
j
1
;:::;j
4
=0
C
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
(i
1
;:::;i
4
= 0; 1;:::;m);
(44)
J
 
[ 
(5)
]
T;t
= l.i.m.
p!1
p
X
j
1
;:::;j
5
=0
C
j
5
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
(i
1
;:::;i
5
= 0; 1;:::;m);
(45)
where J
 
[ 
(k)
]
T;t
is de ned by (3), and 
l
(s)  1 (l = 1;:::; 5) in (42), (44),
(45); another notations are the same as in Theorem 1.
Consider the following Hypothesis on expansion of the iterated Stratonovich
stochastic integrals (3) of arbitrary multiplicity k (k2N).
Hypothesis 1 [26], [67], [68]. Assume thatf 
j
(x)g
1
j=0
is a complete or-
thonormal system of Legendre polynomials or trigonometric functions in the
Electronic Journal. http://diffjournal.spbu.ru/ 121Differential Equations and Control Processes, N. 1, 2021
spaceL
2
([t;T ]). Moreover, every 
l
( ) (l = 1;:::;k) is an enough smooth non-
random function on [t;T ]: Then, for the iterated Stratonovich stochastic integral
(3) of multiplicity k the following expansion
J
 
[ 
(k)
]
T;t
= l.i.m.
p!1
p
X
j
1
;:::j
k
=0
C
j
k
:::j
1
k
Y
l=1
 
(i
l
)
j
l
(46)
that converges in the mean-square sense is valid, where notations are the same
as in Theorem 1.
Hypothesis 1 allows to approximate the iterated Stratonovich stochastic
integral J
 
[ 
(k)
]
T;t
by the sum
J
 
[ 
(k)
]
p
T;t
=
p
X
j
1
;:::j
k
=0
C
j
k
:::j
1
k
Y
l=1
 
(i
l
)
j
l
; (47)
where
lim
p!1
M
8
<
:
 
J
 
[ 
(k)
]
T;t
 J
 
[ 
(k)
]
p
T;t
!
2
9
=
;
= 0:
Assume that J[ 
(k)
]
p
T;t
is the approximation of (2), which is the expression
in (33) before passing to the limit for the case p
1
=::: =p
k
=p, i.e.
J[ 
(k)
]
p
T;t
=
p
X
j
1
;:::;j
k
=0
C
j
k
:::j
1
 
k
Y
l=1
 
(i
l
)
j
l
 
  l.i.m.
N!1
X
(l
1
;:::;l
k
)2G
k
 
j
1
( 
l
1
) w
(i
1
)
 
l
1
::: 
j
k
( 
l
k
) w
(i
k
)
 
l
k
!
: (48)
Let us denote
M
 
 
J[ 
(k)
]
T;t
 J[ 
(k)
]
p
T;t
 
2
 
def
= E
p
k
;
kKk
2
L
2
([t;T ]
k
)
=
Z
[t;T ]
k
K
2
(t
1
;:::;t
k
)dt
1
:::dt
k
def
= I
k
:
For the futher consideration, we need the following useful estimate [26], [67]
E
p
k
 k!
 
I
k
 
p
X
j
1
;:::;j
k
=0
C
2
j
k
:::j
1
!
; (49)
Electronic Journal. http://diffjournal.spbu.ru/ 122Differential Equations and Control Processes, N. 1, 2021
where i
1
;:::;i
k
= 1;:::;m for T t2 (0;1) and i
1
;:::;i
k
= 0; 1;:::;m for
T t2 (0; 1); another notations are the same as in Theorem 1.
The value E
p
k
can be calculated exactly.
Theorem 3 [26], [67], [70]. Suppose that the conditions of Theorem 1 are
satis ed. Then
E
p
k
=I
k
 
p
X
j
1
;:::;j
k
=0
C
j
k
:::j
1
 
 M
8
<
:
J[ 
(k)
]
T;t
X
(j
1
;:::;j
k
)
T
Z
t
 
j
k
(t
k
):::
t
2
Z
t
 
j
1
(t
1
)dw
(i
1
)
t
1
:::dw
(i
k
)
t
k
9
=
;
; (50)
where i
1
;:::;i
k
= 1;:::;m; expression
X
(j
1
;:::;j
k
)
means the sum with respect to all possible permutations (j
1
;:::;j
k
): At the same
time if j
r
swapped with j
q
in the permutation (j
1
;:::;j
k
), then i
r
swapped with
i
q
in the permutation (i
1
;:::;i
k
); another notations are the same as in Theorem
1.
Note that
M
8
<
:
J[ 
(k)
]
T;t
T
Z
t
 
j
k
(t
k
):::
t
2
Z
t
 
j
1
(t
1
)dw
(i
1
)
t
1
:::dw
(i
k
)
t
k
9
=
;
=C
j
k
:::j
1
:
Then from Theorem 3 we obtain
E
p
k
=I
k
 
p
X
j
1
;:::;j
k
=0
C
2
j
k
:::j
1
(i
1
;:::;i
k
are pairwise different); (51)
E
p
k
=I
k
 
p
X
j
1
;:::;j
k
=0
C
j
k
:::j
1
0
@
X
(j
1
;:::;j
k
)
C
j
k
:::j
1
1
A
(i
1
=::: =i
k
): (52)
Consider some examples of the application of Theorem 3 (i
1
;:::;i
5
=
1;:::;m):
E
p
2
=I
2
 
p
X
j
1
;j
2
=0
C
2
j
2
j
1
 
p
X
j
1
;j
2
=0
C
j
2
j
1
C
j
1
j
2
(i
1
=i
2
); (53)
Electronic Journal. http://diffjournal.spbu.ru/ 123Differential Equations and Control Processes, N. 1, 2021
E
p
3
=I
3
 
p
X
j
3
;j
2
;j
1
=0
C
2
j
3
j
2
j
1
 
p
X
j
3
;j
2
;j
1
=0
C
j
3
j
1
j
2
C
j
3
j
2
j
1
(i
1
=i
2
6=i
3
); (54)
E
p
3
=I
3
 
p
X
j
3
;j
2
;j
1
=0
C
2
j
3
j
2
j
1
 
p
X
j
3
;j
2
;j
1
=0
C
j
2
j
3
j
1
C
j
3
j
2
j
1
(i
1
6=i
2
=i
3
); (55)
E
p
3
=I
3
 
p
X
j
3
;j
2
;j
1
=0
C
2
j
3
j
2
j
1
 
p
X
j
3
;j
2
;j
1
=0
C
j
3
j
2
j
1
C
j
1
j
2
j
3
(i
1
=i
3
6=i
2
); (56)
E
p
4
=I
4
 
p
X
j
1
;:::;j
4
=0
C
j
4
:::j
1
0
@
X
(j
1
;j
2
)
C
j
4
:::j
1
1
A
(i
1
=i
2
6=i
3
;i
4
; i
3
6=i
4
); (57)
E
p
4
=I
4
 
p
X
j
1
;:::;j
4
=0
C
j
4
:::j
1
0
@
X
(j
1
;j
3
)
C
j
4
:::j
1
1
A
(i
1
=i
3
6=i
2
;i
4
; i
2
6=i
4
); (58)
E
p
4
=I
4
 
p
X
j
1
;:::;j
4
=0
C
j
4
:::j
1
0
@
X
(j
2
;j
3
)
C
j
4
:::j
1
1
A
(i
2
=i
3
6=i
1
;i
4
; i
1
6=i
4
); (59)
E
p
4
=I
4
 
p
X
j
1
;:::;j
4
=0
C
j
4
:::j
1
0
@
X
(j
1
;j
4
)
C
j
4
:::j
1
1
A
(i
1
=i
4
6=i
2
;i
3
; i
2
6=i
3
); (60)
E
p
4
=I
4
 
p
X
j
1
;:::;j
4
=0
C
j
4
:::j
1
0
@
X
(j
1
;j
4
)
0
@
X
(j
2
;j
3
)
C
j
4
:::j
1
1
A
1
A
(i
1
=i
4
6=i
2
=i
3
); (61)
E
p
4
=I
4
 
p
X
j
1
;:::;j
4
=0
C
j
4
:::j
1
0
@
X
(j
1
;j
2
;j
3
)
C
j
4
:::j
1
1
A
(i
1
=i
2
=i
3
6=i
4
); (62)
E
p
5
=I
5
 
p
X
j
1
;:::;j
5
=0
C
j
5
:::j
1
0
@
X
(j
1
;j
2
)
C
j
5
:::j
1
1
A
; (63)
where i
1
=i
2
6=i
3
;i
4
;i
5
and i
3
;i
4
;i
5
are pairwise different,
E
p
5
=I
5
 
p
X
j
1
;:::;j
5
=0
C
j
5
:::j
1
0
@
X
(j
2
;j
3
)
C
j
5
:::j
1
1
A
; (64)
where i
2
=i
3
6=i
1
;i
4
;i
5
and i
1
;i
4
;i
5
are pairwise different,
Electronic Journal. http://diffjournal.spbu.ru/ 124Differential Equations and Control Processes, N. 1, 2021
E
p
5
=I
5
 
p
X
j
1
;:::;j
5
=0
C
j
5
:::j
1
0
@
X
(j
4
;j
5
)
C
j
5
:::j
1
1
A
; (65)
where i
4
=i
5
6=i
1
;i
2
;i
3
and i
1
;i
2
;i
3
are pairwise different,
E
p
5
=I
5
 
p
X
j
1
;:::;j
5
=0
C
j
5
:::j
1
0
@
X
(j
2
;j
4
)
0
@
X
(j
3
;j
5
)
C
j
5
:::j
1
1
A
1
A
(i
1
6=i
2
=i
4
6=i
3
=i
5
6=i
1
):
(66)
2.4 Approximations of Iterated It^ o Stochastic Integrals from the
Numerical Schemes (11){(16) Using Legendre Polynomials
This section is devoted to approximation of the iterated It^ o stochastic integrals
(6) of multiplicities 1 to 6 based on Theorem 1. At that we will use multiple
Fourier{Legendre series for approximation of the mentioned stochastic integrals.
The numerical schemes (11){(16) contain the following set (see (6)) of iter-
ated It^ o stochastic integrals
I
(i
1
)
(0)T;t
; I
(i
1
)
(1)T;t
; I
(i
1
)
(2)T;t
; I
(i
1
i
2
)
(00)T;t
; I
(i
1
i
2
)
(10)T;t
; I
(i
1
i
2
)
(01)T;t
; I
(i
1
i
2
i
3
)
(000)T;t
; I
(i
1
i
2
i
3
i
4
)
(0000)T;t
; (67)
I
(i
1
i
2
i
3
i
4
i
5
)
(00000)T;t
; I
(i
1
i
2
)
(02)T;t
; I
(i
1
i
2
)
(20)T;t
; I
(i
1
i
2
)
(11)T;t
; I
(i
1
i
2
i
3
)
(100)T;t
; I
(i
1
i
2
i
3
)
(010)T;t
; I
(i
1
i
2
i
3
)
(001)T;t
; (68)
I
(i
1
i
2
i
3
i
4
)
(0001)T;t
; I
(i
1
i
2
i
3
i
4
)
(0010)T;t
; I
(i
1
i
2
i
3
i
4
)
(0100)T;t
; I
(i
1
i
2
i
3
i
4
)
(1000)T;t
; I
(i
1
i
2
i
3
i
4
i
5
i
6
)
(000000)T;t
: (69)
Let us consider the complete orthonormal system of Legendre polynomials
in the space L
2
([t;T ])
 
j
(x) =
r
2j + 1
T t
P
j
  
x 
T +t
2
 
2
T t
 
; j = 0; 1; 2;:::; (70)
where P
j
(x) is the Legendre polynomial
P
j
(x) =
1
2
j
j!
d
j
dx
j
 
x
2
  1
 
j
:
Using Theorem 1 and well known properties of the Legendre polynomials, we
obtain the following formulas for numerical modeling of the stochastic integrals
(67){(69) [26], [42]-[46], [58], [61], [67], [68], [70]-[72]
I
(i
1
)
(0)T;t
=
p
T t 
(i
1
)
0
; (71)
Electronic Journal. http://diffjournal.spbu.ru/ 125Differential Equations and Control Processes, N. 1, 2021
I
(i
1
)
(1)T;t
= 
(T t)
3=2
2
 
 
(i
1
)
0
+
1
p
3
 
(i
1
)
1
 
; (72)
I
(i
1
)
(2)T;t
=
(T t)
5=2
3
 
 
(i
1
)
0
+
p
3
2
 
(i
1
)
1
+
1
2
p
5
 
(i
1
)
2
!
; (73)
I
(i
1
i
2
)q
(00)T;t
=
T t
2
 
 
(i
1
)
0
 
(i
2
)
0
+
q
X
i=1
1
p
4i
2
  1
 
 
(i
1
)
i 1
 
(i
2
)
i
  
(i
1
)
i
 
(i
2
)
i 1
 
  1
fi
1
=i
2
g
!
;
(74)
I
(i
1
i
2
i
3
)q
1
(000)T;t
=
q
1
X
j
1
;j
2
;j
3
=0
C
000
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
 1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
!
; (75)
I
(i
1
i
2
)q
2
(10)T;t
=
q
2
X
j
1
;j
2
=0
C
10
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
!
; (76)
I
(i
1
i
2
)q
2
(01)T;t
=
q
2
X
j
1
;j
2
=0
C
01
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
!
; (77)
I
(i
1
i
2
i
3
i
4
)q
3
(0000)T;t
=
q
3
X
j
1
;j
2
;j
3
;j
4
=0
C
0000
j
4
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
 1
fi
1
=i
4
g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
 1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
  1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
+
+ 1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
!
; (78)
I
(i
1
i
2
i
3
i
4
i
5
)q
4
(00000)T;t
=
q
4
X
j
1
;j
2
;j
3
;j
4
;j
5
=0
C
00000
j
5
j
4
j
3
j
2
j
1
 
5
Y
l=1
 
(i
l
)
j
l
 
 1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
5
)
j
5
 
Electronic Journal. http://diffjournal.spbu.ru/ 126Differential Equations and Control Processes, N. 1, 2021
 1
fi
1
=i
4
g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
5
)
j
5
  1
fi
1
=i
5
g
1
fj
1
=j
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
5
)
j
5
 
 1
fi
2
=i
5
g
1
fj
2
=j
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
5
)
j
5
 
 1
fi
3
=i
5
g
1
fj
3
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
4
)
j
4
  1
fi
4
=i
5
g
1
fj
4
=j
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
5
)
j
5
+ 1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
5
g
1
fj
3
=j
5
g
 
(i
4
)
j
4
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
4
=i
5
g
1
fj
4
=j
5
g
 
(i
3
)
j
3
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
5
)
j
5
+
+1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
5
g
1
fj
2
=j
5
g
 
(i
4
)
j
4
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
4
=i
5
g
1
fj
4
=j
5
g
 
(i
2
)
j
2
+
+1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
5
)
j
5
+ 1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
5
g
1
fj
2
=j
5
g
 
(i
3
)
j
3
+
+1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
3
=i
5
g
1
fj
3
=j
5
g
 
(i
2
)
j
2
+ 1
fi
1
=i
5
g
1
fj
1
=j
5
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
4
)
j
4
+
+1
fi
1
=i
5
g
1
fj
1
=j
5
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
3
)
j
3
+ 1
fi
1
=i
5
g
1
fj
1
=j
5
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
2
)
j
2
+
+1
fi
2
=i
3
g
1
fj
2
=j
3
g
1
fi
4
=i
5
g
1
fj
4
=j
5
g
 
(i
1
)
j
1
+ 1
fi
2
=i
4
g
1
fj
2
=j
4
g
1
fi
3
=i
5
g
1
fj
3
=j
5
g
 
(i
1
)
j
1
+
+ 1
fi
2
=i
5
g
1
fj
2
=j
5
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
!
; (79)
I
(i
1
i
2
)q
5
(20)T;t
=
q
5
X
j
1
;j
2
=0
C
20
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
!
; (80)
I
(i
1
i
2
)q
6
(11)T;t
=
q
6
X
j
1
;j
2
=0
C
11
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
!
; (81)
I
(i
1
i
2
)q
7
(02)T;t
=
q
7
X
j
1
;j
2
=0
C
02
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
!
; (82)
I
(i
1
i
2
i
3
)q
8
(001)T;t
=
q
8
X
j
1
;j
2
;j
3
=0
C
001
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
 1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
!
; (83)
Electronic Journal. http://diffjournal.spbu.ru/ 127Differential Equations and Control Processes, N. 1, 2021
I
(i
1
i
2
i
3
)q
9
(010)T;t
=
q
9
X
j
1
;j
2
;j
3
=0
C
010
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
 1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
!
; (84)
I
(i
1
i
2
i
3
)q
10
(100)T;t
=
q
10
X
j
1
;j
2
;j
3
=0
C
100
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
 1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
!
; (85)
I
(i
1
i
2
i
3
i
4
)q
11
(0001)T;t
=
q
11
X
j
1
;j
2
;j
3
;j
4
=0
C
0001
j
4
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
 1
fi
1
=i
4
g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
 1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
  1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
+
+ 1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
!
; (86)
I
(i
1
i
2
i
3
i
4
)q
12
(0010)T;t
q
12
X
j
1
;j
2
;j
3
;j
4
=0
C
0010
j
4
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
 1
fi
1
=i
4
g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
 1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
  1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
+
+ 1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
!
; (87)
Electronic Journal. http://diffjournal.spbu.ru/ 128Differential Equations and Control Processes, N. 1, 2021
I
(i
1
i
2
i
3
i
4
)q
13
(0100)T;t
=
q
13
X
j
1
;j
2
;j
3
;j
4
=0
C
0100
j
4
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
 1
fi
1
=i
4
g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
 1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
  1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
+
+ 1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
!
; (88)
I
(i
1
i
2
i
3
i
4
)q
14
(1000)T;t
=
q
14
X
j
1
;j
2
;j
3
;j
4
=0
C
1000
j
4
j
3
j
2
j
1
 
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
 1
fi
1
=i
2
g
1
fj
1
=j
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fi
1
=i
3
g
1
fj
1
=j
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
 1
fi
1
=i
4
g
1
fj
1
=j
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
  1
fi
2
=i
3
g
1
fj
2
=j
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
 1
fi
2
=i
4
g
1
fj
2
=j
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
  1
fi
3
=i
4
g
1
fj
3
=j
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fi
1
=i
2
g
1
fj
1
=j
2
g
1
fi
3
=i
4
g
1
fj
3
=j
4
g
+ 1
fi
1
=i
3
g
1
fj
1
=j
3
g
1
fi
2
=i
4
g
1
fj
2
=j
4
g
+
+ 1
fi
1
=i
4
g
1
fj
1
=j
4
g
1
fi
2
=i
3
g
1
fj
2
=j
3
g
!
; (89)
I
(i
1
i
2
i
3
i
4
i
5
i
6
)q
15
(000000)T;t
=
q
15
X
j
1
;j
2
;j
3
;j
4
;j
5
;j
6
=0
C
000000
j
6
j
5
j
4
j
3
j
2
j
1
 
6
Y
l=1
 
(i
l
)
j
l
 
 1
fj
1
=j
6
g
1
fi
1
=i
6
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fj
2
=j
6
g
1
fi
2
=i
6
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
 
 1
fj
3
=j
6
g
1
fi
3
=i
6
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
5
)
j
5
  1
fj
4
=j
6
g
1
fi
4
=i
6
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
5
)
j
5
 
 1
fj
5
=j
6
g
1
fi
5
=i
6
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
  1
fj
1
=j
2
g
1
fi
1
=i
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
 
 1
fj
1
=j
3
g
1
fi
1
=i
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
  1
fj
1
=j
4
g
1
fi
1
=i
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
5
)
j
5
 
(i
6
)
j
6
 
 1
fj
1
=j
5
g
1
fi
1
=i
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
6
)
j
6
  1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
 
 1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
5
)
j
5
 
(i
6
)
j
6
  1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
6
)
j
6
 
Electronic Journal. http://diffjournal.spbu.ru/ 129Differential Equations and Control Processes, N. 1, 2021
 1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
5
)
j
5
 
(i
6
)
j
6
  1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
4
)
j
4
 
(i
6
)
j
6
 
 1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
6
)
j
6
+
+1
fj
1
=j
2
g
1
fi
1
=i
2
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
5
)
j
5
 
(i
6
)
j
6
+ 1
fj
1
=j
2
g
1
fi
1
=i
2
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
4
)
j
4
 
(i
6
)
j
6
+
+1
fj
1
=j
2
g
1
fi
1
=i
2
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
3
)
j
3
 
(i
6
)
j
6
+ 1
fj
1
=j
3
g
1
fi
1
=i
3
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
(i
5
)
j
5
 
(i
6
)
j
6
+
+1
fj
1
=j
3
g
1
fi
1
=i
3
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
(i
4
)
j
4
 
(i
6
)
j
6
+ 1
fj
1
=j
3
g
1
fi
1
=i
3
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
2
)
j
2
 
(i
6
)
j
6
+
+1
fj
1
=j
4
g
1
fi
1
=i
4
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
(i
5
)
j
5
 
(i
6
)
j
6
+ 1
fj
1
=j
4
g
1
fi
1
=i
4
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
(i
3
)
j
3
 
(i
6
)
j
6
+
+1
fj
1
=j
4
g
1
fi
1
=i
4
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
2
)
j
2
 
(i
6
)
j
6
+ 1
fj
1
=j
5
g
1
fi
1
=i
5
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
(i
4
)
j
4
 
(i
6
)
j
6
+
+1
fj
1
=j
5
g
1
fi
1
=i
5
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
(i
3
)
j
3
 
(i
6
)
j
6
+ 1
fj
1
=j
5
g
1
fi
1
=i
5
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
2
)
j
2
 
(i
6
)
j
6
+
+1
fj
2
=j
3
g
1
fi
2
=i
3
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
1
)
j
1
 
(i
6
)
j
6
+ 1
fj
2
=j
4
g
1
fi
2
=i
4
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
1
)
j
1
 
(i
6
)
j
6
+
+1
fj
2
=j
5
g
1
fi
2
=i
5
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
1
)
j
1
 
(i
6
)
j
6
+ 1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
2
)
j
2
 
(i
5
)
j
5
+
+1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
2
)
j
2
 
(i
4
)
j
4
+ 1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
(i
3
)
j
3
 
(i
4
)
j
4
+
+1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
(i
3
)
j
3
 
(i
5
)
j
5
+ 1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
+
+1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
(i
4
)
j
4
 
(i
5
)
j
5
+ 1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
1
)
j
1
 
(i
4
)
j
4
+
+1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
+ 1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
1
)
j
1
 
(i
5
)
j
5
+
+1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
1
=j
5
g
1
fi
1
=i
5
g
 
(i
3
)
j
3
 
(i
4
)
j
4
+ 1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
1
=j
4
g
1
fi
1
=i
4
g
 
(i
3
)
j
3
 
(i
5
)
j
5
+
+1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
1
=j
3
g
1
fi
1
=i
3
g
 
(i
4
)
j
4
 
(i
5
)
j
5
+ 1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
(i
1
)
j
1
 
(i
4
)
j
4
+
+1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+ 1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
(i
1
)
j
1
 
(i
5
)
j
5
+
+1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
1
=j
5
g
1
fi
1
=i
5
g
 
(i
2
)
j
2
 
(i
4
)
j
4
+ 1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
1
=j
4
g
1
fi
1
=i
4
g
 
(i
2
)
j
2
 
(i
5
)
j
5
+
+1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
1
=j
2
g
1
fi
1
=i
2
g
 
(i
4
)
j
4
 
(i
5
)
j
5
+ 1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
(i
1
)
j
1
 
(i
3
)
j
3
+ 1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
(i
1
)
j
1
 
(i
5
)
j
5
+
+1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
1
=j
5
g
1
fi
1
=i
5
g
 
(i
2
)
j
2
 
(i
3
)
j
3
+ 1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
1
=j
3
g
1
fi
1
=i
3
g
 
(i
2
)
j
2
 
(i
5
)
j
5
+
+1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
1
=j
2
g
1
fi
1
=i
2
g
 
(i
3
)
j
3
 
(i
5
)
j
5
+ 1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
(i
1
)
j
1
 
(i
2
)
j
2
+
+1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
(i
1
)
j
1
 
(i
3
)
j
3
+ 1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
(i
1
)
j
1
 
(i
4
)
j
4
+
+1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
1
=j
4
g
1
fi
1
=i
4
g
 
(i
2
)
j
2
 
(i
3
)
j
3
+ 1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
1
=j
3
g
1
fi
1
=i
3
g
 
(i
2
)
j
2
 
(i
4
)
j
4
+
+1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
1
=j
2
g
1
fi
1
=i
2
g
 
(i
3
)
j
3
 
(i
4
)
j
4
 
Electronic Journal. http://diffjournal.spbu.ru/ 130Differential Equations and Control Processes, N. 1, 2021
 1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
 1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
 1
fj
6
=j
1
g
1
fi
6
=i
1
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
 1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
1
=j
5
g
1
fi
1
=i
5
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
 1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
1
=j
4
g
1
fi
1
=i
4
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
 1
fj
6
=j
2
g
1
fi
6
=i
2
g
1
fj
1
=j
3
g
1
fi
1
=i
3
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
 1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
1
=j
5
g
1
fi
1
=i
5
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
 
 1
fj
6
=j
3
g
1
fi
6
=i
3
g
1
fj
1
=j
4
g
1
fi
1
=i
4
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
 1
fj
3
=j
6
g
1
fi
3
=i
6
g
1
fj
1
=j
2
g
1
fi
1
=i
2
g
1
fj
4
=j
5
g
1
fi
4
=i
5
g
 
 1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
1
=j
5
g
1
fi
1
=i
5
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
 1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
1
=j
3
g
1
fi
1
=i
3
g
1
fj
2
=j
5
g
1
fi
2
=i
5
g
 
 1
fj
6
=j
4
g
1
fi
6
=i
4
g
1
fj
1
=j
2
g
1
fi
1
=i
2
g
1
fj
3
=j
5
g
1
fi
3
=i
5
g
 
 1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
1
=j
4
g
1
fi
1
=i
4
g
1
fj
2
=j
3
g
1
fi
2
=i
3
g
 
 1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
1
=j
2
g
1
fi
1
=i
2
g
1
fj
3
=j
4
g
1
fi
3
=i
4
g
 
 1
fj
6
=j
5
g
1
fi
6
=i
5
g
1
fj
1
=j
3
g
1
fi
1
=i
3
g
1
fj
2
=j
4
g
1
fi
2
=i
4
g
!
; (90)
where 1
A
is the indicator of the set A and
C
000
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
8
(T t)
3=2
 
C
000
j
3
j
2
j
1
; (91)
C
01
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)
8
(T t)
2
 
C
01
j
2
j
1
; (92)
C
10
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)
8
(T t)
2
 
C
10
j
2
j
1
; (93)
C
0000
j
4
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
16
(T t)
2
 
C
0000
j
4
j
3
j
2
j
1
; (94)
C
02
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)
16
(T t)
3
 
C
02
j
2
j
1
; (95)
Electronic Journal. http://diffjournal.spbu.ru/ 131Differential Equations and Control Processes, N. 1, 2021
C
20
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)
16
(T t)
3
 
C
20
j
2
j
1
; (96)
C
11
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)
16
(T t)
3
 
C
11
j
2
j
1
; (97)
C
001
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
16
(T t)
5=2
 
C
001
j
3
j
2
j
1
; (98)
C
010
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
16
(T t)
5=2
 
C
010
j
3
j
2
j
1
; (99)
C
100
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
16
(T t)
5=2
 
C
100
j
3
j
2
j
1
; (100)
C
00000
j
5
j
4
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1)
32
(T t)
5=2
 
C
00000
j
5
j
4
j
3
j
2
j
1
;
(101)
C
0001
j
4
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
32
(T t)
3
 
C
0001
j
4
j
3
j
2
j
1
; (102)
C
0010
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
32
(T t)
3
 
C
0010
j
4
j
3
j
2
j
1
; (103)
C
0100
j
4
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
32
(T t)
3
 
C
0100
j
3
j
2
j
1
; (104)
C
1000
j
4
j
3
j
2
j
1
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
32
(T t)
3
 
C
1000
j
4
j
3
j
2
j
1
; (105)
C
000000
j
6
j
5
j
4
j
3
j
2
j
1
=
=
p
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1)(2j
6
+ 1)
64
(T t)
3
 
C
000000
j
6
j
5
j
4
j
3
j
2
j
1
;
(106)
Electronic Journal. http://diffjournal.spbu.ru/ 132Differential Equations and Control Processes, N. 1, 2021
where
 
C
000
j
3
j
2
j
1
=
1
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydz; (107)
 
C
01
j
2
j
1
= 
1
Z
 1
(1 +y)P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdy; (108)
 
C
10
j
2
j
1
= 
1
Z
 1
P
j
2
(y)
y
Z
 1
(1 +x)P
j
1
(x)dxdy; (109)
 
C
0000
j
4
j
3
j
2
j
1
=
1
Z
 1
P
j
4
(u)
u
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydzdu; (110)
 
C
02
j
2
j
1
=
1
Z
 1
P
j
2
(y)(y + 1)
2
y
Z
 1
P
j
1
(x)dxdy; (111)
 
C
20
j
2
j
1
=
1
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)(x + 1)
2
dxdy; (112)
 
C
11
j
2
j
1
=
1
Z
 1
P
j
2
(y)(y + 1)
y
Z
 1
P
j
1
(x)(x + 1)dxdy; (113)
 
C
001
j
3
j
2
j
1
= 
1
Z
 1
P
j
3
(z)(z + 1)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydz; (114)
 
C
010
j
3
j
2
j
1
= 
1
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)(y + 1)
y
Z
 1
P
j
1
(x)dxdydz; (115)
 
C
100
j
3
j
2
j
1
= 
1
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)(x + 1)dxdydz; (116)
 
C
00000
j
5
j
4
j
3
j
2
j
1
=
1
Z
 1
P
j
5
(v)
v
Z
 1
P
j
4
(u)
u
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydzdudv; (117)
Electronic Journal. http://diffjournal.spbu.ru/ 133Differential Equations and Control Processes, N. 1, 2021
 
C
1000
j
4
j
3
j
2
j
1
= 
1
Z
 1
P
j
4
(u)
u
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)(x + 1)dxdydz; (118)
 
C
0100
j
4
j
3
j
2
j
1
= 
1
Z
 1
P
j
4
(u)
u
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)(y + 1)
y
Z
 1
P
j
1
(x)dxdydz; (119)
 
C
0010
j
4
j
3
j
2
j
1
= 
1
Z
 1
P
j
4
(u)
u
Z
 1
P
j
3
(z)(z + 1)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydz; (120)
 
C
0001
j
4
j
3
j
2
j
1
= 
1
Z
 1
P
j
4
(u)(u + 1)
u
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydz; (121)
 
C
000000
j
6
j
5
j
4
j
3
j
2
j
1
=
=
1
Z
 1
P
j
6
(w)
w
Z
 1
P
j
5
(v)
v
Z
 1
P
j
4
(u)
u
Z
 1
P
j
3
(z)
z
Z
 1
P
j
2
(y)
y
Z
 1
P
j
1
(x)dxdydzdudvdw;
(122)
another notations are the same as in Theorem 1.
2.5 Optimization of Approximations of Iterated It^ o Stochastic In-
tegrals from the Numerical Schemes (12){(16)
This section is devoted to the optimization of approximations of iterated It^ o
stochastic integrals from the numerical schemes (12){(16). More precisely, we
discuss how to minimize the numbers q;q
1
;q
2
;:::;q
15
from Section 2.4.
Suppose that " > 0 is the mean-square accuracy of approximation of the
iterated It^ o stochastic integrals (6), i.e.
E
(i
1
:::i
k
)p
(l
1
:::l
k
)T;t
def
= M
 
 
I
(i
1
:::i
k
)
(l
1
:::l
k
)T;t
 I
(i
1
:::i
k
)p
(l
1
:::l
k
)T;t
 
2
 
 ";
where I
(i
1
:::i
k
)p
(l
1
:::l
k
)T;t
; p2 N is the approximation of the iterated It^ o stochastic in-
tegral I
(i
1
:::i
k
)
(l
1
:::l
k
)T;t
. Then from (74) and (49) we obtain the following conditions
Electronic Journal. http://diffjournal.spbu.ru/ 134Differential Equations and Control Processes, N. 1, 2021
for choosing the numbersq;q
1
;q
2
;:::;q
15
for approximations of the iterated It^ o
stochastic integrals (67){(69) [26], [67]
E
(i
1
i
2
)q
(00)T;t
=
(T t)
2
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 "; (123)
E
(i
1
i
2
i
3
)q
1
(000)T;t
  6
 
(T t)
3
6
 
q
1
X
j
1
;j
2
;j
3
=0
 
C
000
j
3
j
2
j
1
 
2
!
 "; (124)
E
(i
1
i
2
)q
2
(01)T;t
  2
 
(T t)
4
4
 
q
2
X
j
1
;j
2
=0
 
C
01
j
2
j
1
 
2
!
 "; (125)
E
(i
1
i
2
)q
2
(10)T;t
  2
 
(T t)
4
12
 
q
2
X
j
1
;j
2
=0
 
C
10
j
2
j
1
 
2
!
 "; (126)
E
(i
1
:::i
4
)q
3
(0000)T;t
  24
 
(T t)
4
24
 
q
3
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0000
j
4
j
3
j
2
j
1
 
2
!
 "; (127)
E
(i
1
:::i
5
)q
4
(00000)T;t
  120
 
(T t)
5
120
 
q
4
X
j
1
;j
2
;j
3
;j
4
;j
5
=0
 
C
00000
j
5
j
4
j
3
j
2
j
1
 
2
!
 "; (128)
E
(i
1
i
2
)q
5
(20)T;t
  2
 
(T t)
6
30
 
q
5
X
j
2
;j
1
=0
 
C
20
j
2
j
1
 
2
!
 "; (129)
E
(i
1
i
2
)q
6
(11)T;t
  2
 
(T t)
6
18
 
q
6
X
j
2
;j
1
=0
 
C
11
j
2
j
1
 
2
!
 "; (130)
E
(i
1
i
2
)q
7
(02)T;t
  2
 
(T t)
6
6
 
q
7
X
j
2
;j
1
=0
 
C
02
j
2
j
1
 
2
!
 "; (131)
E
(i
1
i
2
i
3
)q
8
(001)T;t
  6
 
(T t)
5
10
 
q
8
X
j
1
;j
2
;j
3
=0
 
C
001
j
3
j
2
j
1
 
2
!
 "; (132)
E
(i
1
i
2
i
3
)q
9
(010)T;t
  6
 
(T t)
5
20
 
q
9
X
j
1
;j
2
;j
3
=0
 
C
010
j
3
j
2
j
1
 
2
!
 "; (133)
E
(i
1
i
2
i
3
)q
10
(100)T;t
  6
 
(T t)
5
60
 
q
10
X
j
1
;j
2
;j
3
=0
 
C
100
j
3
j
2
j
1
 
2
!
 "; (134)
Electronic Journal. http://diffjournal.spbu.ru/ 135Differential Equations and Control Processes, N. 1, 2021
E
(i
1
:::i
4
)q
11
(0001)T;t
  24
 
(T t)
6
36
 
q
11
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0001
j
4
j
3
j
2
j
1
 
2
!
 "; (135)
E
(i
1
:::i
4
)q
12
(0010)T;t
  24
 
(T t)
6
60
 
q
12
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0010
j
4
j
3
j
2
j
1
 
2
!
 "; (136)
E
(i
1
:::i
4
)q
13
(0100)T;t
  24
 
(T t)
6
120
 
q
13
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0100
j
4
j
3
j
2
j
1
 
2
!
 "; (137)
E
(i
1
:::i
4
)q
14
(1000)T;t
  24
 
(T t)
6
360
 
q
14
X
j
1
;j
2
;j
3
;j
4
=0
 
C
1000
j
4
j
3
j
2
j
1
 
2
!
 "; (138)
E
(i
1
:::i
6
)q
15
(000000)T;t
  720
 
(T t)
6
720
 
q
15
X
j
1
;j
2
;j
3
;j
4
;j
5
;j
6
=0
(C
j
6
j
5
j
4
j
3
j
2
j
1
)
2
!
 ": (139)
Taking into account (17) and (91){(122), (123){(139), we obtain the fol-
lowing conditions for choosing the numbers q;q
1
;q
2
;:::;q
15
for the numerical
schemes (12){(16) (constant C is independent of T t (see below)).
Milstein scheme (12)
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t):
Strong Taylor{It^ o scheme (13) with convergence order 1.5
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
2
;
6
 
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
!
 C(T t): (140)
Strong Taylor{It^ o scheme (14) with convergence order 2.0
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
3
;
Electronic Journal. http://diffjournal.spbu.ru/ 136Differential Equations and Control Processes, N. 1, 2021
6
 
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
!
 C(T t)
2
; (141)
2
 
1
4
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
01
j
2
j
1
 
2
!
 C(T t); (142)
2
 
1
12
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
10
j
2
j
1
 
2
!
 C(T t); (143)
24
 
1
24
 
1
256
q
3
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
0000
j
4
:::j
1
 
2
!
 
 C(T t): (144)
Strong Taylor{It^ o scheme (15) with convergence order 2.5
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
4
;
6
 
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
!
 C(T t)
3
; (145)
2
 
1
4
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
01
j
2
j
1
 
2
!
 C(T t)
2
; (146)
2
 
1
12
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
10
j
2
j
1
 
2
!
 C(T t)
2
; (147)
24
 
1
24
 
1
256
q
3
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
0000
j
4
:::j
1
 
2
!
 
 C(T t)
2
; (148)
6
 
1
10
 
1
256
q
8
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
001
j
3
j
2
j
1
 
2
!
 
 C(T t); (149)
Electronic Journal. http://diffjournal.spbu.ru/ 137Differential Equations and Control Processes, N. 1, 2021
6
 
1
20
 
1
256
q
9
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
010
j
3
j
2
j
1
 
2
!
 
 C(T t); (150)
6
 
1
60
 
1
256
q
10
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
100
j
3
j
2
j
1
 
2
!
 
 C(T t); (151)
120
 
1
120
 
1
32
2
q
4
X
j
1
;:::;j
5
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1) 
 
 
 
C
00000
j
5
:::j
1
 
2
!
 C(T t): (152)
Strong Taylor{It^ o scheme (16) with convergence order 3.0
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
5
;
6
 
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
!
 C(T t)
4
; (153)
2
 
1
4
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
01
j
2
j
1
 
2
!
 C(T t)
3
; (154)
2
 
1
12
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
10
j
2
j
1
 
2
!
 C(T t)
3
; (155)
24
 
1
24
 
1
256
q
3
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
0000
j
4
:::j
1
 
2
!
 
 C(T t)
3
; (156)
6
 
1
10
 
1
256
q
8
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
001
j
3
j
2
j
1
 
2
!
 
 C(T t)
2
; (157)
Electronic Journal. http://diffjournal.spbu.ru/ 138Differential Equations and Control Processes, N. 1, 2021
6
 
1
20
 
1
256
q
9
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
010
j
3
j
2
j
1
 
2
!
 
 C(T t)
2
; (158)
6
 
1
60
 
1
256
q
10
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
100
j
3
j
2
j
1
 
2
!
 
 C(T t)
2
; (159)
120
 
1
120
 
1
32
2
q
4
X
j
1
;:::;j
5
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1) 
 
 
 
C
00000
j
5
:::j
1
 
2
!
 C(T t)
2
; (160)
2
 
1
30
 
1
256
q
5
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
20
j
2
j
1
 
2
!
 C(T t); (161)
2
 
1
18
 
1
256
q
6
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
11
j
2
j
1
 
2
!
 C(T t); (162)
2
 
1
6
 
1
256
q
7
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
02
j
2
j
1
 
2
!
 C(T t); (163)
24
 
1
36
 
1
32
2
q
11
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
0001
j
4
:::j
1
 
2
!
 
 C(T t); (164)
24
 
1
60
 
1
32
2
q
12
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
0010
j
4
:::j
1
 
2
!
 
 C(T t); (165)
24
 
1
120
 
1
32
2
q
13
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
0100
j
4
:::j
1
 
2
!
 
 C(T t); (166)
Electronic Journal. http://diffjournal.spbu.ru/ 139Differential Equations and Control Processes, N. 1, 2021
24
 
1
360
 
1
32
2
q
14
X
j
1
;:::;j
4
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)
 
 
C
1000
j
4
:::j
1
 
2
!
 
 C(T t); (167)
720
 
1
720
 
1
64
2
q
15
X
j
1
;:::;j
6
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1)(2j
6
+ 1) 
 
 
 
C
000000
j
6
:::j
1
 
2
!
 C(T t): (168)
Taking into account Theorem 3 and the results of Listings 5 and 6 (see
Section 5) we decided to exclude the multiplier factors k! from the left-hand
sides of (140), (141){(144), (145){(152), (153){(168). The detailed numerical
con rmation of the mentioned possibility can be found in [73]. This means that
we will use the following conditions for choosing the numbers q;q
1
;q
2
;:::;q
15
for the numerical schemes (12){(16) (constant C is independent of T t (see
below)).
Milstein scheme (12)
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t): (169)
Strong Taylor{It^ o scheme (13) with convergence order 1.5
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
2
; (170)
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
 C(T t): (171)
Strong Taylor{It^ o scheme (14) with convergence order 2.0
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
3
; (172)
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
 C(T t)
2
; (173)
Electronic Journal. http://diffjournal.spbu.ru/ 140Differential Equations and Control Processes, N. 1, 2021
1
4
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
01
j
2
j
1
 
2
 C(T t); (174)
1
12
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
10
j
2
j
1
 
2
 C(T t); (175)
1
24
 
1
256
q
3
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
0000
j
4
:::j
1
 
2
 C(T t): (176)
Strong Taylor{It^ o scheme (15) with convergence order 2.5
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
4
; (177)
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
 C(T t)
3
; (178)
1
4
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
01
j
2
j
1
 
2
 C(T t)
2
; (179)
1
12
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
10
j
2
j
1
 
2
 C(T t)
2
; (180)
1
24
 
1
256
q
3
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
0000
j
4
:::j
1
 
2
 C(T t)
2
; (181)
1
10
 
1
256
q
8
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
001
j
3
j
2
j
1
 
2
 C(T t); (182)
1
20
 
1
256
q
9
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
010
j
3
j
2
j
1
 
2
 C(T t); (183)
1
60
 
1
256
q
10
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
100
j
3
j
2
j
1
 
2
 C(T t); (184)
1
120
 
1
32
2
q
4
X
j
1
;:::;j
5
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1)
 
 
C
00000
j
5
:::j
1
 
2
 
 C(T t); (185)
Electronic Journal. http://diffjournal.spbu.ru/ 141Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{It^ o scheme (16) with convergence order 3.0
1
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
 C(T t)
5
; (186)
1
6
 
1
64
q
1
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
000
j
3
j
2
j
1
 
2
 C(T t)
4
; (187)
1
4
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
01
j
2
j
1
 
2
 C(T t)
3
; (188)
1
12
 
1
64
q
2
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
10
j
2
j
1
 
2
 C(T t)
3
; (189)
1
24
 
1
256
q
3
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
0000
j
4
:::j
1
 
2
 C(T t)
3
; (190)
1
10
 
1
256
q
8
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
001
j
3
j
2
j
1
 
2
 C(T t)
2
; (191)
1
20
 
1
256
q
9
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
010
j
3
j
2
j
1
 
2
 C(T t)
2
; (192)
1
60
 
1
256
q
10
X
j
1
;j
2
;j
3
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)
 
 
C
100
j
3
j
2
j
1
 
2
 C(T t)
2
; (193)
1
120
 
1
32
2
q
4
X
j
1
;:::;j
5
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1)
 
 
C
00000
j
5
:::j
1
 
2
 
 C(T t)
2
; (194)
1
30
 
1
256
q
5
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
20
j
2
j
1
 
2
 C(T t); (195)
1
18
 
1
256
q
6
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
11
j
2
j
1
 
2
 C(T t); (196)
1
6
 
1
256
q
7
X
j
1
;j
2
=0
(2j
1
+ 1)(2j
2
+ 1)
 
 
C
02
j
2
j
1
 
2
 C(T t); (197)
Electronic Journal. http://diffjournal.spbu.ru/ 142Differential Equations and Control Processes, N. 1, 2021
1
36
 
1
32
2
q
11
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
0001
j
4
:::j
1
 
2
 C(T t); (198)
1
60
 
1
32
2
q
12
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
0010
j
4
:::j
1
 
2
 C(T t); (199)
1
120
 
1
32
2
q
13
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
0100
j
4
:::j
1
 
2
 C(T t); (200)
1
360
 
1
32
2
q
14
X
j
1
;:::;j
4
=0
(2j
1
+1)(2j
2
+1)(2j
3
+1)(2j
4
+1)
 
 
C
1000
j
4
:::j
1
 
2
 C(T t); (201)
1
720
 
1
64
2
q
15
X
j
1
;:::;j
6
=0
(2j
1
+ 1)(2j
2
+ 1)(2j
3
+ 1)(2j
4
+ 1)(2j
5
+ 1)(2j
6
+ 1) 
 
 
 
C
000000
j
6
:::j
1
 
2
 C(T t): (202)
2.6 Approximations of Iterated Stratonovich Stochastic Integrals
from the Numerical Schemes (24){(28) Using Legendre Polyno-
mials
This section is devoted to approximation of the Stratonovich stochastic integrals
(20) of multiplicities 1 to 6 based on Theorem 2 and Hypothesis 1. At that we
will use multiple Fourier{Legendre series for approximation of the mentioned
stochastic integrals.
The numerical schemes (24){(28) contain the following set (see (20)) of
iterated Stratonovich stochastic integrals
I
 (i
1
)
(0)T;t
; I
 (i
1
)
(1)T;t
; I
 (i
1
)
(2)T;t
; I
 (i
1
i
2
)
(00)T;t
; I
 (i
1
i
2
)
(10)T;t
; I
 (i
1
i
2
)
(01)T;t
; I
 (i
1
i
2
i
3
)
(000)T;t
; I
 (i
1
i
2
i
3
i
4
)
(0000)T;t
; (203)
I
 (i
1
i
2
i
3
i
4
i
5
)
(00000)T;t
; I
 (i
1
i
2
)
(02)T;t
; I
 (i
1
i
2
)
(20)T;t
; I
 (i
1
i
2
)
(11)T;t
; I
 (i
1
i
2
i
3
)
(100)T;t
; I
 (i
1
i
2
i
3
)
(010)T;t
; I
 (i
1
i
2
i
3
)
(001)T;t
; (204)
I
 (i
1
i
2
i
3
i
4
)
(0001)T;t
; I
 (i
1
i
2
i
3
i
4
)
(0010)T;t
; I
 (i
1
i
2
i
3
i
4
)
(0100)T;t
; I
 (i
1
i
2
i
3
i
4
)
(1000)T;t
; I
 (i
1
i
2
i
3
i
4
i
5
i
6
)
(000000)T;t
: (205)
Using Theorem 2, Hypothesis 1, and well known properties of the Legendre
polynomials, we obtain the following formulas for numerical modeling of the
stochastic integrals (203){(205) [26], [42]-[46], [58], [61], [67], [68], [70]-[72]
I
 (i
1
)
(0)T;t
=
p
T t 
(i
1
)
0
; (206)
Electronic Journal. http://diffjournal.spbu.ru/ 143Differential Equations and Control Processes, N. 1, 2021
I
 (i
1
)
(1)T;t
= 
(T t)
3=2
2
 
 
(i
1
)
0
+
1
p
3
 
(i
1
)
1
 
; (207)
I
 (i
1
)
(2)T;t
=
(T t)
5=2
3
 
 
(i
1
)
0
+
p
3
2
 
(i
1
)
1
+
1
2
p
5
 
(i
1
)
2
!
; (208)
I
 (i
1
i
2
)q
(00)T;t
=
T t
2
 
 
(i
1
)
0
 
(i
2
)
0
+
q
X
i=1
1
p
4i
2
  1
 
 
(i
1
)
i 1
 
(i
2
)
i
  
(i
1
)
i
 
(i
2
)
i 1
 
!
; (209)
I
 (i
1
i
2
i
3
)q
1
(000)T;t
=
q
1
X
j
1
;j
2
;j
3
=0
C
000
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
; (210)
I
 (i
1
i
2
)q
2
(10)T;t
=
q
2
X
j
1
;j
2
=0
C
10
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
; (211)
I
 (i
1
i
2
)q
2
(01)T;t
=
q
2
X
j
1
;j
2
=0
C
01
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
; (212)
I
(i
1
i
2
i
3
i
4
)q
3
(0000)T;t
=
q
3
X
j
1
;j
2
;j
3
;j
4
=0
C
0000
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
; (213)
I
(i
1
i
2
i
3
i
4
i
5
)q
4
(00000)T;t
=
q
4
X
j
1
;j
2
;j
3
;j
4
;j
5
=0
C
00000
j
5
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
; (214)
I
 (i
1
i
2
)q
5
(20)T;t
=
q
5
X
j
1
;j
2
=0
C
20
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
; (215)
I
(i
1
i
2
)q
6
(11)T;t
=
q
6
X
j
1
;j
2
=0
C
11
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
; (216)
I
(i
1
i
2
)q
7
(02)T;t
=
q
7
X
j
1
;j
2
=0
C
02
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
; (217)
I
 (i
1
i
2
i
3
)q
8
(001)T;t
=
q
8
X
j
1
;j
2
;j
3
=0
C
001
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
; (218)
I
(i
1
i
2
i
3
)q
9
(010)T;t
=
q
9
X
j
1
;j
2
;j
3
=0
C
010
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
; (219)
Electronic Journal. http://diffjournal.spbu.ru/ 144Differential Equations and Control Processes, N. 1, 2021
I
(i
1
i
2
i
3
)q
10
(100)T;t
=
q
10
X
j
1
;j
2
;j
3
=0
C
100
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
; (220)
I
(i
1
i
2
i
3
i
4
)q
11
(0001)T;t
=
q
11
X
j
1
;j
2
;j
3
;j
4
=0
C
0001
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
; (221)
I
(i
1
i
2
i
3
i
4
)q
12
(0010)T;t
q
12
X
j
1
;j
2
;j
3
;j
4
=0
C
0010
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
; (222)
I
(i
1
i
2
i
3
i
4
)q
13
(0100)T;t
=
q
13
X
j
1
;j
2
;j
3
;j
4
=0
C
0100
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
; (223)
I
(i
1
i
2
i
3
i
4
)q
14
(1000)T;t
=
q
14
X
j
1
;j
2
;j
3
;j
4
=0
C
1000
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
; (224)
I
(i
1
i
2
i
3
i
4
i
5
i
6
)q
15
(000000)T;t
=
q
15
X
j
1
;j
2
;j
3
;j
4
;j
5
;j
6
=0
C
000000
j
6
j
5
j
4
j
3
j
2
j
1
 
(i
1
)
j
1
 
(i
2
)
j
2
 
(i
3
)
j
3
 
(i
4
)
j
4
 
(i
5
)
j
5
 
(i
6
)
j
6
; (225)
where 1
A
is the indicator of the set A; another notations are the same as in
Section 2.4.
The question on choosing the numbers q
1
;q
2
;:::;q
15
in (210){(225) turned
out to be nontrivial [26] (Chapter 5). The expansions (210){(225) for iterated
Stratonovich stochastic integrals are simpler than their analogues (75){(90) for
iterated It^ o stochastic integrals. However, the calculation of the mean-square
approximation error for iterated Stratonovich stochastic integrals turns out to
be much more di cult than for iterated It^ o stochastic integrals [26] (Chapter
5). Below we give some reasoning regarding this problem.
Denote
E
 (i
1
:::i
k
)p
(l
1
:::l
k
)T;t
def
= M
 
 
I
 (i
1
:::i
k
)
(l
1
:::l
k
)T;t
 I
 (i
1
:::i
k
)p
(l
1
:::l
k
)T;t
 
2
 
;
whereI
 (i
1
:::i
k
)p
(l
1
:::l
k
)T;t
;p2N is the approximation of the iterated Stratonovich stochas-
tic integral I
 (i
1
:::i
k
)
(l
1
:::l
k
)T;t
.
From (209) for i
1
6=i
2
we obtain [26], [67]
E
 (i
1
i
2
)q
(00)T;t
=
(T t)
2
2
1
X
i=q+1
1
4i
2
  1
 
(T t)
2
2
1
Z
q
1
4x
2
  1
dx =
Electronic Journal. http://diffjournal.spbu.ru/ 145Differential Equations and Control Processes, N. 1, 2021
= 
(T t)
2
8
ln
 
 
 
 
1 
2
2q + 1
 
 
 
 
 C
1
(T t)
2
q
; (226)
where constant C
1
is independent of q.
It is easy to notice that for a su ciently small T t (recall that T t  1
since it is a step of integration for numerical schemes for It^ o SDEs) there exists
a constant C
2
such that
E
 (i
1
:::i
k
)q
(l
1
:::l
k
)T;t
 C
2
E
 (i
1
i
2
)q
(00)T;t
: (227)
From (226) and (227) we  nally obtain
E
 (i
1
:::i
k
)q
(l
1
:::l
k
)T;t
 C
(T t)
2
q
; (228)
where constantC does not depend onT t. The same idea can be found in [2] in
the framework of the method of approximation of iterated Stratonovich stochas-
tic integrals based on the trigonometric expansion of the Brownian bridge pro-
cess.
Obviously, we can get more information about the numbers q
1
;q
2
;:::;q
15
(these numbers are different for different iterated Stratonovich stochastic inte-
grals) using the another approach. Since
J
 
[ 
(k)
]
T;t
=J[ 
(k)
]
T;t
w. p. 1
for pairwise different i
1
;:::;i
k
= 1;:::;m, where J[ 
(k)
]
T;t
; J
 
[ 
(k)
]
T;t
are de-
 ned by (2) and (3) correspondingly, then for pairwise different i
1
;:::;i
6
=
1;:::;m from (51) we obtain [26], [67]
E
 (i
1
i
2
)q
(00)T;t
=
(T t)
2
2
 
1
2
 
q
X
i=1
1
4i
2
  1
!
; (229)
E
 (i
1
i
2
i
3
)q
1
(000)T;t
=
(T t)
3
6
 
q
1
X
j
3
;j
2
;j
1
=0
 
C
000
j
3
j
2
j
1
 
2
; (230)
E
 (i
1
i
2
)q
2
(01)T;t
=
(T t)
4
4
 
q
2
X
j
1
;j
2
=0
 
C
01
j
2
j
1
 
2
; (231)
E
 (i
1
i
2
)q
2
(10)T;t
=
(T t)
4
12
 
q
2
X
j
1
;j
2
=0
 
C
10
j
2
j
1
 
2
; (232)
Electronic Journal. http://diffjournal.spbu.ru/ 146Differential Equations and Control Processes, N. 1, 2021
E
 (i
1
:::i
4
)q
3
(0000)T;t
=
(T t)
4
24
 
q
3
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0000
j
4
j
3
j
2
j
1
 
2
; (233)
E
 (i
1
:::i
5
)q
4
(00000)T;t
=
(T t)
5
120
 
q
4
X
j
1
;j
2
;j
3
;j
4
;j
5
=0
 
C
00000
j
5
i
4
i
3
i
2
j
1
 
2
; (234)
E
 (i
1
i
2
)q
5
(20)T;t
=
(T t)
6
30
 
q
5
X
j
2
;j
1
=0
 
C
20
j
2
j
1
 
2
; (235)
E
 (i
1
i
2
)q
6
(11)T;t
=
(T t)
6
18
 
q
6
X
j
2
;j
1
=0
 
C
11
j
2
j
1
 
2
; (236)
E
 (i
1
i
2
)q
7
(02)T;t
=
(T t)
6
6
 
q
7
X
j
2
;j
1
=0
 
C
02
j
2
j
1
 
2
; (237)
E
 (i
1
i
2
i
3
)q
8
(001)T;t
=
(T t)
5
10
 
q
8
X
j
1
;j
2
;j
3
=0
 
C
001
j
3
j
2
j
1
 
2
; (238)
E
 (i
1
i
2
i
3
)q
9
(010)T;t
=
(T t)
5
20
 
q
9
X
j
1
;j
2
;j
3
=0
 
C
010
j
3
j
2
j
1
 
2
; (239)
E
 (i
1
i
2
i
3
)q
10
(100)T;t
=
(T t)
5
60
 
q
10
X
j
1
;j
2
;j
3
=0
 
C
100
j
3
j
2
j
1
 
2
; (240)
E
 (i
1
:::i
4
)q
11
(0001)T;t
=
(T t)
6
36
 
q
11
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0001
j
4
j
3
j
2
j
1
 
2
; (241)
E
 (i
1
:::i
4
)q
12
(0010)T;t
=
(T t)
6
60
 
q
12
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0010
j
4
j
3
j
2
j
1
 
2
; (242)
E
 (i
1
:::i
4
)q
13
(0100)T;t
=
(T t)
6
120
 
q
13
X
j
1
;j
2
;j
3
;j
4
=0
 
C
0100
j
4
j
3
j
2
j
1
 
2
; (243)
E
 (i
1
:::i
4
)q
14
(1000)T;t
=
(T t)
6
360
 
q
14
X
j
1
;j
2
;j
3
;j
4
=0
 
C
1000
j
4
j
3
j
2
j
1
 
2
; (244)
E
 (i
1
:::i
6
)q
15
(000000)T;t
=
(T t)
6
720
 
q
15
X
j
1
;j
2
;j
3
;j
4
;j
5
;j
6
=0
 
C
000000
j
6
j
5
j
4
j
3
j
2
j
1
 
2
: (245)
Electronic Journal. http://diffjournal.spbu.ru/ 147Differential Equations and Control Processes, N. 1, 2021
Table 1. High-order strong Taylor{Stratonovich schemes.
Order of convergence Scheme Conditions for choosing the numbers q;q
1
;:::;q
15
1.0 (24) (169)
1.5 (25) (170), (171)
2.0 (26) (172){(176)
2.5 (27) (177){(185)
3.0 (28) (186){(202)
Taking into account (229){(245) and the results of paper [73], we use in
the SDE-MATH software package the conditions from Table 1 for choosing the
numbers q;q
1
;q
2
;:::;q
15
for the numerical schemes (24){(28).
Note that in the SDE-MATH software package, which is presented in the fol-
lowing sections, we use the following upper boundsb on the numbersq
1
;:::;q
15
b = 56 for q
1
; b = 15 for q
2
; q
3
; b = 6 for q
4
; q
8
; q
9
; q
10
;
b = 2 for q
5
; q
6
; q
7
; q
11
; q
12
; q
13
; q
14
; q
15
:
This means that for the implementing of the numerical methods (13){(16)
and (25){(28) we use in the SDE-MATH software package the following quan-
tities of the exactly calculated Fourier{Legendre coe cients
57
3
= 185;193 for C
000
j
3
j
2
j
1
;
16
3
= 4;096 for each of C
10
j
2
j
1
; C
01
j
2
j
1
;
16
4
= 65;536 for C
0000
j
4
j
3
j
2
j
1
;
7
3
= 343 for each of C
100
j
3
j
2
j
1
; C
010
j
3
j
2
j
1
; C
001
j
3
j
2
j
1
;
7
5
= 16;807 for C
00000
j
5
j
4
j
3
j
2
j
1
;
3
2
= 9 for each of C
20
j
2
j
1
; C
02
j
2
j
1
; C
11
j
2
j
1
;
3
4
= 81 for each of C
1000
j
4
j
3
j
2
j
1
; C
0100
j
4
j
3
j
2
j
1
; C
0010
j
4
j
3
j
2
j
1
; C
0001
j
4
j
3
j
2
j
1
;
3
6
= 729 for C
000000
j
6
j
5
j
4
j
3
j
2
j
1
:
It should be noted that unlike the method based on Theorems 1{3, exist-
ing and well-known approaches to the mean-square approximation of iterated
stochastic integrals based on the trigonometric basis functions [2], [3], [7], [27],
Electronic Journal. http://diffjournal.spbu.ru/ 148Differential Equations and Control Processes, N. 1, 2021
[28], [34], [37] do not allow choosing theoretically different numbersq for approx-
imations of different iterated stochastic integrals (starting form the multiplicity
2 of stochastic integrals). Moreover, the noted approaches [2], [3], [7], [27],
[28], [34], [37] exclude the possibility for obtaining of approximate and exact
expressions for the mean-square approximation error similar to the formulas
(49), (50).
2.7 Numerical Algorithm for Linear Stationary Systems of It^ o SDEs
Based on Spectral Decomposition
Consider the following linear stationary system of It^ o SDEs
dx
t
= (Ax
t
+Bu(t))dt +Fdw
t
; x
0
= x(0); t2 [0;T ]; (246)
where x
t
2 R
n
is a solution of the system (246), u(t) : [0;T ]! R
k
is a non-
random function, A2 R
n n
; F 2 R
n m
, B2 R
n k
, and w
t
is a standard m-
dimensional Wiener process with independent components w
(i)
t
; i = 1;:::;m:
Also we suppose that n; m; k  1: The process y
t
= Hx
t
2R
1
is interpreted
as an output process of the system (246), where H2R
1 n
:
It is well-known that the solution of (246) has the form [4]
x
t
=e
A(t t
0
)
x
t
0
+
t
Z
t
0
e
A(t s)
Bu(s)ds +
t
Z
t
0
e
A(t s)
Fdw
s
; 0 t
0
 t T; (247)
where e
C
is a matrix exponent
1
X
j=0
C
j
j!
def
= e
C
;
C is a square matrix, and C
0
def
= I is a unity matrix.
Consider the partitionf 
p
g
N
p=0
of [0;T ] such that  
p
= p ;   > 0: For
simplicity, we will suppose that u(s); s2 [0;T ] can be approximated by the
step function, i.e. u(s)  ^ u(s); s2 [0;T ]; where ^ u(s) = u( 
p
) for s2 [ 
p
; 
p+1
);
p = 0; 1;:::;N  1 (more accurate approximations ofu(s) are discussed in [62]
(also see [58], [61])). Substituting t =  
p+1
; t
0
=  
p
; and ^ u(s) instead of u(s)
into (247), we obtain
^ x
p+1
=e
A 
^ x
p
+A
 1
 
e
A 
 I
 
Bu(p ) + ~ w
p+1
( ); x
0
= x(0); (248)
Electronic Journal. http://diffjournal.spbu.ru/ 149Differential Equations and Control Processes, N. 1, 2021
where ^ x
p
is the approximation of x
 
p
and
 
Z
0
e
A(  s)
Fdw
s+p 
def
= ~ w
p+1
( ):
Also we assume that ^ y
p
=H^ x
p
, where ^ y
p
is the approximation of y
 
p
: The
random column ~ w
p+1
( ) admits the following representation [4]
~ w
p+1
( ) =S
D
( ) 
D
( )   w
p+1
; (249)
where   w
p
2R
n
is a column of independent standard Gaussian random variables
such that M
 
  w
p
  w
T
q
	
=O for p6= q,O is a zero matrix of size n n, S
D
( )
is a matrix of orthonormal eigenvectors of the matrix D
f
( ) and  
2
D
( ) is a
diagonal matrix on the main diagonal of which are the eigenvalues of the matrix
D
f
( ), the matrix D
f
( ) is de ned by
D
f
( ) =M
 
~ w
p+1
( ) ~ w
T
p+1
( )
	
=
 
Z
0
exp(A(  s))FF
T
exp(A
T
(  s))ds;
where C
T
is a transposed matrix C. Moreover, D
f
( ) = D
f
(t)
 
 
t= 
, where
D
f
(t) is a solution of the following Cauchy problem [4]
dD
f
dt
(t) =AD
f
(t) +D
f
(t)A
T
+FF
T
; D
f
(0) =O:
In the SDE-MATH software package, we implement the numerical modeling
of the system (246) by the formulas (248), (249). At that we use Algorithms
2.3{2.6 from [62] (also see [61], Chapter 11) for the implemetation of (249).
3 The Structure of the SDE-MATH Software Package
3.1 Development Tools
The software package was implemented with Python programming language.
The main reason to use it is a huge community and signi cant amount of helpful
libraries for calculations and mathematics. The development was performed in
free to use Atom text editor
1
.
1
All programs in Python programming language from this paper were written by the  rst author
Electronic Journal. http://diffjournal.spbu.ru/ 150Differential Equations and Control Processes, N. 1, 2021
3.2 Dependency Libraries
In the development of the SDE-MATH software package such libraries as
SymPy, NumPy, PyQt5, and Matplotlib were involved. All these libraries and
tools are free and open source.
• SymPy is a Python library able to perform symbolic algebra calculations.
• NumPy is a library which specialization is e cient mathematical calcula-
tions. Most part of this library is written in C programming language that
guarantees high calculation performance.
• The database is SQLite3. This is a tiny database for a local usage on one
machine.
• Matplotlib library is a piece of software used to present obtained results in
a best way.
• PyQt5 is a library used to build graphical user interface for the SDE-MATH
software package.
3.3 Architecture
Taking into account, that the SDE-MATH software package is oriented on a nu-
merical modeling its architecture is clear. There are two main statements. The
 rst is that mathematical formulas are strongly integrated with SymPy library.
By that we mean that they completely rely on SymPy. And the second is usage
of database to make some calculations able for caching. The architecture itself
is provided on Figure 1. Here all parts of the software package can be seen.
The main package is responsible for startup, so it decides which part of the
software package must be started. The software package has several modes of
operation. The objectives now are
• Run program to calculate and store the Fourier{Legendre coe cients in
few text  les with further loading in database.
• Run program with graphical user interface. This is the main program entry
for the SDE-MATH software package.
Electronic Journal. http://diffjournal.spbu.ru/ 151Differential Equations and Control Processes, N. 1, 2021
Symbolic algebra
package
Modeling
Database
File
system
Use
Use
Main package
(program entry)
Tools
Use
SymPy
NumPy
SQLite3
Use
Use
Use
Accuracy calculation 
package
Use
Use
Graphical User 
Interface
Use
PyQt5
Use
Figure 1: The SDE-MATH software package architecture
Electronic Journal. http://diffjournal.spbu.ru/ 152Differential Equations and Control Processes, N. 1, 2021
On the current state of development the main entry package booting up
PyQt5 library with all necessary widgets. More detailed description of this
process will be provided later.
Moving further, the modeling package comes up. This package responsible
for all work referenced to modeling including initialization of modeling environ-
ment, calculations loops and more. Also, it depends on accuracy calculation
module deciding which amount of members in each approximation of iterated
stochastic integral should be used in modeling of the It^ o SDE (1) solution.
Accuracy calculation module accepts the order of strong numerical scheme
for the It^ o SDE (1) and its integration step and then calculates necessary
amount of members in approximations of iterated It^ o and Stratonovich stochas-
tic integrals.
Symbolic algebra module is the construction part which combines many
supplementary differential operators with strong numerical schemes for the It^ o
SDE (1). Having these components combined this module performs simpli ca-
tion of resulting formula so the modeling package can do its modeling work.
Tools module provides some functionality related to bootstrap of runtime
environment and external instruments such as database and  le system.
3.3.1 Integration with SymPy
Class inheritance tree was extended to implement strong numerical schemes for
It^ o SDEs. While numerical schemes for It^ o SDEs were being implemented it was
also necessary to implement supplementary subprograms. SymPy is a Python
library able to perform symbolic algebra calculations. This is a core part of
the project since it is differentiates input functions, builds and simpli es strong
numerical schemes for It^ o SDEs to model the It^ o SDE (1) solution. Without
this part the program package cannot be able to provide such exible input of
data.
3.3.2 Purpose of NumPy
NumPy is a library that helps with calculation optimizations in this project.
The library specialization is e cient mathematical calculations. The main us-
age case is to calculate compiled symbolic formulas with it. It has integration
with SymPy to replace symbolic functions with high performance numerical
functions.
Electronic Journal. http://diffjournal.spbu.ru/ 153Differential Equations and Control Processes, N. 1, 2021
3.3.3 Purpose of SQLite Database
The database was used to store the precalculated Fourier{Legendre coe cients,
so getting them from there made numerical modeling much faster, because cal-
culation process for these Fourier{Legendre coe cients involve high-cost sym-
bolic operations. The database contains only one table, and might be thought
redundant, but modeling needs hundreds (or even thousands) of precalculated
coe cients. Obviously, calculation of them at runtime is terribly ine cient, but
text  les also not the best choice. Text  les provide a sequential access memory
and combining different accuracy values q
1
;:::;q
15
it causes sequential search
which extends time to give the result. That is where database comes up. The
random access allows to get any Fourier{Legendre coe cient or any quantity
of them which makes solution as exible as it possible.
The download of precalculated Fourier{Legendre coe cients is built in sup-
plemental subprograms to provide uent calculation pipeline. Having the pre-
calculated Fourier{Legendre coe cient not found, subprogram initiates calcu-
lation for it with following store in the database.
Op. 1
Op. 2 C
Op. 4 Op. 3
Formula calculation tree
Database
Request for a
calculation
Result of
calculation
C
id index_string value
0 0:0:0_0:0:0 4/3
1 0:0:1_0:0:0 -2/3
2 0:0:2_0:0:0 2/15
3 0:0:3_0:0:0 0
4 0:0:4_0:0:0 0
5 0:0:5_0:0:0 0
... ... ...
Figure 2: Fourier{Legendre coe cients calculations explanation
Electronic Journal. http://diffjournal.spbu.ru/ 154Differential Equations and Control Processes, N. 1, 2021
It is an interesting note that having mentioned earlier optimization done,
the calculations performance were increased in several times. Now the most
heavy operation is symbolic simpli cations before modeling. The actual mod-
eling takes seconds, for thousands of iterations on m components of stochastic
process, so it is not such important how long modeling period of time, as the
accuracy that needs to be accomplished.
The scheme of calculation process is presented on Figure 2.
3.3.4 Purpose of Matplotlib
Matplotlib library is a piece of software used to present obtained results in
a best way. This library has many features, but feature that needed in this
project is to print charts with modeling results in a PyQt5 widget. Thus the
data visualization is integrated in graphical user interface.
3.4 Implementation Plan
The implementation of SDE-MATH software package was performed sequen-
tially. The components of SDE-MATH software package were implemented in
order of their necessity for calculation pipeline completion.
3.4.1 Calculation of the Fourier{Legendre Coe cients
The Fourier{Legendre coe cients for the approximations of iterated It^ o and
Stratonovich stochastic integrals were implemented and placed in Listings 43{
61. This was the  rst step since the Fourier{Legendre coe cients involved
almost in every strong numerical scheme for the It^ o SDE (1).
Also it is important to note that the SDE-MATH software package contains
a Python script intended for generating of Fourier{Legendre coe cients using
multiprocessing. This script placed in Listing 62 and already contains tasks
that were performed to generate about 300,000 Fourier{Legendre coe cients.
Similarly, user can run and calculate additional Fourier{Legendre coe cients
if they are needed. To determine which Fourier{Legendre coe cients will be
calculated user must specify pairs of starting and ending values of components
in lower multi-index and specify upper multi-index of the Fourier{Legendre
coe cient. For example (((0; 15); (0; 15); (0; 15)); (0; 1; 0)). This means that
Electronic Journal. http://diffjournal.spbu.ru/ 155Differential Equations and Control Processes, N. 1, 2021
program calculates the Fourier{Legendre coe cients C
010
j
3
j
2
j
1
; where j
1
;j
2
;j
3
2
f0; 1;:::; 14g.
3.4.2 Differential Operators L;
 
L; G
(i)
0
; i = 1;:::;m
Moving further, strong numerical schemes for It^ o SDEs rely on the differential
operators (4), (5), and (23). They were implemented and placed in Listings
64{67.
3.4.3 Approximations of Iterated Stochastic Integrals
The next step is implementation of approximations of iterated It^ o and Stratono-
vich stochastic integrals for the numerical schemes (12){(16), (24){(28). They
are implemented and de nition of their classes are placed in Listings 69{108.
3.4.4 Strong Numerical Schemes for It^ o SDEs
The strong numerical schemes (12){(16), (24){(28) for It^ o SDEs were imple-
mented. They are placed in Listings 110{131.
3.4.5 Graphical User Interface
Finally, the graphical user interface was implemented. The source codes refer-
enced to graphical user interface are placed in Listings 7{42.
4 Software Package Graphical User Interface
For the SDE-MATH software package mentioned above the graphical user in-
terface was developed. The graphical user interface is important and massive
part of SDE-MATH software package because it allows user to perform mod-
eling experiments without programming skills and understanding of program
package architecture and principles of work.
4.1 Information Model of The Graphical User Interface
The development of graphical user interface was started from consideration of
Electronic Journal. http://diffjournal.spbu.ru/ 156Differential Equations and Control Processes, N. 1, 2021
Charts
window
Taylor-Stratonovich Taylor-Ito Other
 Convergence Order 1.0
 Convergence Order 1.5
 Convergence Order 2.0
 Convergence Order 2.5
 Convergence Order 3.0
 Milstein
 Convergence Order 1.5
 Convergence Order 2.0
 Convergence Order 2.5
 Convergence Order 3.0
 Euler Linear Systems
SDE`s strong numerical schemes
Curves Zoom Resize Save Move
Charts
window
Modeling Logs
Back Charts
window
Setting of scalar parameters
n
m
 2
 1
Next
Euler
Milstein
 SDE math: software package X
 SDE math: charts window X
 SDE math: software package X
 SDE math: software package X
Welcome to SDE-MATH Software Package
 SDE math: software package X
Greeting Message
Ok
Back Charts
window
 SDE math: software package X
Back
Next Back
Setting of vector and matrix parameters
Ok
Do not
show again
The modeling is being performed...
2
3
5
6
7
4
 SDE math: software package X
Preparing Database...
1
Figure 3: Information model of graphical user interface
experiments and routines which can be performed with the SDE-MATH soft-
ware package. The graphical user interface is aimed on provision of user capa-
bilities to perform nonlinear and linear systems of It^ o SDEs modeling experi-
Electronic Journal. http://diffjournal.spbu.ru/ 157Differential Equations and Control Processes, N. 1, 2021
ments. The information model which schematically describes the graphical user
interface structure is presented on Figure 3.
4.1.1 Processing Screens
To represent long duration processes the graphical user interface has two dialogs
which can be seen on Figure 3, in Windows 1 and 6. The  rst one represents
database preparing process on application very  rst run. During this process the
Fourier{Legendre coe cients are being loaded into the SQLite database. This
screen appears also when user calculates new Fourier{Legendre coe cients. The
other screen shows logs during modeling experiment.
4.1.2 Greetings Dialog
After the SDE-MATH software package has completed the database prepa-
ration, it shows greeting dialog which represents short information about its
purposes. The greeting dialog can be seen on Figure 3 in Window 2.
4.1.3 Main Menu Dialog
In the main menu of the SDE-MATH software package user can choose one of
strong numerical schemes for It^ o SDEs to perform modeling experiments. The
main menu dialog can be seen on Figure 3 in Window 3.
4.1.4 Visualization Tool
It is important to note that the main SDE-MATH software package window has
a checkbox in right upper corner which do switching on and off charts window.
In any time user can call this window or hide it if it is not needed. The charts
window is universal utility for modeling experiments results visualization. This
window has few instruments on it. The left side bar contains all curves labels,
and control elements for hiding, showing, and deleting curves. On the right side
of the window there are plot which draws the curves. The charts window can
be seen on Figure 3, it is Window 3.
4.1.5 Data Input Dialogs
Since the software package has options to perform linear It^ o SDEs modeling
experiments it is necessary to provide user with input  elds for numerical data
Electronic Journal. http://diffjournal.spbu.ru/ 158Differential Equations and Control Processes, N. 1, 2021
both scalar and matrix. On the other side, for nonlinear It^ o SDEs it is necessary
to provide symbolic input. The choice of control elements is conditioned by the
above obstacles. On Figure 3, and especially in Windows 4 and 5, these input
controls can be seen. There are "LineEditWidget" and "TableWidget" which
are su cient to provide input abilities. The topic of input data validation is
also important but to be more accurate referenced to user experience rather
than to information model, so it will be described further.
4.2 The User Experience and Implementation Results
The above part represents the structure of software package but not the dynam-
ics and user experience of it. Let us discuss the SDE-MATH software package
user experience on few examples provided further on Figures 4{36. This exam-
ples represent two scenarios of the SDE-MATH software package use.
The database preparation screen is presented on Figure 4. During the
database preparation this screen displays informational message and spinning
visualizer of process continuation.
The screen that presented on Figure 5 appears every time when software
package runs unless user presses "Ok" button with marked checkbox. In such
case this message screen will not be shown again.
On Figure 6 the main menu dialog is presented. In this dialog user can
choose any strong numerical scheme for It^ o SDEs to perform modeling experi-
ment.
The tooltip example can be seen on Figure 7. Such tooltips displayed with
characteristic icon are placed all over software package interface to help user
with explanations.
As noted earlier, the dedicated charts window is universal tool for visualiza-
tion. The speci c examples of such visualization are presented on Figure 8,19,
34{36.
The initial state of input dialogs for nonlinear and linear It^ o SDEs are
displayed on Figures 9 and 20. At that moment user can start to input the
data.
The example of wrong scalar data input is presented on Figures 10, 15, 21,
and 31. When user input wrong data the error message appears and "Next" or
"Perform modeling" button is blocked. The input  eld is being checked all the
user data input process, and as soon as wrong character is entered noti cation
Electronic Journal. http://diffjournal.spbu.ru/ 159Differential Equations and Control Processes, N. 1, 2021
pops up.
If scalar data is correct the "Next" button is automatically unblocked. On
Figures 11, 16, 22, and 32 the examples of scenario are displayed.
On Figures 12, 13, and 28 the example of correct matrix data input is
presented. In this particular case the input is symbolic. Symbolic algebra
input errors are much harder to determine so this is done on further stages, in
modeling runtime.
In the other case when matrix input data are numerical, the validation is
performed right after user has  nished input. The examples of incorrect matrix
numerical input can be found on Figure 24.
When user  nishes input with a success the "Next" or "Perform modeling"
button is automatically unblocked. On Figures 23, 25{27, 29, and 30 that can
be clearly seen.
The Figures 17, 18, and 33 displays sequence of log messages emerged during
the modeling process.
After modeling has been done the focus moves to the charts window where
obtained modeling results can be seen. The results of modeling is displayed
on Figures 19, 34{36. On Figures 35 and 36 the expectations and variances of
obtained components of solution are displayed.
Figure 4: Fourier{Legendre coe cients database preparation screen
Electronic Journal. http://diffjournal.spbu.ru/ 160Differential Equations and Control Processes, N. 1, 2021
Figure 5: Greetings screen
Figure 6: Main menu dialog
Electronic Journal. http://diffjournal.spbu.ru/ 161Differential Equations and Control Processes, N. 1, 2021
Figure 7: Tooltip
Figure 8: Charts window
Electronic Journal. http://diffjournal.spbu.ru/ 162Differential Equations and Control Processes, N. 1, 2021
Figure 9: Nonlinear system of It^ o SDEs data input
Figure 10: Wrong data input
Electronic Journal. http://diffjournal.spbu.ru/ 163Differential Equations and Control Processes, N. 1, 2021
Figure 11: Correct data input
Figure 12: Vector function a(x;t) input
Electronic Journal. http://diffjournal.spbu.ru/ 164Differential Equations and Control Processes, N. 1, 2021
Figure 13: Matrix function B(x;t) input
Figure 14: Initial data input
Electronic Journal. http://diffjournal.spbu.ru/ 165Differential Equations and Control Processes, N. 1, 2021
Figure 15: Wrong data input
Figure 16: Correct data input
Electronic Journal. http://diffjournal.spbu.ru/ 166Differential Equations and Control Processes, N. 1, 2021
Figure 17: Modeling logs
Figure 18: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 167Differential Equations and Control Processes, N. 1, 2021
Figure 19: Modeling results
Figure 20: Linear system of It^ o SDEs data input
Electronic Journal. http://diffjournal.spbu.ru/ 168Differential Equations and Control Processes, N. 1, 2021
Figure 21: Wrong data input
Figure 22: Correct data input
Electronic Journal. http://diffjournal.spbu.ru/ 169Differential Equations and Control Processes, N. 1, 2021
Figure 23: Matrix A input
Figure 24: Wrong matrix A input
Electronic Journal. http://diffjournal.spbu.ru/ 170Differential Equations and Control Processes, N. 1, 2021
Figure 25: Correct matrix A input
Figure 26: Matrix B input
Electronic Journal. http://diffjournal.spbu.ru/ 171Differential Equations and Control Processes, N. 1, 2021
Figure 27: Matrix F input
Figure 28: Vector function u(t) input
Electronic Journal. http://diffjournal.spbu.ru/ 172Differential Equations and Control Processes, N. 1, 2021
Figure 29: Matrix H input
Figure 30: Initial data input
Electronic Journal. http://diffjournal.spbu.ru/ 173Differential Equations and Control Processes, N. 1, 2021
Figure 31: Wrong data input
Figure 32: Correct data input
Electronic Journal. http://diffjournal.spbu.ru/ 174Differential Equations and Control Processes, N. 1, 2021
Figure 33: Modeling logs
Figure 34: Modeling results (components of solution)
Electronic Journal. http://diffjournal.spbu.ru/ 175Differential Equations and Control Processes, N. 1, 2021
Figure 35: Modeling results (expectations)
Figure 36: Modeling results (variances)
Electronic Journal. http://diffjournal.spbu.ru/ 176Differential Equations and Control Processes, N. 1, 2021
5 The Results Obtained Using the SDE-MATH Software
Package
This section represents the results that were obtained with the SDE-MATH
software package at the current stage of the development.
5.1 The Calculated Fourier{Legendre Coe cients
When application runs  rst time it performs loading of Fourier{Legendre coef-
 cients basic pack in the database from the  les. Further, in Listings 1{4 few
examples of them can be seen.
Listing 1: The Fourier{Legendre coe cients C
000
j
3
j
2
j
1
examples
1 C 0:0:0 = 4/3
2 C 0:0:1 = −2/3
3 C 0:0:2 = 2/15
4 C 0:0:3 = 0
5 ...
6 C 0:6:4 = −4/429
7 C 0:6:5 = 2/143
8 C 0:6:6 = 2/2145
9 C 1:0:0 = 2/3
10 ...
11 C 47:33:44 = 3874457388633368/31334948307735906710660485
12 C 47:33:45 = 0
13 C 47:33:46 = 52892292737827468/2224781329849249376456894435
14 C 47:34:0 = 0
15 C 47:34:1 = 0
Listing 2: The Fourier{Legendre coe cients C
0000
j
4
j
3
j
2
j
1
examples
1 C 0:0:0:0 = 2/3
2 C 0:0:0:1 = −2/5
3 C 0:0:0:2 = 2/15
4 C 0:0:1:0 = −2/15
5 C 0:0:1:1 = 2/15
6 ...
7 C 1:1:0:1 = −2/35
8 C 1:1:0:2 = 0
9 C 1:1:1:0 = 2/105
10 C 1:1:1:1 = 0
11 ...
12 C 20:20:20:1 = −2401828/165607444685315115
13 C 20:20:20:2 = 0
14 C 20:20:20:3 = −1241929832/77669891557412788935
15 C 20:20:20:4 = 0
Electronic Journal. http://diffjournal.spbu.ru/ 177Differential Equations and Control Processes, N. 1, 2021
Listing 3: The Fourier{Legendre coe cients C
00000
j
5
j
4
j
3
j
2
j
1
examples
1 C 0:0:0:0:0 = 4/15
2 C 0:0:0:0:1 = −8/45
3 C 0:0:0:1:0 = −4/45
4 C 0:0:0:1:1 = 8/105
5 C 0:0:1:0:0 = 0
6 C 0:0:1:0:1 = 4/315
7 ...
8 C 1:1:0:1:0 = −4/315
9 C 1:1:0:1:1 = 4/315
10 C 1:1:1:0:0 = 2/105
11 C 1:1:1:0:1 = −8/945
12 C 1:1:1:1:0 = 2/945
13 C 1:1:1:1:1 = 0
14 ...
15 C 20:20:20:20:1 = 0
16 C 20:20:20:20:2 = −249877207023610010/10969028984480026752856704371
17 C 20:20:20:20:3 = 0
18 C 20:20:20:20:4 = −307937246954575016/571102494076952592887484313076115
Listing 4: The Fourier{Legendre coe cients C
000000
j
6
j
5
j
4
j
3
j
2
j
1
examples
1 C 0:0:0:0:0:0 = 4/45
2 C 0:0:0:0:0:1 = −4/63
3 C 0:0:0:0:0:2 = 2/63
4 C 0:0:0:0:1:0 = −4/105
5 ...
6 C 2:1:0:1:0:2 = −2/1575
7 C 2:1:0:1:1:0 = 38/22275
8 C 2:1:0:1:1:1 = −2/1575
9 C 2:1:0:1:1:2 = 68/81081
10 ...
11 C 15:15:15:15:15:15 = 0
12 C 15:15:15:15:15:16 = −798538765964/243076352242280511713913783475
13 C 15:15:15:15:15:17 = 0
14 C 15:15:15:15:15:18 = −59075427603328/17302616709609603697454044769175
5.2 Accuracy Settings
From Theorem 3 (see formulas (51){(66)) it follows that the number p in the
formula (48) should be chosen individually for various combinations of indices
i
1
;:::;i
k
2f1;:::;mg: As follows from Listing 5 (see below) and the results of
work [73], these numbersp in the overwhelming majority of cases do not exceed
the number p from the formula (51). Moreover, all the mentioned numbers p
are many times less than the number p selected using the formula (49) (due to
the presence of the multiplier factor k! on the left-hand side of (49)).
In this work, we have replaced the mentioned numbers p for all possible
Electronic Journal. http://diffjournal.spbu.ru/ 178Differential Equations and Control Processes, N. 1, 2021
combinations of indices i
1
;:::;i
k
2f1;:::;mg with the number p according to
the formula (51). This is possible due to the results of Listing 6. This listing
shows that the above replacement does not lead to noticeable accuracy loss of
the mean square approximation of iterated It^ o stochastic integrals (for more
details see [73]).
Thus, in this paper we decided to exclude the multiplier factor k! in the
conditions for choosing the numbers q
1
;:::;q
15
(see (169){(202)). Recall that
these numbers are used to construct the approximations of iterated It^ o and
Stratonovich stochastic integrals from the numerical schemes (13){(16), (25){
(28). The test script was written. The results of its work are presented in
Listings 5 and 6, where
1. dt is the integration step;
2. q1(1,2) means p from (54), q1(2,3) means p from (55), q1(1,3) means p
from (56), q1 means p from (51) for k = 3;
3. C = 1 (see (17) and (29));
4. error 1 means the left-hand side of (171);
5. error 2 means the left-hand side of (54) divided by (T t)
3
;
6. error 3 means the left-hand side of (56) divided by (T t)
3
;
7. error 4 means the left-hand side of (55) divided by (T t)
3
.
The above idea of calculation of the numbers q
1
;:::;q
15
is described in
Listing 109.
Listing 5: Accuracy calculation module
1
2 dt = 0.011
3 q1 = 12
4 q1 (1, 2) = 6
5 q1 (1, 3) = 12
6 q1 (2, 3) = 6
7
8 dt = 0.008
9 q1 = 16
10 q1 (1, 2) = 8
11 q1 (1, 3) = 16
12 q1 (2, 3) = 8
Electronic Journal. http://diffjournal.spbu.ru/ 179Differential Equations and Control Processes, N. 1, 2021
13
14 dt = 0.0045
15 q1 = 28
16 q1 (1, 2) = 14
17 q1 (1, 3) = 28
18 q1 (2, 3) = 14
19
20 dt = 0.0035
21 q1 = 36
22 q1 (1, 2) = 18
23 q1 (1, 3) = 36
24 q1 (2, 3) = 18
25
26 dt = 0.0027
27 q1 = 47
28 q1 (1, 2) = 23
29 q1 (1, 3) = 47
30 q1 (2, 3) = 23
31
32 dt = 0.0025
33 q1 = 50
34 q1 (1, 2) = 25
35 q1 (1, 3) = 51
36 q1 (2, 3) = 25
37
38
39 Process finished with exit code 0
Listing 6: Accuracy calculation module
1
2 dt = 0.011
3 error 1 = 0.010153888451696458
4 q1 = 12
5 error 2 = 0.005076944225848201
6 q1 (1, 2) = 12
7 error 3 = 0.010307776903394072
8 q1 (1, 3) = 12
9 error 4 = 0.005076944225848284
10 q1 (2, 3) = 12
11
12 dt = 0.008
13 error 1 = 0.007681193827577537
14 q1 = 16
15 error 2 = 0.003840596913789046
16 q1 (1, 2) = 16
17 error 3 = 0.0077866300793989485
18 q1 (1, 3) = 16
19 error 4 = 0.003840596913789157
20 q1 (2, 3) = 16
21
22 dt = 0.0045
Electronic Journal. http://diffjournal.spbu.ru/ 180Differential Equations and Control Processes, N. 1, 2021
23 error 1 = 0.004432832059862973
24 q1 = 28
25 error 2 = 0.0022164160299319446
26 q1 (1, 2) = 28
27 error 3 = 0.004479699207443705
28 q1 (1, 3) = 28
29 error 4 = 0.002216416029932139
30 q1 (2, 3) = 28
31
32 dt = 0.0035
33 error 1 = 0.0034564405520411956
34 q1 = 36
35 error 2 = 0.0017282202760207088
36 q1 (1, 2) = 36
37 error 3 = 0.003488223569838411
38 q1 (1, 3) = 36
39 error 4 = 0.0017282202760210141
40 q1 (2, 3) = 36
41
42 dt = 0.0027
43 error 1 = 0.0026523659377455377
44 q1 = 47
45 error 2 = 0.00132618296887127
46 q1 (1, 2) = 47
47 error 3 = 0.0026731529281250332
48 q1 (1, 3) = 47
49 error 4 = 0.0013261829688714366
50 q1 (2, 3) = 47
51
52 dt = 0.0025
53 error 1 = 0.002494053620431952
54 q1 = 50
55 error 2 = 0.0012470268102122428
56 q1 (1, 2) = 50
57 error 3 = 0.0025128597161119537
58 q1 (1, 3) = 50
59 error 4 = 0.0012470268102123538
60 q1 (2, 3) = 50
61
62
63 Process finished with exit code 0
5.3 Testing Example (Nonlinear System of It^ o SDEs)
The input data for testing of the SDE-MATH software package correspond
to the autonomous variant of nonlinear system of It^ o SDE (1) with multidi-
mensional non-commutative noise. More precisely, we choose n = 2; m = 2,
x
(1)
0
= 1; x
(2)
0
= 1:5;
Electronic Journal. http://diffjournal.spbu.ru/ 181Differential Equations and Control Processes, N. 1, 2021
a
 
x
(1)
; x
(2)
 
=
0
B
@
 5x
(1)
 5x
(2)
1
C
A
;
B
 
x
(1)
; x
(2)
 
=
0
B
@
0:5  sin
 
x
(1)
 
x
(2)
x
(2)
0:5  cos
 
x
(1)
 
1
C
A
:
Figures 37{92 related to the strong high-order Taylor{It^ o and Taylor{Stra-
tonovich schemes (12){(16), (24){(28) for the It^ o SDE (1) represent modeling
results.
Test machine speci cations are CPU with maximum core frequency 4.2 GHz
and 16GB of RAM.
5.4 Visualization and Numerical Results for Nonlinear System of
It^ o SDEs Obtained via the SDE-MATH Software Package
This subsection is fully devoted to modeling logs and results visualization. They
are presented on Figures 37{91
Euler scheme (dt = 0:001) Milstein scheme (C = 50; dt = 0:001)
Figure 37: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 182Differential Equations and Control Processes, N. 1, 2021
Figure 38: Strong Taylor{It^ o scheme of order 1.5 (C = 50; dt = 0:001)
Figure 39: Strong Taylor{It^ o schemes of orders 0:5; 1:0; and 1:5 (x
(1)
t
component, C = 50;
dt = 0:001)
Electronic Journal. http://diffjournal.spbu.ru/ 183Differential Equations and Control Processes, N. 1, 2021
Figure 40: Strong Taylor{It^ o schemes of orders 0:5; 1:0; and 1:5 (x
(2)
t
component, C = 50;
dt = 0:001)
Euler scheme (dt = 0:005) Milstein scheme (C = 500; dt = 0:005)
Figure 41: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 184Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{It^ o scheme of order 1.5 (C =
500; dt = 0:005)
Strong Taylor{It^ o scheme of order 2.0 (C =
500; dt = 0:005)
Figure 42: Modeling logs
Figure 43: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, and 2.0 (x
(1)
t
component,C = 500;
dt = 0:005)
Electronic Journal. http://diffjournal.spbu.ru/ 185Differential Equations and Control Processes, N. 1, 2021
Figure 44: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, and 2.0 (x
(2)
t
component,C = 500;
dt = 0:005)
Figure 45: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, and 2.5 (x
(1)
t
component,
C = 7500; dt = 0:01)
Electronic Journal. http://diffjournal.spbu.ru/ 186Differential Equations and Control Processes, N. 1, 2021
Euler scheme (dt = 0:01) Milstein scheme (C = 7500; dt = 0:01)
Strong Taylor{It^ o scheme of order 1.5 (C =
7500; dt = 0:01)
Strong Taylor{It^ o scheme of order 2.0 (C =
7500; dt = 0:01)
Strong Taylor{It^ o scheme of order 2.5 (C =
7500; dt = 0:01)
Figure 46: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 187Differential Equations and Control Processes, N. 1, 2021
Figure 47: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, and 2.5 (x
(2)
t
component,
C = 7500; dt = 0:01)
Figure 48: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(1)
t
component,
C = 14000; dt = 0:025)
Electronic Journal. http://diffjournal.spbu.ru/ 188Differential Equations and Control Processes, N. 1, 2021
Euler scheme (dt = 0:025) Milstein scheme (C = 14000; dt = 0:025)
Strong Taylor{It^ o scheme of order 1.5 (C =
14000; dt = 0:025)
Strong Taylor{It^ o scheme of order 2.0 (C =
14000; dt = 0:025)
Strong Taylor{It^ o scheme of order 2.5 (C =
14000; dt = 0:025)
Strong Taylor{It^ o scheme of order 3.0 (C =
14000; dt = 0:025)
Figure 49: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 189Differential Equations and Control Processes, N. 1, 2021
Figure 50: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(2)
t
component,
C = 14000; dt = 0:025)
Strong Taylor{Stratonovich scheme of order
1.0 (C = 50; dt = 0:001)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 50; dt = 0:001)
Figure 51: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 190Differential Equations and Control Processes, N. 1, 2021
Figure 52: Strong Taylor{Stratonovich schemes of orders 1.0 and 1.5 (x
(1)
t
component,C = 50;
dt = 0:001)
Figure 53: Strong Taylor{Stratonovich schemes of orders 1.0 and 1.5 (x
(2)
t
component,C = 50;
dt = 0:001)
Electronic Journal. http://diffjournal.spbu.ru/ 191Differential Equations and Control Processes, N. 1, 2021
Figure 54: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, and 2.0 (x
(1)
t
component,
C = 500; dt = 0:005)
Strong Taylor{Stratonovich scheme of order
1.0 (C = 500; dt = 0:005)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 500; dt = 0:005)
Figure 55: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 192Differential Equations and Control Processes, N. 1, 2021
Figure 56: Strong Taylor{Stratonovich scheme of order 2.0 (C = 500; dt = 0:005)
Figure 57: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, and 2.0 (x
(2)
t
component,
C = 500; dt = 0:005)
Electronic Journal. http://diffjournal.spbu.ru/ 193Differential Equations and Control Processes, N. 1, 2021
Figure 58: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, and 2.5 (x
(1)
t
component,
C = 7500; dt = 0:01)
Strong Taylor{Stratonovich scheme of order
1.0 (C = 7500; dt = 0:01)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 7500; dt = 0:01)
Figure 59: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 194Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{Stratonovich scheme of order
2.0 (C = 7500; dt = 0:01)
Strong Taylor{Stratonovich scheme of order
2.5 (C = 7500; dt = 0:01)
Figure 60: Modeling logs
Figure 61: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, and 2.5 (x
(2)
t
component,
C = 7500; dt = 0:01)
Electronic Journal. http://diffjournal.spbu.ru/ 195Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{Stratonovich scheme of order
1.0 (C = 14000; dt = 0:025)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 14000; dt = 0:025)
Strong Taylor{Stratonovich scheme of order
2.0 (C = 14000; dt = 0:025)
Strong Taylor{Stratonovich scheme of order
2.5 (C = 14000; dt = 0:025)
Strong Taylor{Stratonovich scheme of order
3.0 (C = 14000; dt = 0:025)
Figure 62: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 196Differential Equations and Control Processes, N. 1, 2021
Figure 63: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(1)
t
com-
ponent, C = 14000; dt = 0:025)
Figure 64: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(2)
t
com-
ponent, C = 14000; dt = 0:025)
Electronic Journal. http://diffjournal.spbu.ru/ 197Differential Equations and Control Processes, N. 1, 2021
Figure 65: Strong Taylor{It^ o schemes of orders 0.5, 1.0, and 1.5 (x
(1)
t
component, C = 0:1;
dt = 0:07)
Euler scheme (dt = 0:07) Milstein scheme (C = 0:1; dt = 0:07)
Figure 66: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 198Differential Equations and Control Processes, N. 1, 2021
Figure 67: Strong Taylor{It^ o scheme of order 1.5 (C = 0:1; dt = 0:07)
Figure 68: Strong Taylor{It^ o schemes of orders 0.5, 1.0, and 1.5 (x
(2)
t
component, C = 0:1;
dt = 0:07)
Electronic Journal. http://diffjournal.spbu.ru/ 199Differential Equations and Control Processes, N. 1, 2021
Figure 69: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, and 2.0 (x
(1)
t
component,C = 0:5;
dt = 0:15)
Euler scheme (dt = 0:15) Milstein scheme (C = 0:5; dt = 0:15)
Figure 70: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 200Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{It^ o scheme of order 1.5 (C =
0:5; dt = 0:15)
Strong Taylor{It^ o scheme of order 2.0 (C =
0:5; dt = 0:15)
Figure 71: Modeling logs
Figure 72: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, and 2.0 (x
(2)
t
component,C = 0:5;
dt = 0:15)
Electronic Journal. http://diffjournal.spbu.ru/ 201Differential Equations and Control Processes, N. 1, 2021
Euler scheme (dt = 0:2) Milstein scheme (C = 0:8; dt = 0:2)
Strong Taylor{It^ o scheme of order 1.5 (C =
0:8; dt = 0:2)
Strong Taylor{It^ o scheme of order 2.0 (C =
0:8; dt = 0:2)
Strong Taylor{It^ o scheme of order 2.5 (C =
0:8; dt = 0:2)
Figure 73: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 202Differential Equations and Control Processes, N. 1, 2021
Figure 74: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, and 2.5 (x
(1)
t
component,
C = 0:8; dt = 0:2)
Figure 75: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, and 2.5 (x
(2)
t
component,
C = 0:8; dt = 0:2)
Electronic Journal. http://diffjournal.spbu.ru/ 203Differential Equations and Control Processes, N. 1, 2021
Euler scheme (dt = 0:2) Milstein scheme (C = 4; dt = 0:2)
Strong Taylor{It^ o scheme of order 1.5 (C = 4;
dt = 0:2)
Strong Taylor{It^ o scheme of order 2.0 (C = 4;
dt = 0:2)
Strong Taylor{It^ o scheme of order 2.5 (C = 4;
dt = 0:2)
Strong Taylor{It^ o scheme of order 3.0 (C = 4;
dt = 0:2)
Figure 76: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 204Differential Equations and Control Processes, N. 1, 2021
Figure 77: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(1)
t
component,
C = 4; dt = 0:2)
Figure 78: Strong Taylor{It^ o schemes of orders 0.5, 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(2)
t
component,
C = 4; dt = 0:2)
Electronic Journal. http://diffjournal.spbu.ru/ 205Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{Stratonovich scheme of order
1.0 (C = 0:1; dt = 0:07)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 0:1; dt = 0:07)
Figure 79: Modeling logs
Figure 80: Strong Taylor{Stratonovich schemes of orders 1.0 and 1.5 (x
(1)
t
component,C = 0:1;
dt = 0:07)
Electronic Journal. http://diffjournal.spbu.ru/ 206Differential Equations and Control Processes, N. 1, 2021
Figure 81: Strong Taylor{Stratonovich schemes of orders 1.0 and 1.5 (x
(2)
t
component,C = 0:1;
dt = 0:07)
Strong Taylor{Stratonovich scheme of order
1.0 (C = 0:5; dt = 0:15)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 0:5; dt = 0:15)
Figure 82: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 207Differential Equations and Control Processes, N. 1, 2021
Figure 83: Strong Taylor{Stratonovich scheme of order 2.0 (C = 0:5; dt = 0:15)
Figure 84: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, and 2.0 (x
(1)
t
component,
C = 0:5; dt = 0:15)
Electronic Journal. http://diffjournal.spbu.ru/ 208Differential Equations and Control Processes, N. 1, 2021
Figure 85: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, and 2.0 (x
(2)
t
component,
C = 0:5; dt = 0:15)
Strong Taylor{Stratonovich scheme of order
1.0 (C = 0:8; dt = 0:2)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 0:8; dt = 0:2)
Figure 86: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 209Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{Stratonovich scheme of order
2.0 (C = 0:8; dt = 0:2)
Strong Taylor{Stratonovich scheme of order
2.5 (C = 0:8; dt = 0:2)
Figure 87: Modeling logs
Figure 88: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, and 2.5 (x
(1)
t
component,
C = 0:8; dt = 0:2)
Electronic Journal. http://diffjournal.spbu.ru/ 210Differential Equations and Control Processes, N. 1, 2021
Figure 89: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, and 2.5 (x
(2)
t
component,
C = 0:8; dt = 0:2)
Figure 90: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(1)
t
com-
ponent, C = 4; dt = 0:2)
Electronic Journal. http://diffjournal.spbu.ru/ 211Differential Equations and Control Processes, N. 1, 2021
Strong Taylor{Stratonovich scheme of order
1.0 (C = 4; dt = 0:2)
Strong Taylor{Stratonovich scheme of order
1.5 (C = 4; dt = 0:2)
Strong Taylor{Stratonovich scheme of order
2.0 (C = 4; dt = 0:2)
Strong Taylor{Stratonovich scheme of order
2.5 (C = 4; dt = 0:2)
Strong Taylor{Stratonovich scheme of order
3.0 (C = 4; dt = 0:2)
Figure 91: Modeling logs
Electronic Journal. http://diffjournal.spbu.ru/ 212Differential Equations and Control Processes, N. 1, 2021
Figure 92: Strong Taylor{Stratonovich schemes of orders 1.0, 1.5, 2.0, 2.5, and 3.0 (x
(2)
t
com-
ponent, C = 4; dt = 0:2)
5.5 Example of Linear System of It^ o SDEs (Solar Activity)
Consider a mathematical model of the solar activity without its average value
in a form of the system of linear It^ o SDEs (246) [4]. In (246) we choose [4]
n = 2; m = 1; k = 2; x
(1)
0
= 7; x
(2)
0
= 0:25;
A =
0
B
@
0 1
 0:3205  0:14
1
C
A
; B =
0
B
@
0 0
0 0
1
C
A
; (250)
u(t) 
0
B
@
0
0
1
C
A
; F =
0
B
@
0
5:08
1
C
A
: (251)
5.6 Visualization and Numerical Results for Solar Activity Model
This subsection is devoted to the visualization and numerical results for the
model of solar activity (246), (250), (251).
Electronic Journal. http://diffjournal.spbu.ru/ 213Differential Equations and Control Processes, N. 1, 2021
Figure 93: Modeling logs for solar activity model
Figure 94: Solar activity model (x
(1)
t
component)
Electronic Journal. http://diffjournal.spbu.ru/ 214Differential Equations and Control Processes, N. 1, 2021
Figure 95: Solar activity model (x
(2)
t
component)
Figure 96: Solar activity model (expectations)
Electronic Journal. http://diffjournal.spbu.ru/ 215Differential Equations and Control Processes, N. 1, 2021
Figure 97: Solar activity model (variances)
5.7 Example of Abstract Linear System of It^ o SDEs
Now consider the system of linear It^ o SDEs (246) with the following data
n = 4; m = 5; k = 3; x
(1)
0
= 1; x
(2)
0
= 2; x
(3)
0
= 1; x
(4)
0
= 2; (252)
A =
0
B
B
B
B
B
B
B
B
B
B
B
@
 1 0 0 0
0  2 0 0
0 0  3 0
0 0 0  4
1
C
C
C
C
C
C
C
C
C
C
C
A
; B =
0
B
B
B
B
B
B
B
B
B
B
B
@
1 1 1
1 1 1
1 1 1
1 1 1
1
C
C
C
C
C
C
C
C
C
C
C
A
; F =
0
B
B
B
B
B
B
B
B
B
B
B
@
0:2 0:1 0:1 0:1 0:1
0:1 0:2 0:1 0:1 0:1
0:1 0:1 0:2 0:1 0:1
0:1 0:1 0:1 0:2 0:1
1
C
C
C
C
C
C
C
C
C
C
C
A
;
(253)
u(t) 
 
0 0 0
 
T
; H =
 
0:1 0:1 0:1 0:1
 
: (254)
Electronic Journal. http://diffjournal.spbu.ru/ 216Differential Equations and Control Processes, N. 1, 2021
5.8 Visualization and Numerical Results for Abstract Linear System
of It^ o SDEs Obtained via the SDE-MATH Software Package
This subsection is devoted to the visualization and numerical results for the
model (246), (252){(254).
Figure 98: Modeling logs (linear system of It^ o SDEs (246), (252){(254))
Figure 99: Linear system of It^ o SDEs (246), (252){(254) (components of solution)
Electronic Journal. http://diffjournal.spbu.ru/ 217Differential Equations and Control Processes, N. 1, 2021
Figure 100: Linear system of It^ o SDEs (246), (252){(254) (expectations)
Figure 101: Linear system of It^ o SDEs (246), (252){(254) (variances)
Electronic Journal. http://diffjournal.spbu.ru/ 218Differential Equations and Control Processes, N. 1, 2021
6 Source Codes of the SDE-MATH Software Package in
the Python Programming Language
6.1 Source Codes of Graphical User Interface
6.1.1 Source Codes of Main Menu
Listing 7: Con guration  le example
1 """
2 Configuration file example , change this paths to yours
3 """
4
5 # Paths to resources
6 resources = "./ resources/"
7
8 # Path to database
9 database = "./ resources/database.db"
10
11 # Size of read buffer for the Fourier−Legendre coefficients
12 read buffer size = 8192
13
14 # Recursion limit for the Fourier−Legendre calculations
15 recursion limit = 10 ∗∗ 8
Listing 8: Program entry
1 #!/usr/bin/env python
2 import logging
3 import os
4 import sys
5
6 from PyQt5 import QtGui, QtWidgets
7 from PyQt5.QtWidgets import QApplication
8 from PyQt5.QtWinExtras import QWinTaskbarButton
9
10 from config import database , images
11 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
12 from tools .database import connect , disconnect
13 from ui .main.main window import MainWindow
14
15
16 def main() :
17
18 logging . basicConfig(
19 level=logging .INFO,
20 format="%(asctime)s − %(levelname)s − %(message)s",
21 datefmt="%H:%M:%S"
Electronic Journal. http://diffjournal.spbu.ru/ 219Differential Equations and Control Processes, N. 1, 2021
22 )
23
24 app = QApplication(sys .argv)
25 app.setWindowIcon(QtGui.QIcon(os.path. join(images , "function .png")))
26 app. setStyle(QtWidgets.QStyleFactory. create( 'Fusion '))
27
28 main window = MainWindow()
29
30 main window. taskbar button = QWinTaskbarButton()
31 main window. taskbar button . setOverlayIcon(QtGui.QIcon("resources/function .svg"))
32
33 exit(app.exec())
34
35
36 if name == " main ":
37 main()
Listing 9: Main window
1 from PyQt5.QtCore import QThreadPool, pyqtSignal
2 from PyQt5.QtWidgets import QStackedWidget , QMainWindow
3 from sympy. physics .mechanics. tests . test system import lam
4
5 from init . initialization import initialization
6 from tools . fsys import is locked
7 from ui . async calls .worker import Worker
8 from ui . charts .charts window import PlotWindow
9 from ui .main. greetings import GreetingsWidget
10 from ui .main.menu.base import MainMenuWidget
11 from ui .main.modeling. linear .base import LinearModelingWidget
12 from ui .main.modeling. nonliear .base import NonlinearModelingWidget
13 from ui .main. progress . complex progress import ComplexProgressWidget
14 from ui .main. progress . simple progress import SimpleProgressWidget
15
16
17 class MainWindow(QMainWindow):
18
19 main window close = pyqtSignal()
20 start simple progress = pyqtSignal(str)
21 stop simple progress = pyqtSignal(str)
22
23 def init ( self ):
24 super(QMainWindow, self ). init ()
25
26 self .plot window = PlotWindow()
27
28 self . stack widget = QStackedWidget( self )
29
30 self .main menu = MainMenuWidget( self . stack widget)
31 self . complex progress = ComplexProgressWidget( self . stack widget)
32 self . simple progress = SimpleProgressWidget( self . stack widget)
33 self . greetings = GreetingsWidget( self . stack widget)
34 self . linear modeling = LinearModelingWidget( self . stack widget)
Electronic Journal. http://diffjournal.spbu.ru/ 220Differential Equations and Control Processes, N. 1, 2021
35 self . nonlinear modeling = NonlinearModelingWidget( self . stack widget)
36
37 self . stack widget .addWidget( self .main menu)
38 self . stack widget .addWidget( self . nonlinear modeling)
39 self . stack widget .addWidget( self . linear modeling)
40 self . stack widget .addWidget( self . greetings)
41 self . stack widget .addWidget( self . simple progress)
42 self . stack widget .addWidget( self . complex progress)
43
44 self .setCentralWidget( self . stack widget)
45
46 self . exec init ()
47
48 self .setWindowTitle("SDE−MATH: software package")
49 self .setMinimumSize(640, 480)
50 self . resize (800, 600)
51 self .show()
52
53 self .main menu.group1. show nonlinear dialog .connect( self . show nonlinear)
54 self .main menu.group2. show nonlinear dialog .connect( self . show nonlinear)
55 self .main menu.group3. show linear dialog .connect(
56 lambda: self . stack widget .setCurrentWidget( self . linear modeling))
57
58 self . nonlinear modeling .show main menu.connect(
59 lambda: self . stack widget .setCurrentWidget( self .main menu))
60 self . nonlinear modeling . start progress .connect(
61 lambda: self . stack widget .setCurrentWidget( self . complex progress))
62
63 self . linear modeling .show main menu.connect(
64 lambda: self . stack widget .setCurrentWidget( self .main menu))
65 self . linear modeling . start progress .connect(
66 lambda: self . stack widget .setCurrentWidget( self . complex progress))
67
68 self . greetings .show main menu.connect(
69 lambda: self . stack widget .setCurrentWidget( self .main menu))
70
71 self . greetings .show main menu.connect(
72 lambda: self . stack widget .setCurrentWidget( self .main menu))
73
74 self . greetings .show main menu.connect(
75 lambda: self . stack widget .setCurrentWidget( self .main menu))
76
77 self . complex progress .back btn. clicked .connect(
78 lambda: self . stack widget .setCurrentWidget( self .main menu))
79
80 # plot events
81
82 self .main window close.connect( self .plot window. close)
83
84 self .main menu. charts check . clicked .connect( self .plot window. setVisible)
85 self .plot window. charts show .connect(
86 lambda: self .main menu. charts check .setChecked(True))
87 self .plot window. charts hide .connect(
88 lambda: self .main menu. charts check .setChecked(False))
89
Electronic Journal. http://diffjournal.spbu.ru/ 221Differential Equations and Control Processes, N. 1, 2021
90 self . nonlinear modeling .draw chart.connect( self .plot window. charts list .new items)
91 self . nonlinear modeling .draw chart.connect( self .plot window. plot widget .new items)
92 self . nonlinear modeling .draw chart.connect( self .plot window.show)
93
94 self . nonlinear modeling . charts check .stateChanged.connect( self .plot window. setVisible
)
95 self .plot window. charts show .connect(
96 lambda: self . nonlinear modeling . charts check .setChecked(True))
97 self .plot window. charts hide .connect(
98 lambda: self . nonlinear modeling . charts check .setChecked(False))
99
100 self . linear modeling .draw chart.connect( self .plot window. charts list .new items)
101 self . linear modeling .draw chart.connect( self .plot window. plot widget .new items)
102 self . linear modeling .draw chart.connect( self .plot window.show)
103
104 self . linear modeling . charts check . clicked .connect( self .plot window. setVisible)
105 self .plot window. charts show .connect(
106 lambda: self . linear modeling . charts check .setChecked(True))
107 self .plot window. charts hide .connect(
108 lambda: self . linear modeling . charts check .setChecked(False))
109
110 self . linear modeling . start progress .connect( self . complex progress . spin)
111 self . nonlinear modeling . start progress .connect( self . complex progress . spin)
112 self . linear modeling . stop progress .connect( self . complex progress . stop)
113 self . nonlinear modeling . stop progress .connect( self . complex progress . stop)
114
115 def closeEvent(self , event):
116 self .main window close.emit()
117
118 def exec init ( self ):
119 self . simple progress . spin("Preparing the database ... ")
120 self . stack widget .setCurrentWidget( self . simple progress)
121
122 worker = Worker( initialization )
123 worker. signals . finished .connect( self . init done)
124
125 QThreadPool. globalInstance () . start(worker)
126
127 def init done( self ):
128 if not is locked(".welcome. lock"):
129 self . stack widget .setCurrentWidget( self . greetings)
130 else :
131 self . stack widget .setCurrentWidget( self .main menu)
132 self . simple progress .stop()
133
134 def show nonlinear(self , scheme id):
135 self . nonlinear modeling . set scheme(scheme id)
136 self . stack widget .setCurrentWidget( self . nonlinear modeling)
Listing 10: Greetings window
1 from PyQt5.QtCore import pyqtSignal , Qt
2 from PyQt5.QtWidgets import QPushButton, QVBoxLayout, QWidget, QSizePolicy , n
Electronic Journal. http://diffjournal.spbu.ru/ 222Differential Equations and Control Processes, N. 1, 2021
3 QSpacerItem , QHBoxLayout, QLabel, QCheckBox, QApplication , QStyle
4
5 from tools . fsys import lock , unlock
6 from ui .main.svg import SVG
7
8
9 class GreetingsWidget(QWidget):
10
11 show main menu = pyqtSignal()
12
13 def init (self , parent=None):
14 super(QWidget, self ). init (parent)
15
16 header = QLabel("Welcome to SDE−MATH Software Package for "
17 "the Numerical Solution of Systems of Ito SDEs")
18 font = header. font()
19 font . setPointSize(15)
20 header.setAlignment(Qt. AlignJustify)
21 header.setWordWrap(True)
22 header.setFont(font)
23
24 welcome = QLabel(
25 "Exact solutions of Ito SDEs are known in rare cases . For this "
26 "reason , it becomes necessary to construct numerical methods for "
27 "Ito SDEs. Moreover , the problem of numerical solution of Ito SDEs "
28 "often occurs even in cases when the exact solution of Ito SDE is known. "
29 "This means that in some cases , knowing the exact solution to the Ito "
30 "SDE does not allow us to simulate it numerically in a simple way.", self
31 )
32
33 font = welcome. font()
34 welcome.setFont(font)
35
36 welcome.setAlignment(Qt. AlignJustify)
37 welcome.setWordWrap(True)
38 welcome. setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Minimum))
39
40 check again = QCheckBox("Do not show again", self )
41 next btn = QPushButton("Ok", self )
42 next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP DialogApplyButton))
43
44 check again . clicked .connect( self . check lock)
45 next btn . clicked .connect(lambda: self .show main menu.emit())
46
47 controls = QHBoxLayout()
48 controls .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
49 controls .addWidget(check again)
50 controls .addWidget(next btn)
51 controls .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
52
53 eq1 = QHBoxLayout()
54 eq1.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
55 eq1.addWidget(SVG("equation1 .svg", scale factor=1.))
56 eq1.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
57
Electronic Journal. http://diffjournal.spbu.ru/ 223Differential Equations and Control Processes, N. 1, 2021
58 eq2 = QHBoxLayout()
59 eq2.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
60 eq2.addWidget(SVG("equation2 .svg", scale factor=1.))
61 eq2.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
62
63 column = QVBoxLayout()
64 column.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
65 column.addWidget(header)
66 column.addItem(QSpacerItem(0, 15, QSizePolicy .Expanding , QSizePolicy .Minimum))
67 column.addLayout(eq1)
68 column.addItem(QSpacerItem(0, 15, QSizePolicy .Expanding , QSizePolicy .Minimum))
69 column.addLayout(eq2)
70 column.addItem(QSpacerItem(0, 15, QSizePolicy .Expanding , QSizePolicy .Minimum))
71 column.addWidget(welcome)
72 column.addItem(QSpacerItem(0, 30, QSizePolicy .Expanding , QSizePolicy .Minimum))
73 column.addLayout(controls)
74 column.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
75
76 layout = QHBoxLayout()
77 layout .addItem(QSpacerItem(50, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
78 layout .addLayout(column)
79 layout .addItem(QSpacerItem(50, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
80
81 self .setLayout(layout)
82
83 def check lock( self ):
84 if self . sender() .isChecked() :
85 lock(".welcome. lock")
86 else :
87 unlock(".welcome. lock")
Listing 11: Info icon
1 from PyQt5.QtCore import QSize
2 from PyQt5.QtWidgets import QWidget, QApplication , QStyle , QLabel
3
4
5 class InfoIcon(QLabel):
6
7 def init (self , text : str , parent=None):
8 super(QWidget, self ). init (parent)
9
10 self .setToolTip(text)
11 self . setStyleSheet("QToolTip fbackground: white;g")
12 self .setPixmap(QApplication. style () . standardIcon(
13 QStyle.SP MessageBoxInformation).pixmap(QSize(16, 16)))
Listing 12: Error widget
1 from PyQt5.QtCore import QSize
2 from PyQt5.QtWidgets import QWidget, QApplication , QStyle , QLabel, QHBoxLayout,
QSpacerItem , QSizePolicy
Electronic Journal. http://diffjournal.spbu.ru/ 224Differential Equations and Control Processes, N. 1, 2021
3
4
5 class ErrorWidget(QWidget):
6
7 def init (self , text : str , parent=None):
8 super(QWidget, self ). init (parent)
9
10 msg m = QLabel(text)
11 msg m. setStyleSheet("QLabel f color : rgb(230, 0, 0); g")
12
13 msg i = QLabel()
14 msg i. setStyleSheet("QToolTip f background: white; g")
15 msg i.setPixmap(QApplication. style () . standardIcon(
16 QStyle.SP MessageBoxCritical).pixmap(QSize(16, 16)))
17
18 layout = QHBoxLayout()
19 layout .setContentsMargins(0, 0, 0, 0)
20 layout .addWidget(msg i)
21 layout .addWidget(msg m)
22 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
23
24 self .setLayout(layout)
Listing 13: Svg picture
1 import os
2
3 from PyQt5.QtCore import QSize
4 from PyQt5.QtSvg import QSvgWidget
5 from PyQt5.QtWidgets import QSizePolicy
6
7 from config import images
8
9
10 class SVG(QSvgWidget):
11
12 def init (self , name: str , scale factor=1.):
13 super(QSvgWidget, self ). init ()
14
15 self . load(os.path. join(images , name))
16
17 self . scale factor = scale factor
18 self . setSizePolicy(QSizePolicy .Fixed , QSizePolicy .Fixed)
19
20 def sizeHint( self ):
21 size = self . renderer() . defaultSize ()
22 return QSize(size .width() ∗ self . scale factor ,
23 size . height() ∗ self . scale factor )
Listing 14: Main menu (base part)
1 from PyQt5.QtWidgets import QWidget, QSizePolicy , QSpacerItem , QHBoxLayout, QVBoxLayout,
Electronic Journal. http://diffjournal.spbu.ru/ 225Differential Equations and Control Processes, N. 1, 2021
QCheckBox, QLabel
2
3 from ui .main. info import InfoIcon
4 from ui .main.menu. linear import LinearGroupWidget
5 from ui .main.menu. taylor ito import ItoGroupWidget
6 from ui .main.menu. taylor stratonovich import StratonovichGroupWidget
7
8
9 class MainMenuWidget(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . charts check = QCheckBox("Charts window", self )
15
16 icon = InfoIcon("This is charts window checkbox , it willnn"
17 "follow you on every application dialog , sonn"
18 "you can easily open or close window with available charts")
19
20 bar layout = QHBoxLayout()
21 bar layout .addItem(QSpacerItem(0, 35, QSizePolicy .Expanding , QSizePolicy .Minimum))
22 bar layout .addWidget(icon)
23 bar layout .addWidget( self . charts check)
24
25 header = QLabel("Strong Numerical Schemes for Ito SDEs", parent=self )
26 font = header. font()
27 font . setPointSize(15)
28 header.setFont(font)
29
30 icon = InfoIcon("You are now in main menu, you can choosenn"
31 "any scheme to perform modeling")
32
33 header layout = QHBoxLayout()
34 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding)
)
35 header layout .addWidget(icon)
36 header layout .addWidget(header)
37 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding)
)
38
39 self .group3 = LinearGroupWidget( self )
40 self .group1 = ItoGroupWidget( self )
41 self .group2 = StratonovichGroupWidget( self )
42
43 menu layout = QHBoxLayout()
44 menu layout.addWidget( self .group1)
45 menu layout.addWidget( self .group2)
46 menu layout.addWidget( self .group3)
47
48 layout = QVBoxLayout()
49 layout .addLayout(bar layout)
50 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
51 layout .addLayout(header layout)
52 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
53 layout .addLayout(menu layout)
Electronic Journal. http://diffjournal.spbu.ru/ 226Differential Equations and Control Processes, N. 1, 2021
54 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
55
56 self .setLayout(layout)
Listing 15: Main menu (linear part)
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QPushButton, QVBoxLayout, QSizePolicy , QSpacerItem , QGroupBox
3
4
5 class LinearGroupWidget(QGroupBox):
6
7 show linear dialog = pyqtSignal()
8
9 def init (self , parent=None):
10 super(QGroupBox, self ). init (parent)
11
12 linear btn = QPushButton("Dispersion Spectral Decomposition")
13
14 layout = QVBoxLayout()
15 layout .addWidget(linear btn)
16 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
17
18 self .setLayout(layout)
19
20 self . setTitle("Linear Ito SDEs Systems Modeling")
21 self . setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Expanding))
22
23 linear btn . clicked .connect(lambda: self . show linear dialog .emit())
Listing 16: Main menu (Taylor-It^ o part)
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QPushButton, QVBoxLayout, QSizePolicy , QSpacerItem , QGroupBox
3
4
5 class ItoGroupWidget(QGroupBox):
6
7 show nonlinear dialog = pyqtSignal(int)
8
9 def init (self , parent=None):
10 super(QGroupBox, self ). init (parent)
11
12 btn1 = QPushButton("Euler")
13 btn2 = QPushButton("Milstein")
14 btn3 = QPushButton("Convergence Order 1.5")
15 btn4 = QPushButton("Convergence Order 2.0")
16 btn5 = QPushButton("Convergence Order 2.5")
17 btn6 = QPushButton("Convergence Order 3.0")
18
19 layout = QVBoxLayout()
20 layout .addWidget(btn1)
Electronic Journal. http://diffjournal.spbu.ru/ 227Differential Equations and Control Processes, N. 1, 2021
21 layout .addWidget(btn2)
22 layout .addWidget(btn3)
23 layout .addWidget(btn4)
24 layout .addWidget(btn5)
25 layout .addWidget(btn6)
26 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
27
28 self .setLayout(layout)
29
30 self . setTitle("Taylor−Ito Schemes")
31 self . setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Expanding))
32
33 btn1. clicked .connect(lambda: self . show nonlinear dialog .emit(0))
34 btn2. clicked .connect(lambda: self . show nonlinear dialog .emit(1))
35 btn3. clicked .connect(lambda: self . show nonlinear dialog .emit(2))
36 btn4. clicked .connect(lambda: self . show nonlinear dialog .emit(3))
37 btn5. clicked .connect(lambda: self . show nonlinear dialog .emit(4))
38 btn6. clicked .connect(lambda: self . show nonlinear dialog .emit(5))
Listing 17: Main menu (Taylor{Stratonovich part)
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QPushButton, QVBoxLayout, QSizePolicy , QSpacerItem , QGroupBox
3
4
5 class StratonovichGroupWidget(QGroupBox):
6
7 show nonlinear dialog = pyqtSignal(int)
8
9 def init (self , parent=None):
10 super(QGroupBox, self ). init (parent)
11
12 btn1 = QPushButton("Convergence Order 1.0")
13 btn2 = QPushButton("Convergence Order 1.5")
14 btn3 = QPushButton("Convergence Order 2.0")
15 btn4 = QPushButton("Convergence Order 2.5")
16 btn5 = QPushButton("Convergence Order 3.0")
17
18 layout = QVBoxLayout()
19 layout .addWidget(btn1)
20 layout .addWidget(btn2)
21 layout .addWidget(btn3)
22 layout .addWidget(btn4)
23 layout .addWidget(btn5)
24 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
25
26 self .setLayout(layout)
27
28 self . setTitle("Taylor−Stratonovich Schemes")
29 self . setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Expanding))
30
31 btn1. clicked .connect(lambda: self . show nonlinear dialog .emit(6))
32 btn2. clicked .connect(lambda: self . show nonlinear dialog .emit(7))
Electronic Journal. http://diffjournal.spbu.ru/ 228Differential Equations and Control Processes, N. 1, 2021
33 btn3. clicked .connect(lambda: self . show nonlinear dialog .emit(8))
34 btn4. clicked .connect(lambda: self . show nonlinear dialog .emit(9))
35 btn5. clicked .connect(lambda: self . show nonlinear dialog .emit(10))
Listing 18: Complex progress view
1 import logging
2
3 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QSpacerItem , QSizePolicy ,
n
4 QListWidget , QLabel, QPushButton, QApplication , QStyle
5 from pyqtspinner . spinner import WaitingSpinner
6
7 from ui .main. progress . log handler import LogHandler
8
9
10 class ComplexProgressWidget(QWidget):
11
12 def init (self , parent=None):
13 super(QWidget, self ). init (parent)
14
15 self . spinner = WaitingSpinner(self ,
16 radius=5.0,
17 lines=10,
18 line length=5.0,
19 centerOnParent=False)
20 self . list widget = QListWidget( self )
21 self . handler = LogHandler( self .handle message)
22
23 self . label = QLabel( self )
24 font = self . label . font()
25 font . setPointSize(15)
26 self . label .setFont(font)
27
28 self .back btn = QPushButton("Ok")
29 self .back btn. setIcon(QApplication. style () . standardIcon(QStyle.SP DialogApplyButton))
30 self .back btn. hide()
31
32 spinner layout = QHBoxLayout()
33 spinner layout .addWidget( self . spinner)
34 spinner layout .addWidget( self . label)
35 spinner layout .addSpacerItem(QSpacerItem(0, 0, QSizePolicy .Expanding ,
36 QSizePolicy .Minimum))
37
38 bottom bar = QHBoxLayout()
39 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
40 bottom bar.addWidget( self .back btn)
41
42 layout = QVBoxLayout()
43 layout .addLayout(spinner layout)
44 layout .addWidget( self . list widget )
45 layout .addLayout(bottom bar)
46
Electronic Journal. http://diffjournal.spbu.ru/ 229Differential Equations and Control Processes, N. 1, 2021
47 self .setLayout(layout)
48
49 def handle message(self , text):
50 self . list widget .addItem(text)
51 self . list widget .scrollToBottom()
52
53 def spin(self , text):
54 self . list widget . clear ()
55 logging .getLogger() .addHandler( self . handler)
56 self .back btn. hide()
57 self . spinner . start ()
58 self . label .setText(text)
59
60 def stop(self , text):
61 self .back btn.show()
62 self . list widget .scrollToBottom()
63 self . label .setText(text)
64 self . spinner .stop()
65 logging .getLogger() .removeHandler( self . handler)
Listing 19: Simple progress view
1 from PyQt5.QtCore import Qt
2 from PyQt5.QtWidgets import QVBoxLayout, QWidget, QLabel, QSpacerItem , QSizePolicy
3 from pyqtspinner . spinner import WaitingSpinner
4
5
6 class SimpleProgressWidget(QWidget):
7
8 def init (self , parent=None):
9 super(QWidget, self ). init (parent)
10
11 self . spinner = WaitingSpinner(self , radius=15.0, lines=10, line length=15.0)
12
13 self . label = QLabel()
14 self . label .setAlignment(Qt.AlignCenter)
15 font = self . label . font()
16 font . setPointSize(15)
17 self . label .setFont(font)
18
19 layout = QVBoxLayout()
20 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
21 layout .addWidget( self . spinner)
22 layout .addItem(QSpacerItem(0, 50, QSizePolicy .Minimum, QSizePolicy .Minimum))
23 layout .addWidget( self . label)
24 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding))
25
26 self .setLayout(layout)
27
28 def spin(self , text):
29 self . spinner . start ()
30 self . label .setText(text)
31
Electronic Journal. http://diffjournal.spbu.ru/ 230Differential Equations and Control Processes, N. 1, 2021
32 def stop( self ):
33 self . spinner .stop()
Listing 20: Log handler for application
1 import logging
2
3
4 class LogHandler(logging .Handler):
5
6 def init (self , callback):
7 super() . init ()
8 self . callback = callback
9 self . setFormatter(logging .Formatter("%(asctime)s − %(message)s", "%H:%M:%S"))
10
11 def handle(self , record):
12 self . callback( self .format(record))
Listing 21: Matrix widget
1 from PyQt5.QtWidgets import QTableWidgetItem , QTableWidget, QSizePolicy
2
3
4 class MatrixWidget(QTableWidget):
5
6 def init (self , parent=None):
7 super(QTableWidget, self ). init (parent)
8
9 self .itemChanged.connect( self .item changed)
10 self .m = [["0"]]
11
12 self .setRowCount(1)
13 self .setColumnCount(1)
14 self . setItem(0, 0, CustomItem("0"))
15
16 self . setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Expanding))
17
18 def resize w(self , w: int):
19
20 self . blockSignals(True)
21
22 old w = self .columnCount()
23 self .setColumnCount(w)
24 h = self .rowCount()
25
26 self .m = [[ self .m[ i ][ j ] if i < h and j < old w else "0"
27 for j in range(w)]
28 for i in range(h)]
29
30 for i in range(h):
31 for j in range(w):
32 item = self .item(i , j)
Electronic Journal. http://diffjournal.spbu.ru/ 231Differential Equations and Control Processes, N. 1, 2021
33 if item is not None:
34 item.setText( self .m[ i ][ j ])
35 else :
36 self . setItem(i , j , CustomItem( self .m[ i ][ j ]) )
37
38 self . blockSignals(False)
39
40 def resize h(self , h: int):
41
42 self . blockSignals(True)
43
44 old h = self .rowCount()
45 w = self .columnCount()
46 self .setRowCount(h)
47
48 self .m = [[ self .m[ i ][ j ] if i < old h and j < w else "0"
49 for j in range(w)]
50 for i in range(h)]
51
52 for i in range(h):
53 for j in range(w):
54 item = self .item(i , j)
55 if item is not None:
56 item.setText( self .m[ i ][ j ])
57 else :
58 self . setItem(i , j , CustomItem( self .m[ i ][ j ]) )
59
60 self . blockSignals(False)
61
62 def item changed(self , item):
63 self .m[item.row() ][ item.column() ] = item. text()
64
65
66 class CustomItem(QTableWidgetItem):
67
68 def init (self , value : str):
69 super(QTableWidgetItem , self ). init (value)
70
71 self . valid = True
6.1.2 Source Codes of Charts Window
Listing 22: Charts window
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QMainWindow, QSplitter
3
4 from ui . charts . side . available charts widget import AvailableChartsWidget
5 from ui . charts . visuals . charts widget import ChartsWidget
6
7
Electronic Journal. http://diffjournal.spbu.ru/ 232Differential Equations and Control Processes, N. 1, 2021
8 class PlotWindow(QMainWindow):
9
10 charts show = pyqtSignal()
11 charts hide = pyqtSignal()
12
13 def init ( self ):
14 super(QMainWindow, self ). init ()
15
16 self . plot widget = ChartsWidget( self )
17 self . charts list = AvailableChartsWidget( self )
18
19 splitter = QSplitter ()
20 splitter .addWidget( self . charts list )
21 splitter .addWidget( self . plot widget)
22 splitter . setSizes ([ splitter .width() / 0.85,
23 splitter .width() / 0.15])
24
25 layout = QHBoxLayout( self )
26 layout .addWidget( splitter )
27
28 central widget = QWidget()
29 central widget .setLayout(layout)
30 self .setCentralWidget(central widget)
31
32 self .setWindowTitle("SDE−MATH: charts window")
33 self . resize (1200, 800)
34
35 self . charts list . on show all .connect( self . plot widget . show all)
36 self . charts list . on hide all .connect( self . plot widget . hide all )
37 self . charts list . on remove all .connect( self . plot widget . delete all )
38
39 def showEvent(self , event):
40 self . charts show .emit()
41
42 def closeEvent(self , event):
43 self . charts hide .emit()
Listing 23: Curves list
1 import os
2
3 from PyQt5 import QtGui
4 from PyQt5.QtCore import pyqtSignal
5 from PyQt5.QtWidgets import QVBoxLayout, QWidget, QSizePolicy , QSpacerItem , n
6 QScrollArea , QLabel, QHBoxLayout, QPushButton, QApplication , QStyle
7
8 from config import images
9 from ui . charts . side . item widget import ItemWidget
10 from ui .main. info import InfoIcon
11
12
13 class AvailableChartsWidget(QWidget):
14
Electronic Journal. http://diffjournal.spbu.ru/ 233Differential Equations and Control Processes, N. 1, 2021
15 on hide all = pyqtSignal()
16 on show all = pyqtSignal()
17 on remove all = pyqtSignal()
18
19 def init (self , parent=None):
20 super(QWidget, self ). init (parent)
21
22 self .items = dict()
23
24 self . spacer = QSpacerItem(0, 0, QSizePolicy .Minimum, QSizePolicy .Expanding)
25 self . plot widget = self .parent() . plot widget
26
27 remove all = QPushButton()
28 remove all . setFlat(True)
29 remove all . setIcon(
30 QApplication. style () . standardIcon(QStyle.SP DialogResetButton))
31
32 hide all = QPushButton()
33 hide all . setFlat(True)
34 hide all . setIcon(QtGui.QIcon(os.path. join(images , "crossed .png")))
35
36 show all = QPushButton()
37 show all . setFlat(True)
38 show all . setIcon(QtGui.QIcon(os.path. join(images , "eye.png")))
39
40 header layout = QHBoxLayout()
41 header layout .addWidget(
42 InfoIcon("Here You will see all modeling seriesnn"
43 "You can hide them or delete , if you need to"))
44 header layout .addItem(
45 QSpacerItem(5, 0, QSizePolicy .Minimum, QSizePolicy .Minimum))
46 header layout .addWidget(QLabel("Curves"))
47 header layout .addItem(
48 QSpacerItem(5, 0, QSizePolicy .Minimum, QSizePolicy .Minimum))
49 header layout .setContentsMargins(0, 0, 0, 0)
50 header layout . setSpacing(0)
51 header layout .addItem(
52 QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
53 header layout .addWidget(show all)
54 header layout .addWidget( hide all )
55 header layout .addWidget(remove all)
56
57 self . layout = QVBoxLayout()
58 self . layout .setContentsMargins(3, 3, 3, 3)
59 self . layout . setSpacing(2)
60
61 scroll widget = QWidget( self )
62 scroll widget .setLayout( self . layout)
63
64 scroll area = QScrollArea( self )
65 scroll area . setWidgetResizable(True)
66 scroll area .setWidget(scroll widget)
67
68 self . layout .addItem( self . spacer)
69
Electronic Journal. http://diffjournal.spbu.ru/ 234Differential Equations and Control Processes, N. 1, 2021
70 layout = QVBoxLayout()
71 layout .setContentsMargins(0, 0, 0, 0)
72 layout .addLayout(header layout)
73 layout .addWidget( scroll area )
74
75 self .setLayout(layout)
76
77 self . setSizePolicy(
78 QSizePolicy(QSizePolicy .MinimumExpanding,
79 QSizePolicy .MinimumExpanding))
80
81 show all . clicked .connect( self . show all)
82 hide all . clicked .connect( self . hide all )
83 remove all . clicked .connect( self . delete all )
84
85 def new items(self , lines : list ):
86 self . layout .removeItem( self . spacer)
87
88 for i in range(len( lines )):
89 item widget = ItemWidget( lines [ i ].name, lines [ i ]. color , parent=self )
90 item widget .uid = lines [ i ]. uid
91 item widget .on show.connect( self . plot widget .show item)
92 item widget . on hide .connect( self . plot widget . hide item)
93 item widget . on delete .connect( self . plot widget . delete item)
94 item widget . on delete .connect( self . delete item)
95 self .items[ lines [ i ]. uid] = item widget
96
97 self . plot widget . hide label .connect(lambda uid: self .items[uid ]. hide())
98 self . plot widget . show label .connect(lambda uid: self .items[uid ].show())
99
100 self . layout .addWidget(item widget)
101
102 self . layout .addItem( self . spacer)
103
104 def delete item( self ):
105 s = self . sender()
106 s. setParent(None)
107 self .items.pop(s.uid)
108 self . layout .removeWidget(s)
109
110 def delete all ( self ):
111 for item in self .items. values() :
112 item. setParent(None)
113 self . layout .removeWidget(item)
114 self .items. clear ()
115 self . on remove all .emit()
116
117 def hide all ( self ):
118 for item in self .items. values() :
119 item.checkbox. blockSignals(True)
120 item.checkbox.setChecked(False)
121 item.checkbox. blockSignals(False)
122 self . on hide all .emit()
123
124 def show all( self ):
Electronic Journal. http://diffjournal.spbu.ru/ 235Differential Equations and Control Processes, N. 1, 2021
125 for item in self .items. values() :
126 item.checkbox. blockSignals(True)
127 item.checkbox.setChecked(True)
128 item.checkbox. blockSignals(False)
129 self . on show all .emit()
Listing 24: Curves list item
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QPushButton, QSizePolicy , QHBoxLayout, QStyle , n
3 QApplication , QCheckBox, QVBoxLayout, QLabel, QSpacerItem , QFrame
4
5
6 class ItemWidget(QFrame):
7
8 on delete = pyqtSignal(object)
9 on hide = pyqtSignal(int)
10 on show = pyqtSignal(int)
11
12 def init (self , name, color , parent=None):
13 super(QFrame, self ). init (parent)
14
15 self .uid = 0
16
17 self .setFrameShape(QFrame. StyledPanel)
18 self . setStyleSheet("QFrame f background: white; g")
19
20 self .checkbox = QCheckBox(name)
21 self .checkbox.setChecked(True)
22
23 btn = QPushButton()
24 btn. setFlat(True)
25 btn. setIcon(QApplication. style () . standardIcon(QStyle.SP DialogCancelButton))
26
27 underline = QLabel()
28 underline . setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Maximum))
29 underline .setMaximumHeight(3)
30 underline . setStyleSheet(f"QLabel ff background: fcolorg; gg")
31
32 layout = QHBoxLayout()
33 layout .setContentsMargins(3, 3, 3, 3)
34 layout . setSpacing(0)
35 layout .addWidget( self .checkbox)
36 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
37 layout .addWidget(btn)
38
39 layout underlined = QVBoxLayout()
40 layout underlined .setContentsMargins(0, 0, 0, 0)
41 layout underlined . setSpacing(0)
42 layout underlined .addLayout(layout)
43 layout underlined .addWidget(underline)
44
45 self .setLayout(layout underlined)
Electronic Journal. http://diffjournal.spbu.ru/ 236Differential Equations and Control Processes, N. 1, 2021
46
47 self .checkbox.stateChanged.connect( self .checkbox changed)
48 btn. clicked .connect(lambda: self . on delete .emit( self .uid))
49
50 def checkbox changed(self , v):
51 if v > 0:
52 self .on show.emit( self .uid)
53 else :
54 self . on hide .emit( self .uid)
Listing 25: Charts area
1 import matplotlib . pyplot as plt
2 from PyQt5.QtCore import pyqtSignal
3 from PyQt5.QtWidgets import QSizePolicy , QFrame, QHBoxLayout, QPushButton, n
4 QSpacerItem
5 from PyQt5.QtWidgets import QVBoxLayout
6 from matplotlib .backends.backend qt5agg import FigureCanvasQTAgg as FigureCanvas
7
8 from ui . charts . visuals . color import Color
9 from ui . charts . visuals . toolbar import ToolBar
10 from ui .main. info import InfoIcon
11
12
13 class ChartsWidget(QFrame):
14
15 hide label = pyqtSignal(int)
16 show label = pyqtSignal(int)
17
18 def init (self , parent=None):
19 super(QFrame, self ). init (parent)
20
21 self . plots = dict()
22 self .mode = 0
23
24 self .setFrameStyle(QFrame. StyledPanel)
25 self . setStyleSheet("QFrame f background: white; g")
26
27 self . figure = plt . figure ()
28 self .canvas = FigureCanvas( self . figure)
29 self .canvas.mpl connect( 'resize event ' , self . on resize)
30 self . toolbar = ToolBar( self .canvas , self )
31
32 self .ax = self . figure . add subplot(111)
33 self .ax.margins(0)
34 self .ax. grid(axis='both ' , alpha=.3)
35 self .ax. relim( visible only=True)
36 self .ax. autoscale ()
37
38 self . figure . tight layout ()
39 self .canvas.draw()
40
41 self . btn to fn = QPushButton("Trajectories")
Electronic Journal. http://diffjournal.spbu.ru/ 237Differential Equations and Control Processes, N. 1, 2021
42 self . btn to fn . setFlat(True)
43 self .btn to mx = QPushButton("Expectations")
44 self .btn to mx. setFlat(True)
45 self . btn to dx = QPushButton("Variances")
46 self . btn to dx . setFlat(True)
47
48 toolbar layout = QHBoxLayout()
49 toolbar layout .setContentsMargins(0, 0, 0, 0)
50 toolbar layout . setSpacing(0)
51 toolbar layout .addItem(QSpacerItem(15, 0, QSizePolicy .Minimum, QSizePolicy .Minimum))
52 toolbar layout .addWidget(InfoIcon("Click this buttons to switch plot modesnn"
53 "between trajectories , expectations and variances"))
54 toolbar layout .addItem(QSpacerItem(15, 0, QSizePolicy .Minimum, QSizePolicy .Minimum))
55 toolbar layout .addWidget( self . btn to fn)
56 toolbar layout .addWidget( self .btn to mx)
57 toolbar layout .addWidget( self . btn to dx)
58 toolbar layout .addWidget( self . toolbar)
59 toolbar layout .addItem(QSpacerItem(15, 0, QSizePolicy .Minimum, QSizePolicy .Minimum))
60
61 layout = QVBoxLayout()
62 layout .setContentsMargins(0, 0, 0, 0)
63 layout . setSpacing(0)
64 layout .addLayout(toolbar layout)
65 layout .addWidget( self .canvas)
66
67 self .setLayout(layout)
68
69 self . setSizePolicy(QSizePolicy(QSizePolicy .Expanding , QSizePolicy .Expanding))
70
71 self . btn to fn . pressed .connect( self .fn mode)
72 self .btn to mx. pressed .connect( self .mx mode)
73 self . btn to dx . pressed .connect( self .dx mode)
74
75 def rescale( self ):
76 self .ax. relim( visible only=True)
77 self .ax. autoscale ()
78 self .canvas.draw()
79
80 def clear( self ):
81 for f in self . plots . values() :
82 self . hide label .emit(f .uid)
83 if f . line fn is not None:
84 f . line fn . set visible (False)
85 if f . line mx is not None:
86 f . line mx . set visible (False)
87 if f . line dx is not None:
88 f . line dx . set visible (False)
89
90 def fn mode( self ):
91
92 self .mode = 0
93
94 self . clear ()
95
96 for f in self . plots . values() :
Electronic Journal. http://diffjournal.spbu.ru/ 238Differential Equations and Control Processes, N. 1, 2021
97 if f . line fn is not None:
98 self . show label .emit(f .uid)
99 if f . visible :
100 f . line fn . set visible (True)
101
102 self . rescale ()
103
104 def mx mode( self ):
105
106 self .mode = 1
107
108 self . clear ()
109
110 for f in self . plots . values() :
111 if f . line mx is not None:
112 self . show label .emit(f .uid)
113 if f . visible :
114 f . line mx . set visible (True)
115
116 self . rescale ()
117
118 def dx mode( self ):
119
120 self .mode = 2
121
122 self . clear ()
123
124 for f in self . plots . values() :
125 if f . line dx is not None:
126 self . show label .emit(f .uid)
127 if f . visible :
128 f . line dx . set visible (True)
129
130 self . rescale ()
131
132 def new items(self , lines : list ):
133
134 for line in lines :
135 self . plots [ line .uid] = line
136
137 for f in self . plots . values() :
138 if f . line fn is None and f . fn is not None:
139 f . line fn = self .ax. plot(f .t , f .fn , linewidth=1, color=f . color) [0]
140 if f . line mx is None and f .mx is not None:
141 f . line mx = self .ax. plot(f .t , f .mx, linewidth=1, color=f . color) [0]
142 if f . line dx is None and f .dx is not None:
143 f . line dx = self .ax. plot(f .t , f .dx, linewidth=1, color=f . color) [0]
144
145 if self .mode == 0:
146 self .fn mode()
147
148 if self .mode == 1:
149 self .mx mode()
150
151 if self .mode == 2:
Electronic Journal. http://diffjournal.spbu.ru/ 239Differential Equations and Control Processes, N. 1, 2021
152 self .dx mode()
153
154 def delete item(self , uid: int):
155 item = self . plots .pop(uid)
156 Color. free(item. color)
157 if item. line fn is not None:
158 item. line fn .remove()
159 if item. line mx is not None:
160 item. line mx .remove()
161 if item. line dx is not None:
162 item. line dx .remove()
163
164 self . rescale ()
165
166 def hide item(self , uid: int):
167 item = self . plots [uid]
168 if item. line fn is not None and self .mode == 0:
169 item. line fn . set visible (False)
170 if item. line mx is not None and self .mode == 1:
171 item. line mx . set visible (False)
172 if item. line dx is not None and self .mode == 2:
173 item. line dx . set visible (False)
174 item. visible = False
175
176 self . rescale ()
177
178 def show item(self , uid: int):
179 item = self . plots [uid]
180 if item. line fn is not None and self .mode == 0:
181 item. line fn . set visible (True)
182 if item. line mx is not None and self .mode == 1:
183 item. line mx . set visible (True)
184 if item. line dx is not None and self .mode == 2:
185 item. line dx . set visible (True)
186 item. visible = True
187
188 self . rescale ()
189
190 def show all( self ):
191 for item in self . plots . values() :
192 if item. line fn is not None and self .mode == 0:
193 item. line fn . set visible (True)
194 if item. line mx is not None and self .mode == 1:
195 item. line mx . set visible (True)
196 if item. line dx is not None and self .mode == 2:
197 item. line dx . set visible (True)
198 item. visible = True
199
200 self . rescale ()
201
202 def hide all ( self ):
203 for item in self . plots . values() :
204 if item. line fn is not None and self .mode == 0:
205 item. line fn . set visible (False)
206 if item. line mx is not None and self .mode == 1:
Electronic Journal. http://diffjournal.spbu.ru/ 240Differential Equations and Control Processes, N. 1, 2021
207 item. line mx . set visible (False)
208 if item. line dx is not None and self .mode == 2:
209 item. line dx . set visible (False)
210 item. visible = False
211
212 self . rescale ()
213
214 def delete all ( self ):
215 for item in reversed( self . plots . values()):
216 Color. free(item. color)
217 if item. line fn is not None:
218 item. line fn .remove()
219 if item. line mx is not None:
220 item. line mx .remove()
221 if item. line dx is not None:
222 item. line dx .remove()
223
224 self . plots . clear ()
225
226 self . rescale ()
227
228 def on resize(self , event):
229 self . figure . tight layout ()
230 self .canvas.draw()
Listing 26: Curves color
1 from random import choice
2
3
4 class Color:
5
6 reserved colors = [
7 "#ff834a",
8 "#ffe100",
9 "#c700c7",
10 "#24e280",
11 "#1100ff",
12 "#ff1e22",
13 ]
14 available colors = [
15 "#ff834a",
16 "#ffe100",
17 "#c700c7",
18 "#24e280",
19 "#1100ff",
20 "#ff1e22",
21 ]
22
23 def new (cls , ∗args , ∗∗kwargs):
24
25 try:
26 return cls . available colors .pop()
Electronic Journal. http://diffjournal.spbu.ru/ 241Differential Equations and Control Processes, N. 1, 2021
27
28 except IndexError:
29 return f"#f''.join ([ choice('0123456789ABCDEF') for j in range(6) ])g"
30
31 @classmethod
32 def free(cls , code: str):
33
34 if code in cls . reserved colors :
35 cls . available colors .append(code)
Listing 27: Curve
1 from ui . charts . visuals . color import Color
2
3
4 class Line:
5 count = 0
6
7 def init (self , name, t , fn , mx=None, dx=None):
8 self .name = name
9 self .t = t
10 self . fn = fn
11 self .mx = mx
12 self .dx = dx
13 self . line fn = None
14 self . line mx = None
15 self . line dx = None
16 self . visible = True
17 self . color = Color()
18
19 self .uid = Line.count
20 Line.count += 1
6.1.3 Source Codes of Input for Nonlinear Systems of It^ o SDEs
Listing 28: Base part of data input for nonlinear systems
1 import logging
2
3 import numpy as np
4 from PyQt5.QtCore import QThreadPool, pyqtSignal
5 from PyQt5.QtWidgets import QCheckBox, QPushButton, QStyle , QApplication ,n
6 QSizePolicy , QHBoxLayout, QSpacerItem , QVBoxLayout, QStackedWidget , n
7 QWidget, QLabel
8 from sympy import Matrix
9
10 import config
11 from mathematics.sde. nonlinear . drivers . euler import euler
12 from mathematics.sde. nonlinear . drivers . milstein import milstein
13 from mathematics.sde. nonlinear . drivers . strong taylor ito 1p5 import strong taylor ito 1p5
Electronic Journal. http://diffjournal.spbu.ru/ 242Differential Equations and Control Processes, N. 1, 2021
14 from mathematics.sde. nonlinear . drivers . strong taylor ito 2p0 import strong taylor ito 2p0
15 from mathematics.sde. nonlinear . drivers . strong taylor ito 2p5 import strong taylor ito 2p5
16 from mathematics.sde. nonlinear . drivers . strong taylor ito 3p0 import strong taylor ito 3p0
17 from mathematics.sde. nonlinear . drivers . strong taylor stratonovich 1p0 import
strong taylor stratonovich 1p0
18 from mathematics.sde. nonlinear . drivers . strong taylor stratonovich 1p5 import
strong taylor stratonovich 1p5
19 from mathematics.sde. nonlinear . drivers . strong taylor stratonovich 2p0 import
strong taylor stratonovich 2p0
20 from mathematics.sde. nonlinear . drivers . strong taylor stratonovich 2p5 import
strong taylor stratonovich 2p5
21 from mathematics.sde. nonlinear . drivers . strong taylor stratonovich 3p0 import
strong taylor stratonovich 3p0
22 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
23 from tools import database
24 from ui . async calls .worker import Worker
25 from ui . charts . visuals . line import Line
26 from ui .main.modeling. nonliear . step1 import Step1
27 from ui .main.modeling. nonliear . step2 import Step2
28 from ui .main.modeling. nonliear . step3 import Step3
29 from ui .main.modeling. nonliear . step4 import Step4
30 from ui .main.modeling. nonliear . step5 import Step5
31
32
33 class NonlinearModelingWidget(QWidget):
34
35 show main menu = pyqtSignal()
36 start progress = pyqtSignal(str)
37 stop progress = pyqtSignal(str)
38 draw chart = pyqtSignal(list )
39
40 def init (self , parent=None):
41 super(QWidget, self ). init (parent)
42
43 self . logger = logging .getLogger( name )
44 self .scheme id = 0
45 self .schemes = [
46 (euler , "Euler", "Euler Scheme") ,
47 (milstein , "Milstein", "Milstein Scheme") ,
48 (strong taylor ito 1p5 , "Taylor−Ito 1.5",
49 "Strong Taylor−Ito Scheme with Convergence Order 1.5") ,
50 (strong taylor ito 2p0 , "Taylor−Ito 2.0",
51 "Strong Taylor−Ito Scheme with Convergence Order 2.0") ,
52 (strong taylor ito 2p5 , "Taylor−Ito 2.5",
53 "Strong Taylor−Ito Scheme with Convergence Order 2.5") ,
54 (strong taylor ito 3p0 , "Taylor−Ito 3.0",
55 "Strong Taylor−Ito Scheme with Convergence Order 3.0") ,
56 (strong taylor stratonovich 1p0 , "Taylor−Str . 1.0",
57 "Strong Taylor−Stratonovich Scheme with Convergence Order 1.0") ,
58 (strong taylor stratonovich 1p5 , "Taylor−Str . 1.5",
59 "Strong Taylor−Stratonovich Scheme with Convergence Order 1.5") ,
60 (strong taylor stratonovich 2p0 , "Taylor−Str . 2.0",
61 "Strong Taylor−Stratonovich Scheme with Convergence Order 2.0") ,
62 (strong taylor stratonovich 2p5 , "Taylor−Str . 2.5",
63 "Strong Taylor−Stratonovich Scheme with Convergence Order 2.5") ,
Electronic Journal. http://diffjournal.spbu.ru/ 243Differential Equations and Control Processes, N. 1, 2021
64 (strong taylor stratonovich 3p0 , "Taylor−Str . 3.0",
65 "Strong Taylor−Stratonovich Scheme with Convergence Order 3.0") ,
66 ]
67
68 self . stack widget = QStackedWidget( self )
69
70 self . step1 = Step1()
71 self . step2 = Step2()
72 self . step3 = Step3()
73 self . step4 = Step4()
74 self . step5 = Step5()
75
76 back btn = QPushButton("Back", self )
77 back btn. setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
78
79 self . charts check = QCheckBox("Charts window", self )
80
81 self .scheme name = QLabel()
82 self .scheme name. setSizePolicy(QSizePolicy .Expanding , QSizePolicy .Minimum)
83
84 bar layout = QHBoxLayout()
85 bar layout .addWidget(back btn)
86 bar layout .addItem(QSpacerItem(10, 35, QSizePolicy .Minimum, QSizePolicy .Minimum))
87 bar layout .addWidget( self .scheme name)
88 bar layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
89 bar layout .addWidget( self . charts check)
90
91 self . stack widget .addWidget( self . step1)
92 self . stack widget .addWidget( self . step2)
93 self . stack widget .addWidget( self . step3)
94 self . stack widget .addWidget( self . step4)
95 self . stack widget .addWidget( self . step5)
96
97 layout = QVBoxLayout()
98 layout .addLayout(bar layout)
99 layout .addWidget( self . stack widget)
100
101 self .setLayout(layout)
102
103 back btn. clicked .connect( self .show main menu.emit)
104 back btn. clicked .connect(
105 lambda: self . stack widget .setCurrentWidget( self . step1))
106
107 self . step1 . next btn . clicked .connect(
108 lambda: self . stack widget .setCurrentWidget( self . step2))
109 self . step2 . prev btn . clicked .connect(
110 lambda: self . stack widget .setCurrentWidget( self . step1))
111 self . step2 . next btn . clicked .connect(
112 lambda: self . stack widget .setCurrentWidget( self . step3))
113 self . step3 . prev btn . clicked .connect(
114 lambda: self . stack widget .setCurrentWidget( self . step2))
115 self . step3 . next btn . clicked .connect(
116 lambda: self . stack widget .setCurrentWidget( self . step4))
117 self . step4 . prev btn . clicked .connect(
118 lambda: self . stack widget .setCurrentWidget( self . step3))
Electronic Journal. http://diffjournal.spbu.ru/ 244Differential Equations and Control Processes, N. 1, 2021
119 self . step4 . next btn . clicked .connect(
120 lambda: self . stack widget .setCurrentWidget( self . step5))
121 self . step5 . prev btn . clicked .connect(
122 lambda: self . stack widget .setCurrentWidget( self . step4))
123
124 self . step5 .run btn. clicked .connect(
125 lambda: self .run modeling())
126 self . step5 .run btn. clicked .connect(
127 lambda: self . stack widget .setCurrentWidget( self . step1))
128
129 self . step1 . n valid .connect( self . step2 .matrix. resize h)
130 self . step1 . n valid .connect( self . step3 .matrix. resize h)
131 self . step1 . n valid .connect( self . step4 .matrix. resize h)
132
133 self . step1 .m valid.connect( self . step3 .matrix. resize w)
134
135 def set scheme(self , scheme id):
136 self .scheme id = scheme id
137 self .scheme name.setText( self .schemes[scheme id ][2])
138 if scheme id == 0:
139 self . step5 . count c(False)
140 else :
141 self . step5 . count c(True)
142
143 def run modeling( self ):
144 self . start progress .emit("The modeling is being performed ... ")
145
146 worker = Worker( self . routine)
147 worker. signals . result .connect( self . on modeling finish)
148 worker. signals . error .connect( self . on modeling corrupted)
149 QThreadPool. globalInstance () . start(worker)
150
151 def routine( self ):
152
153 scheme = self .schemes[ self .scheme id]
154
155 a = Matrix( self . step2 .matrix.m)
156 b = Matrix( self . step3 .matrix.m)
157
158 x0 = np.ndarray(shape=(self . step4 .matrix.rowCount() ,
159 self . step4 .matrix.columnCount()) , dtype=float)
160 for i in range( self . step4 .matrix.rowCount()):
161 for j in range( self . step4 .matrix.columnCount()):
162 x0[ i ][ j ] = float( self . step4 .matrix.m[ i ][ j ])
163
164 if self . step5 .s != 0:
165 np.random. seed( self . step5 .s)
166
167 database.connect(config .database)
168
169 if self .scheme id == 0:
170 result = scheme[0](
171 x0, a, b,
172 ( self . step5 .t0 ,
173 self . step5 .dt ,
Electronic Journal. http://diffjournal.spbu.ru/ 245Differential Equations and Control Processes, N. 1, 2021
174 self . step5 .t1)
175 )
176 else :
177 C. preload(56, 56, 56, 56, 56)
178 result = scheme[0](
179 x0, a, b, self . step5 .c,
180 ( self . step5 .t0 ,
181 self . step5 .dt ,
182 self . step5 .t1)
183 )
184
185 database. disconnect()
186
187 lines = [Line(f"fscheme[1]g , xfi + 1g",
188 np. array(result [1]) . astype(float) ,
189 np. array(result [0][ i , :]) . astype(float))
190 for i in range(len(result [0]) )]
191
192 return lines
193
194 def on modeling finish(self , result):
195 self . stop progress .emit("The modeling has been completed!")
196 self .draw chart.emit(result)
197
198 def on modeling corrupted(self , result):
199
200 self . logger . error(result [0])
201 self . logger . error(result [1])
202 self . logger . error(result [2])
203
204 self . stop progress .emit("The modeling failed !")
Listing 29: Step 1 of data input for nonlinear systems
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QGridLayout, QLineEdit , QLabel, n
3 QVBoxLayout, QSpacerItem , QSizePolicy , QPushButton, QApplication , QStyle
4
5 from ui .main. error import ErrorWidget
6 from ui .main. info import InfoIcon
7 from ui .main.svg import SVG
8
9
10 class Step1(QWidget):
11
12 n valid = pyqtSignal(int)
13 m valid = pyqtSignal(int)
14
15 def init (self , parent=None):
16 super(QWidget, self ). init (parent)
17
18 self . n is valid = False
19 self . m is valid = False
Electronic Journal. http://diffjournal.spbu.ru/ 246Differential Equations and Control Processes, N. 1, 2021
20
21 self . input stack = self .parent()
22
23 info n = InfoIcon("Dimension of linear system of Ito SDEs")
24 info m = InfoIcon("Dimension of vector Wiener process")
25
26 label n = QLabel("n")
27 label m = QLabel("m")
28
29 self . lineedit n = QLineEdit()
30 self . lineedit m = QLineEdit()
31
32 self .msg n = ErrorWidget("Wrong value !")
33 self .msg n. hide()
34
35 self .msg m = ErrorWidget("Wrong value !")
36 self .msg m. hide()
37
38 grid layout = QGridLayout()
39 grid layout .addWidget( self .msg n, 0, 2)
40 grid layout .addWidget( self .msg m, 2, 2)
41 grid layout .addWidget(info n , 1, 0)
42 grid layout .addWidget(info m , 3, 0)
43 grid layout .addWidget(label n , 1, 1)
44 grid layout .addWidget(label m , 3, 1)
45 grid layout .addWidget( self . lineedit n , 1, 2)
46 grid layout .addWidget( self . lineedit m , 3, 2)
47
48 header = QLabel("Dimensions settings", parent=self )
49 font = header. font()
50 font . setPointSize(15)
51 header.setFont(font)
52
53 self . next btn = QPushButton("Next", self )
54 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
55 self . next btn .setEnabled(False)
56
57 header layout = QHBoxLayout()
58 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
59 header layout .addWidget(header)
60 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
61
62 bottom bar = QHBoxLayout()
63 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
64 bottom bar.addWidget( self . next btn)
65
66 eq1 = QHBoxLayout()
67 eq1.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
68 eq1.addWidget(SVG("equation1 .svg", scale factor=1.))
69 eq1.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
70
71 eq2 = QHBoxLayout()
72 eq2.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
73 eq2.addWidget(SVG("equation2 .svg", scale factor=1.))
74 eq2.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
Electronic Journal. http://diffjournal.spbu.ru/ 247Differential Equations and Control Processes, N. 1, 2021
75
76 equalities layout = QVBoxLayout()
77 equalities layout .addLayout(eq1)
78 equalities layout .addItem(QSpacerItem(0, 20, QSizePolicy .Minimum, QSizePolicy .Minimum
))
79 equalities layout .addLayout(eq2)
80
81 equalities wrap = QHBoxLayout()
82 equalities wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum)
)
83 equalities wrap .addLayout(equalities layout)
84 equalities wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum)
)
85
86 grid wrap = QHBoxLayout()
87 grid wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
88 grid wrap .addLayout(grid layout)
89 grid wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
90
91 layout = QVBoxLayout()
92 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Minimum, QSizePolicy .Expanding))
93 layout .addLayout(equalities wrap)
94 layout .addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum))
95 layout .addLayout(header layout)
96 layout .addItem(QSpacerItem(0, 5, QSizePolicy .Minimum, QSizePolicy .Minimum))
97 layout .addLayout(grid wrap)
98 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Minimum, QSizePolicy .Expanding))
99 layout .addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum))
100 layout .addLayout(bottom bar)
101
102 self .setLayout(layout)
103
104 self . lineedit n .textChanged.connect( self . validate n)
105 self . lineedit m .textChanged.connect( self . validate m)
106
107 def validate form( self ):
108 if self . n is valid and self . m is valid :
109 self . next btn .setEnabled(True)
110 else :
111 self . next btn .setEnabled(False)
112
113 def validate n(self , value):
114 try:
115 typed value = int(value)
116 if typed value <= 0:
117 raise ValueError()
118
119 self . n is valid = True
120 self . n valid .emit(typed value)
121 self .msg n. hide()
122
123 except ValueError:
124 self . n is valid = False
125 self .msg n.show()
126
Electronic Journal. http://diffjournal.spbu.ru/ 248Differential Equations and Control Processes, N. 1, 2021
127 finally :
128 self . validate form ()
129
130 def validate m(self , value):
131 try:
132 typed value = int(value)
133 if typed value <= 0:
134 raise ValueError()
135
136 self . m is valid = True
137 self .m valid.emit(typed value)
138 self .msg m. hide()
139
140 except ValueError:
141 self . m is valid = False
142 self .msg m.show()
143
144 finally :
145 self . validate form ()
Listing 30: Step 2 of data input for nonlinear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QSpacerItem , QSizePolicy , n
2 QVBoxLayout, QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step2(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of column a(x, t)", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of column a(x, t) are expected to be functionsnn"
22 "Size : n x 1nn"
23 "Functions must be set in python and SymPy notation")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
Electronic Journal. http://diffjournal.spbu.ru/ 249Differential Equations and Control Processes, N. 1, 2021
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
Listing 31: Step 3 of data input for nonlinear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QSpacerItem , QSizePolicy , n
2 QVBoxLayout, QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step3(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of matrix B(x, t)", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of matrix B(x, t) are expected to be functionsnn"
22 "Size : n x mnn"
23 "Functions must be set in python and SymPy notation")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
Electronic Journal. http://diffjournal.spbu.ru/ 250Differential Equations and Control Processes, N. 1, 2021
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
Listing 32: Step 4 of data input for nonlinear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QLabel, n
2 QSpacerItem , QSizePolicy , QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step4(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of column x0", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of column x0 are expected to be functionsnn"
22 "Size : n x 1nn"
23 "Functions must be set in python and SymPy notation")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
Electronic Journal. http://diffjournal.spbu.ru/ 251Differential Equations and Control Processes, N. 1, 2021
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
Listing 33: Step 5 of data input for nonlinear systems
1 import sys
2
3 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QLineEdit , n
4 QGridLayout, QVBoxLayout, QSizePolicy , QSpacerItem , QPushButton, n
5 QApplication , QStyle
6
7 from ui .main. error import ErrorWidget
8 from ui .main. info import InfoIcon
9
10
11 class Step5(QWidget):
12
13 def init (self , parent=None):
14 super(QWidget, self ). init (parent)
15
16 self .t0 = sys . float info .min
17 self .dt = 0
18 self .t1 = sys . float info .max
19 self .s = 0
20 self .c = 0
21
22 self . t0 is valid = False
23 self . dt is valid = False
24 self . t1 is valid = False
25 self . s is valid = True
Electronic Journal. http://diffjournal.spbu.ru/ 252Differential Equations and Control Processes, N. 1, 2021
26 self . c is valid = False
27
28 self . input stack = self .parent()
29
30 info t0 = InfoIcon("Start point of integration intervalnn"
31 "Must be in [0 , t1) range")
32 info dt = InfoIcon("Integration stepnn"
33 "Must be set in (0, 1) interval")
34 info t1 = InfoIcon("Final point of integration intervalnn"
35 "Must be more then t0")
36 info s = InfoIcon("This is random generator seednn"
37 "If You do not want to use specificnn"
38 "seed just leave this field empty")
39 self . info c = InfoIcon("The constant which defines approximation accuracy")
40
41 label t0 = QLabel("t0")
42 label dt = QLabel("dt")
43 label t1 = QLabel("t1")
44 label s = QLabel("seed")
45 self . label c = QLabel("C")
46
47 self . lineedit t0 = QLineEdit()
48 self . lineedit dt = QLineEdit()
49 self . lineedit t1 = QLineEdit()
50 self . lineedit s = QLineEdit()
51 self . lineedit c = QLineEdit()
52
53 self .msg t0 = ErrorWidget("Wrong value !")
54 self .msg t0. hide()
55
56 self .msg dt = ErrorWidget("Wrong value !")
57 self .msg dt. hide()
58
59 self .msg t1 = ErrorWidget("Wrong value !")
60 self .msg t1. hide()
61
62 self .msg s = ErrorWidget("Wrong value !")
63 self .msg s. hide()
64
65 self .msg c = ErrorWidget("Wrong value !")
66 self .msg c. hide()
67
68 header = QLabel("Accuracy settings", parent=self )
69 font = header. font()
70 font . setPointSize(15)
71 header.setFont(font)
72
73 self . prev btn = QPushButton("Back", self )
74 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
75
76 self .run btn = QPushButton("Perform modeling", self )
77 self .run btn. setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
78 self .run btn.setEnabled(False)
79
80 header layout = QHBoxLayout()
Electronic Journal. http://diffjournal.spbu.ru/ 253Differential Equations and Control Processes, N. 1, 2021
81 header layout .addWidget(header)
82 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
83
84 bottom bar = QHBoxLayout()
85 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
86 bottom bar.addWidget( self . prev btn)
87 bottom bar.addWidget( self .run btn)
88
89 grid layout = QGridLayout()
90
91 grid layout .addWidget( self .msg t0 , 0, 2)
92
93 grid layout .addWidget(info t0 , 1, 0)
94 grid layout .addWidget(label t0 , 1, 1)
95 grid layout .addWidget( self . lineedit t0 , 1, 2)
96
97 grid layout .addWidget( self .msg dt , 0, 5)
98
99 grid layout .addWidget(info dt , 1, 3)
100 grid layout .addWidget(label dt , 1, 4)
101 grid layout .addWidget( self . lineedit dt , 1, 5)
102
103 grid layout .addWidget( self .msg t1 , 0, 8)
104
105 grid layout .addWidget(info t1 , 1, 6)
106 grid layout .addWidget(label t1 , 1, 7)
107 grid layout .addWidget( self . lineedit t1 , 1, 8)
108
109 grid layout .addWidget( self .msg s , 2, 2)
110
111 grid layout .addWidget(info s , 3, 0)
112 grid layout .addWidget(label s , 3, 1)
113 grid layout .addWidget( self . lineedit s , 3, 2)
114
115 grid layout .addWidget( self .msg c , 2, 5)
116
117 grid layout .addWidget( self . info c , 3, 3)
118 grid layout .addWidget( self . label c , 3, 4)
119 grid layout .addWidget( self . lineedit c , 3, 5)
120
121 column layout = QVBoxLayout()
122 column layout.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding)
)
123 column layout.addLayout(header layout)
124 column layout.addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum))
125 column layout.addLayout(grid layout)
126 column layout.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding)
)
127
128 control layout = QHBoxLayout()
129 control layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding
))
130 control layout .addLayout(column layout)
131 control layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding
))
Electronic Journal. http://diffjournal.spbu.ru/ 254Differential Equations and Control Processes, N. 1, 2021
132
133 layout = QVBoxLayout()
134 layout .addLayout(control layout)
135 layout .addLayout(bottom bar)
136
137 self .setLayout(layout)
138
139 self . lineedit t0 .textChanged.connect( self . validate t0)
140 self . lineedit t0 .textChanged.connect( self . validate t1)
141 self . lineedit t0 .textChanged.connect( self . validate dt)
142 self . lineedit dt .textChanged.connect( self . validate dt)
143 self . lineedit t1 .textChanged.connect( self . validate t0)
144 self . lineedit t1 .textChanged.connect( self . validate t1)
145 self . lineedit t1 .textChanged.connect( self . validate dt)
146 self . lineedit s .textChanged.connect( self . validate s)
147 self . lineedit c .textChanged.connect( self . validate c)
148
149 def count c(self , flag : bool):
150 if flag :
151 self . info c .show()
152 self . label c .show()
153 self . lineedit c .show()
154 self . validate c ()
155 else :
156 self . info c . hide()
157 self . label c . hide()
158 self . lineedit c . hide()
159 self . c is valid = True
160
161 self .msg c. hide()
162
163 def validate form( self ):
164 if self . t0 is valid n
165 and self . dt is valid n
166 and self . t1 is valid n
167 and self . s is valid n
168 and self . c is valid :
169 self .run btn.setEnabled(True)
170 else :
171 self .run btn.setEnabled(False)
172
173 def validate t0( self ):
174 try:
175 typed value = float( self . lineedit t0 . text())
176 if typed value >= self .t1:
177 raise ValueError()
178
179 self . t0 is valid = True
180 self .t0 = typed value
181 self .msg t0. hide()
182
183 except ValueError:
184 self . t0 is valid = False
185 self .msg t0.show()
186
Electronic Journal. http://diffjournal.spbu.ru/ 255Differential Equations and Control Processes, N. 1, 2021
187 def validate dt( self ):
188 try:
189 typed value = float( self . lineedit dt . text())
190 if typed value <= 0 n
191 or ( self .t1 − self .t0) / typed value < 1 n
192 or typed value >= 1:
193 raise ValueError()
194
195 self . dt is valid = True
196 self .dt = typed value
197 self .msg dt. hide()
198 self . validate form ()
199
200 except ValueError:
201 self . dt is valid = False
202 self .msg dt.show()
203
204 def validate t1( self ):
205 try:
206 typed value = float( self . lineedit t1 . text())
207 if typed value <= self .t0:
208 raise ValueError()
209
210 self . t1 is valid = True
211 self .t1 = typed value
212 self .msg t1. hide()
213
214 except ValueError:
215 self . t1 is valid = False
216 self .msg t1.show()
217
218 def validate s( self ):
219 try:
220 if self . lineedit s . text() == "":
221 self . s is valid = True
222 self .s = 0
223 else :
224 typed value = int( self . lineedit s . text())
225 if typed value <= 0:
226 raise ValueError()
227 self .s = typed value
228
229 self . s is valid = True
230 self .msg s. hide()
231
232 except ValueError:
233 self . s is valid = False
234 self .msg s.show()
235
236 finally :
237 self . validate form ()
238
239 def validate c( self ):
240 try:
241 typed value = float( self . lineedit c . text())
Electronic Journal. http://diffjournal.spbu.ru/ 256Differential Equations and Control Processes, N. 1, 2021
242 if typed value <= 0:
243 raise ValueError()
244
245 self . c is valid = True
246 self .c = typed value
247 self .msg c. hide()
248
249 except ValueError:
250 self . c is valid = False
251 self .msg c.show()
252
253 finally :
254 self . validate form ()
6.1.4 Source Codes of Input for Linear Systems of It^ o SDEs
Listing 34: Base part of data input for linear systems
1 import logging
2 from time import time
3
4 import numpy as np
5 from PyQt5.QtCore import QThreadPool, pyqtSignal
6 from PyQt5.QtWidgets import QCheckBox, QPushButton, QStyle , QApplication , n
7 QSizePolicy , QHBoxLayout, QSpacerItem , QVBoxLayout, QStackedWidget , n
8 QWidget, QLabel
9
10 from mathematics.sde. linear . dindet import dindet
11 from mathematics.sde. linear . distortions import Symbolic , ComplexDistortion
12 from mathematics.sde. linear . integration import Integral
13 from mathematics.sde. linear . stoch import stoch
14 from ui . async calls .worker import Worker
15 from ui . charts . visuals . line import Line
16 from ui .main.modeling. linear . step1 import Step1
17 from ui .main.modeling. linear . step2 import Step2
18 from ui .main.modeling. linear . step3 import Step3
19 from ui .main.modeling. linear . step4 import Step4
20 from ui .main.modeling. linear . step5 import Step5
21 from ui .main.modeling. linear . step6 import Step6
22 from ui .main.modeling. linear . step7 import Step7
23 from ui .main.modeling. linear . step8 import Step8
24
25
26 class LinearModelingWidget(QWidget):
27
28 show main menu = pyqtSignal()
29 start progress = pyqtSignal(str)
30 stop progress = pyqtSignal(str)
31 draw chart = pyqtSignal(list )
32
33 def init (self , parent=None):
Electronic Journal. http://diffjournal.spbu.ru/ 257Differential Equations and Control Processes, N. 1, 2021
34 super(QWidget, self ). init (parent)
35
36 self . logger = logging .getLogger( name )
37
38 self . stack widget = QStackedWidget( self )
39
40 self . step1 = Step1()
41 self . step2 = Step2()
42 self . step3 = Step3()
43 self . step4 = Step4()
44 self . step5 = Step5()
45 self . step6 = Step6()
46 self . step7 = Step7()
47 self . step8 = Step8()
48
49 back btn = QPushButton("Back", self )
50 back btn. setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
51
52 self . charts check = QCheckBox("Charts window", self )
53
54 self .scheme name = QLabel("Linear Systems of Ito SDEs")
55
56 bar layout = QHBoxLayout()
57 bar layout .addWidget(back btn)
58 bar layout .addItem(QSpacerItem(10, 35, QSizePolicy .Minimum, QSizePolicy .Minimum))
59 bar layout .addWidget( self .scheme name)
60 bar layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
61 bar layout .addWidget( self . charts check)
62
63 self . stack widget .addWidget( self . step1)
64 self . stack widget .addWidget( self . step2)
65 self . stack widget .addWidget( self . step3)
66 self . stack widget .addWidget( self . step4)
67 self . stack widget .addWidget( self . step5)
68 self . stack widget .addWidget( self . step6)
69 self . stack widget .addWidget( self . step7)
70 self . stack widget .addWidget( self . step8)
71
72 layout = QVBoxLayout()
73 layout .addLayout(bar layout)
74 layout .addWidget( self . stack widget)
75
76 self .setLayout(layout)
77
78 back btn. clicked .connect( self .show main menu.emit)
79 back btn. clicked .connect(
80 lambda: self . stack widget .setCurrentWidget( self . step1))
81
82 self . step1 . next btn . clicked .connect(
83 lambda: self . stack widget .setCurrentWidget( self . step2))
84 self . step2 . prev btn . clicked .connect(
85 lambda: self . stack widget .setCurrentWidget( self . step1))
86 self . step2 . next btn . clicked .connect(
87 lambda: self . stack widget .setCurrentWidget( self . step3))
88 self . step3 . prev btn . clicked .connect(
Electronic Journal. http://diffjournal.spbu.ru/ 258Differential Equations and Control Processes, N. 1, 2021
89 lambda: self . stack widget .setCurrentWidget( self . step2))
90 self . step3 . next btn . clicked .connect(
91 lambda: self . stack widget .setCurrentWidget( self . step4))
92 self . step4 . prev btn . clicked .connect(
93 lambda: self . stack widget .setCurrentWidget( self . step3))
94 self . step4 . next btn . clicked .connect(
95 lambda: self . stack widget .setCurrentWidget( self . step5))
96 self . step5 . prev btn . clicked .connect(
97 lambda: self . stack widget .setCurrentWidget( self . step4))
98 self . step5 . next btn . clicked .connect(
99 lambda: self . stack widget .setCurrentWidget( self . step6))
100 self . step6 . prev btn . clicked .connect(
101 lambda: self . stack widget .setCurrentWidget( self . step5))
102 self . step6 . next btn . clicked .connect(
103 lambda: self . stack widget .setCurrentWidget( self . step7))
104 self . step7 . prev btn . clicked .connect(
105 lambda: self . stack widget .setCurrentWidget( self . step6))
106 self . step7 . next btn . clicked .connect(
107 lambda: self . stack widget .setCurrentWidget( self . step8))
108 self . step8 . prev btn . clicked .connect(
109 lambda: self . stack widget .setCurrentWidget( self . step7))
110
111 self . step8 .run btn. clicked .connect(
112 lambda: self .run modeling())
113 self . step8 .run btn. clicked .connect(
114 lambda: self . stack widget .setCurrentWidget( self . step1))
115
116 self . step1 . n valid .connect( self . step2 .matrix. resize h)
117 self . step1 . n valid .connect( self . step2 .matrix. resize w)
118
119 self . step1 . n valid .connect( self . step3 .matrix. resize h)
120 self . step1 . k valid .connect( self . step3 .matrix. resize w)
121
122 self . step1 . n valid .connect( self . step4 .matrix. resize h)
123 self . step1 .m valid.connect( self . step4 .matrix. resize w)
124
125 self . step1 . k valid .connect( self . step5 .matrix. resize h)
126
127 self . step1 . n valid .connect( self . step6 .matrix. resize w)
128
129 self . step1 . n valid .connect( self . step7 .matrix. resize h)
130
131 def run modeling( self ):
132 self . start progress .emit("The modeling is being performed ... ")
133
134 worker = Worker( self . routine)
135 worker. signals . result .connect( self . on modeling finish)
136 worker. signals . error .connect( self . on modeling corrupted)
137 QThreadPool. globalInstance () . start(worker)
138
139 def routine( self ):
140 n = int( self . step1 . lineedit n . text())
141 m = int( self . step1 . lineedit m . text())
142 k = int( self . step1 . lineedit k . text())
143 t0 = float( self . step8 . lineedit t0 . text())
Electronic Journal. http://diffjournal.spbu.ru/ 259Differential Equations and Control Processes, N. 1, 2021
144 dt = float( self . step8 . lineedit dt . text())
145 t1 = float( self . step8 . lineedit t1 . text())
146
147 self . logger . info("Reading input data")
148
149 integral = Integral(n)
150
151 integral .k, integral .m, integral .dt , integral .t0 , integral .tk = n
152 k, m, dt , t0 , t1
153
154 integral .m a = np. array ([[ float( self . step2 .matrix.m[ i ][ j ])
155 for j in range( self . step2 .matrix.columnCount())]
156 for i in range( self . step2 .matrix.rowCount()) ])
157
158 integral .mat b = np. array ([[ float( self . step3 .matrix.m[ i ][ j ])
159 for j in range( self . step3 .matrix.columnCount())]
160 for i in range( self . step3 .matrix.rowCount()) ])
161
162 integral .mat f = np. array ([[ float( self . step4 .matrix.m[ i ][ j ])
163 for j in range( self . step4 .matrix.columnCount())]
164 for i in range( self . step4 .matrix.rowCount()) ])
165
166 integral .m h = np. array ([[ float( self . step6 .matrix.m[ i ][ j ])
167 for j in range( self . step6 .matrix.columnCount())]
168 for i in range( self . step6 .matrix.rowCount()) ])
169
170 integral .m x0 = np. array ([[ float( self . step7 .matrix.m[ i ][ j ])
171 for j in range( self . step7 .matrix.columnCount())]
172 for i in range( self . step7 .matrix.rowCount()) ])
173
174 integral .m mx0 = np. array ([[ float( self . step7 .matrix.m[ i ][ j ])
175 for j in range( self . step7 .matrix.columnCount())]
176 for i in range( self . step7 .matrix.rowCount()) ])
177
178 integral .m dx0 = np. zeros (( integral .n, integral .n))
179
180 self . logger . info("Input is correct")
181 self . logger . info("Calculation of Ad and Bd (Algorithm 11.2)")
182
183 integral .m ad, integral .m bd = dindet(
184 integral .n, integral .k, integral .m a, integral .mat b, integral .dt)
185
186 self . logger . info("Calculation of Fd (Algorithm 11.6)")
187
188 integral .m fd = stoch(integral .n, integral .m a, integral .mat f , integral .dt)
189
190 mat u = np. array ([[ object ]] ∗ self . step5 .matrix.rowCount())
191 for i in range( self . step5 .matrix.rowCount()):
192 mat u[ i ][0] = Symbolic( self . step5 .matrix.m[ i ][0])
193
194 integral . distortion = ComplexDistortion( self . step5 .matrix.rowCount() , mat u)
195
196 self . logger . info("Starting modeling loop")
197
198 start time = time()
Electronic Journal. http://diffjournal.spbu.ru/ 260Differential Equations and Control Processes, N. 1, 2021
199 integral . integrate ()
200
201 self . logger . info(f"Integration took f(time() − start time) :.3 fg seconds")
202
203 lines = [Line(f"Linear , xfi + 1g",
204 np. array(integral . v t). astype(float) ,
205 np. array(integral .m xt[i , :]) . astype(float) ,
206 mx=np. array(integral .m mx[i , :]) . astype(float) ,
207 dx=np. array(integral .m dx[i , :]) . astype(float))
208 for i in range(integral .m xt.shape [0]) ]
209
210 name = f"Linear"
211
212 lines .append(Line(f"Linear , y",
213 np. array(integral . v t). astype(float) ,
214 np. array(integral . v yt). astype(float) ,
215 mx=np. array(integral .v my). astype(float) ,
216 dx=np. array(integral .v dy). astype(float)))
217
218 return lines
219
220 def on modeling finish(self , result):
221 self . stop progress .emit("The modeling has been completed!")
222 self .draw chart.emit(result)
223
224 def on modeling corrupted(self , result):
225 self . logger . error(result [0])
226 self . logger . error(result [1])
227 self . logger . error(result [2])
228
229 self . stop progress .emit("The modeling failed !")
Listing 35: Step 1 of data input for linear systems
1 from PyQt5.QtCore import pyqtSignal
2 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QGridLayout, QLineEdit , QLabel, n
3 QVBoxLayout, QSpacerItem , QSizePolicy , QPushButton, QApplication , QStyle
4
5 from ui .main. error import ErrorWidget
6 from ui .main. info import InfoIcon
7 from ui .main.svg import SVG
8
9
10 class Step1(QWidget):
11
12 n valid = pyqtSignal(int)
13 m valid = pyqtSignal(int)
14 k valid = pyqtSignal(int)
15
16 def init (self , parent=None):
17 super(QWidget, self ). init (parent)
18
19 self . n is valid = False
Electronic Journal. http://diffjournal.spbu.ru/ 261Differential Equations and Control Processes, N. 1, 2021
20 self . m is valid = False
21 self . k is valid = False
22
23 self . input stack = self .parent()
24
25 info n = InfoIcon("Dimension of linear system of Ito SDEs")
26 info m = InfoIcon("Dimension of vector Wiener process")
27 info k = InfoIcon("Dimension of vector function u(t)")
28
29 label n = QLabel("n")
30 label m = QLabel("m")
31 label k = QLabel("k")
32
33 self . lineedit n = QLineEdit()
34 self . lineedit m = QLineEdit()
35 self . lineedit k = QLineEdit()
36
37 self .msg n = ErrorWidget("Wrong value !")
38 self .msg n. hide()
39
40 self .msg m = ErrorWidget("Wrong value !")
41 self .msg m. hide()
42
43 self .msg k = ErrorWidget("Wrong value !")
44 self .msg k. hide()
45
46 grid layout = QGridLayout()
47 grid layout .addWidget( self .msg n, 0, 2)
48 grid layout .addWidget( self .msg m, 2, 2)
49 grid layout .addWidget( self .msg k, 4, 2)
50 grid layout .addWidget(info n , 1, 0)
51 grid layout .addWidget(info m , 3, 0)
52 grid layout .addWidget(info k , 5, 0)
53 grid layout .addWidget(label n , 1, 1)
54 grid layout .addWidget(label m , 3, 1)
55 grid layout .addWidget(label k , 5, 1)
56 grid layout .addWidget( self . lineedit n , 1, 2)
57 grid layout .addWidget( self . lineedit m , 3, 2)
58 grid layout .addWidget( self . lineedit k , 5, 2)
59
60 header = QLabel("Dimensions settings", parent=self )
61 font = header. font()
62 font . setPointSize(15)
63 header.setFont(font)
64
65 self . next btn = QPushButton("Next", self )
66 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
67 self . next btn .setEnabled(False)
68
69 header layout = QHBoxLayout()
70 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
71 header layout .addWidget(header)
72 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
73
74 bottom bar = QHBoxLayout()
Electronic Journal. http://diffjournal.spbu.ru/ 262Differential Equations and Control Processes, N. 1, 2021
75 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
76 bottom bar.addWidget( self . next btn)
77
78 eq1 = QHBoxLayout()
79 eq1.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
80 eq1.addWidget(SVG("equation3 .svg", scale factor=1.))
81 eq1.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
82
83 eq2 = QHBoxLayout()
84 eq2.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
85 eq2.addWidget(SVG("equation4 .svg", scale factor=1.))
86 eq2.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
87
88 equalities layout = QVBoxLayout()
89 equalities layout .addLayout(eq1)
90 equalities layout .addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum
))
91 equalities layout .addLayout(eq2)
92
93 equalities wrap = QHBoxLayout()
94 equalities wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum)
)
95 equalities wrap .addLayout(equalities layout)
96 equalities wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum)
)
97
98 grid wrap = QHBoxLayout()
99 grid wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
100 grid wrap .addLayout(grid layout)
101 grid wrap .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
102
103 layout = QVBoxLayout()
104 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Minimum, QSizePolicy .Expanding))
105 layout .addLayout(equalities wrap)
106 layout .addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum))
107 layout .addLayout(header layout)
108 layout .addItem(QSpacerItem(0, 5, QSizePolicy .Minimum, QSizePolicy .Minimum))
109 layout .addLayout(grid wrap)
110 layout .addItem(QSpacerItem(0, 0, QSizePolicy .Minimum, QSizePolicy .Expanding))
111 layout .addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum))
112 layout .addLayout(bottom bar)
113
114 self .setLayout(layout)
115
116 self . lineedit n .textChanged.connect( self . validate n)
117 self . lineedit m .textChanged.connect( self . validate m)
118 self . lineedit k .textChanged.connect( self . validate k)
119
120 def validate form( self ):
121 if self . n is valid and self . m is valid and self . k is valid :
122 self . next btn .setEnabled(True)
123 else :
124 self . next btn .setEnabled(False)
125
126 def validate n(self , value):
Electronic Journal. http://diffjournal.spbu.ru/ 263Differential Equations and Control Processes, N. 1, 2021
127 try:
128 typed value = int(value)
129 if typed value <= 0:
130 raise ValueError()
131
132 self . n is valid = True
133 self . n valid .emit(typed value)
134 self .msg n. hide()
135
136 except ValueError:
137 self . n is valid = False
138 self .msg n.show()
139
140 finally :
141 self . validate form ()
142
143 def validate m(self , value):
144 try:
145 typed value = int(value)
146 if typed value <= 0:
147 raise ValueError()
148
149 self . m is valid = True
150 self .m valid.emit(typed value)
151 self .msg m. hide()
152
153 except ValueError:
154 self . m is valid = False
155 self .msg m.show()
156
157 finally :
158 self . validate form ()
159
160 def validate k(self , value):
161 try:
162 typed value = int(value)
163 if typed value <= 0:
164 raise ValueError()
165
166 self . k is valid = True
167 self . k valid .emit(typed value)
168 self .msg k. hide()
169
170 except ValueError:
171 self . k is valid = False
172 self .msg k.show()
173
174 finally :
175 self . validate form ()
Listing 36: Step 2 of data input for linear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QSpacerItem , QSizePolicy , n
Electronic Journal. http://diffjournal.spbu.ru/ 264Differential Equations and Control Processes, N. 1, 2021
2 QVBoxLayout, QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step2(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of matrix A", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of matrix A arenn"
22 "expected to be real valuesnn"
23 "Size : n x n")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
53
54 self .matrix.itemChanged.connect( self . validate item)
55
56 def validate item(self , item):
Electronic Journal. http://diffjournal.spbu.ru/ 265Differential Equations and Control Processes, N. 1, 2021
57
58 value = item. text()
59 try:
60 float(value)
61 if not item. valid :
62 item. valid = True
63 self . errors −= 1
64
65 except ValueError:
66 if item. valid :
67 item. valid = False
68 self . errors += 1
69
70 finally :
71 self . validate form ()
72
73 def validate form( self ):
74
75 if self . errors == 0:
76 self .msg. hide()
77 self . next btn .setEnabled(True)
78 else :
79 self .msg.show()
80 self . next btn .setEnabled(False)
Listing 37: Step 3 of data input for linear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QSpacerItem , QSizePolicy , n
2 QVBoxLayout, QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step3(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of matrix B", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of matrix B arenn"
22 "expected to be real valuesnn"
23 "Size : n x k")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
Electronic Journal. http://diffjournal.spbu.ru/ 266Differential Equations and Control Processes, N. 1, 2021
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
53
54 self .matrix.itemChanged.connect( self . validate item)
55
56 def validate item(self , item):
57
58 value = item. text()
59 try:
60 float(value)
61 if not item. valid :
62 item. valid = True
63 self . errors −= 1
64
65 except ValueError:
66 if item. valid :
67 item. valid = False
68 self . errors += 1
69
70 finally :
71 self . validate form ()
72
73 def validate form( self ):
74
75 if self . errors == 0:
76 self .msg. hide()
77 self . next btn .setEnabled(True)
78 else :
79 self .msg.show()
80 self . next btn .setEnabled(False)
Electronic Journal. http://diffjournal.spbu.ru/ 267Differential Equations and Control Processes, N. 1, 2021
Listing 38: Step 4 of data input for linear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QLabel, QSpacerItem , n
2 QSizePolicy , QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step4(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of matrix F", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of matrix F arenn"
22 "expected to be real valuesnn"
23 "Size : n x m")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
53
Electronic Journal. http://diffjournal.spbu.ru/ 268Differential Equations and Control Processes, N. 1, 2021
54 self .matrix.itemChanged.connect( self . validate item)
55
56 def validate item(self , item):
57
58 value = item. text()
59 try:
60 float(value)
61 if not item. valid :
62 item. valid = True
63 self . errors −= 1
64
65 except ValueError:
66 if item. valid :
67 item. valid = False
68 self . errors += 1
69
70 finally :
71 self . validate form ()
72
73 def validate form( self ):
74
75 if self . errors == 0:
76 self .msg. hide()
77 self . next btn .setEnabled(True)
78 else :
79 self .msg.show()
80 self . next btn .setEnabled(False)
Listing 39: Step 5 of data input for linear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QLabel, QSpacerItem , n
2 QSizePolicy , QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step5(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of vector function u(t)", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of vector u(t) are expected to be functionsnn"
22 "Size : k x 1nn"
23 "Functions must be set in python and SymPy notation")
Electronic Journal. http://diffjournal.spbu.ru/ 269Differential Equations and Control Processes, N. 1, 2021
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
Listing 40: Step 6 of data input for linear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QLabel, QSpacerItem , n
2 QSizePolicy , QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step6(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of matrix H", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of matrix H arenn"
Electronic Journal. http://diffjournal.spbu.ru/ 270Differential Equations and Control Processes, N. 1, 2021
22 "expected to be int valuesnn"
23 "Size : 1 x n")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
53
54 self .matrix.itemChanged.connect( self . validate item)
55
56 def validate item(self , item):
57
58 value = item. text()
59 try:
60 float(value)
61 if not item. valid :
62 item. valid = True
63 self . errors −= 1
64
65 except ValueError:
66 if item. valid :
67 item. valid = False
68 self . errors += 1
69
70 finally :
71 self . validate form ()
72
73 def validate form( self ):
74
75 if self . errors == 0:
76 self .msg. hide()
Electronic Journal. http://diffjournal.spbu.ru/ 271Differential Equations and Control Processes, N. 1, 2021
77 self . next btn .setEnabled(True)
78 else :
79 self .msg.show()
80 self . next btn .setEnabled(False)
Listing 41: Step 7 of data input for linear systems
1 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QLabel, QSpacerItem , n
2 QSizePolicy , QPushButton, QApplication , QStyle
3
4 from ui .main. error import ErrorWidget
5 from ui .main. info import InfoIcon
6 from ui .main.modeling. matrix widget import MatrixWidget
7
8
9 class Step7(QWidget):
10
11 def init (self , parent=None):
12 super(QWidget, self ). init (parent)
13
14 self . errors = 0
15
16 header = QLabel("Setting of column x0", parent=self )
17 font = header. font()
18 font . setPointSize(15)
19 header.setFont(font)
20
21 info = InfoIcon("Elements of column x0 arenn"
22 "expected to be real valuesnn"
23 "Size : n x 1")
24
25 self .msg = ErrorWidget("Wrong values in matrix!")
26 self .msg. hide()
27
28 self .matrix = MatrixWidget( self )
29
30 self . next btn = QPushButton("Next", self )
31 self . next btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
32
33 self . prev btn = QPushButton("Back", self )
34 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
35
36 header layout = QHBoxLayout()
37 header layout .addWidget(info)
38 header layout .addWidget(header)
39 header layout .addWidget( self .msg)
40 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
41
42 bottom bar = QHBoxLayout()
43 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
44 bottom bar.addWidget( self . prev btn)
45 bottom bar.addWidget( self . next btn)
46
Electronic Journal. http://diffjournal.spbu.ru/ 272Differential Equations and Control Processes, N. 1, 2021
47 layout = QVBoxLayout()
48 layout .addLayout(header layout)
49 layout .addWidget( self .matrix)
50 layout .addLayout(bottom bar)
51
52 self .setLayout(layout)
53
54 self .matrix.itemChanged.connect( self . validate item)
55
56 def validate item(self , item):
57
58 value = item. text()
59 try:
60 float(value)
61 if not item. valid :
62 item. valid = True
63 self . errors −= 1
64
65 except ValueError:
66 if item. valid :
67 item. valid = False
68 self . errors += 1
69
70 finally :
71 self . validate form ()
72
73 def validate form( self ):
74
75 if self . errors == 0:
76 self .msg. hide()
77 self . next btn .setEnabled(True)
78 else :
79 self .msg.show()
80 self . next btn .setEnabled(False)
Listing 42: Step 8 of data input for linear systems
1 import sys
2
3 from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QLineEdit , QGridLayout, n
4 QVBoxLayout, QSizePolicy , QSpacerItem , QPushButton, QApplication , QStyle
5
6 from ui .main. error import ErrorWidget
7 from ui .main. info import InfoIcon
8
9
10 class Step8(QWidget):
11
12 def init (self , parent=None):
13 super(QWidget, self ). init (parent)
14
15 self .t0 = sys . float info .min
16 self .dt = 0
Electronic Journal. http://diffjournal.spbu.ru/ 273Differential Equations and Control Processes, N. 1, 2021
17 self .t1 = sys . float info .max
18 self .s = 0
19
20 self . t0 is valid = False
21 self . dt is valid = False
22 self . t1 is valid = False
23 self . s is valid = True
24
25 self . input stack = self .parent()
26
27 info t0 = InfoIcon("Start point of integration intervalnn"
28 "Must be in [0 , t1) range")
29 info dt = InfoIcon("Integration stepnn"
30 "Must be set in (0, 1) interval")
31 info t1 = InfoIcon("Final point of integration intervalnn"
32 "Must be more then t0")
33 info s = InfoIcon("This is random generator seednn"
34 "If You do not want to use specificnn"
35 "seed just leave this field empty")
36
37 label t0 = QLabel("t0")
38 label dt = QLabel("dt")
39 label t1 = QLabel("t1")
40 label s = QLabel("seed")
41
42 self . lineedit t0 = QLineEdit()
43 self . lineedit dt = QLineEdit()
44 self . lineedit t1 = QLineEdit()
45 self . lineedit s = QLineEdit()
46
47 self .msg t0 = ErrorWidget("Wrong value !")
48 self .msg t0. hide()
49
50 self .msg dt = ErrorWidget("Wrong value !")
51 self .msg dt. hide()
52
53 self .msg t1 = ErrorWidget("Wrong value !")
54 self .msg t1. hide()
55
56 self .msg s = ErrorWidget("Wrong value !")
57 self .msg s. hide()
58
59 header = QLabel("Accuracy settings", parent=self )
60 font = header. font()
61 font . setPointSize(15)
62 header.setFont(font)
63
64 self . prev btn = QPushButton("Back", self )
65 self . prev btn . setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowBack))
66
67 self .run btn = QPushButton("Perform modeling", self )
68 self .run btn. setIcon(QApplication. style () . standardIcon(QStyle.SP ArrowForward))
69 self .run btn.setEnabled(False)
70
71 header layout = QHBoxLayout()
Electronic Journal. http://diffjournal.spbu.ru/ 274Differential Equations and Control Processes, N. 1, 2021
72 header layout .addWidget(header)
73 header layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
74
75 bottom bar = QHBoxLayout()
76 bottom bar.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Minimum))
77 bottom bar.addWidget( self . prev btn)
78 bottom bar.addWidget( self .run btn)
79
80 grid layout = QGridLayout()
81
82 grid layout .addWidget( self .msg t0 , 0, 2)
83
84 grid layout .addWidget(info t0 , 1, 0)
85 grid layout .addWidget(label t0 , 1, 1)
86 grid layout .addWidget( self . lineedit t0 , 1, 2)
87
88 grid layout .addWidget( self .msg dt , 0, 5)
89
90 grid layout .addWidget(info dt , 1, 3)
91 grid layout .addWidget(label dt , 1, 4)
92 grid layout .addWidget( self . lineedit dt , 1, 5)
93
94 grid layout .addWidget( self .msg t1 , 0, 8)
95
96 grid layout .addWidget(info t1 , 1, 6)
97 grid layout .addWidget(label t1 , 1, 7)
98 grid layout .addWidget( self . lineedit t1 , 1, 8)
99
100 grid layout .addWidget( self .msg s , 2, 2)
101
102 grid layout .addWidget(info s , 3, 0)
103 grid layout .addWidget(label s , 3, 1)
104 grid layout .addWidget( self . lineedit s , 3, 2)
105
106 column layout = QVBoxLayout()
107 column layout.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding)
)
108 column layout.addLayout(header layout)
109 column layout.addItem(QSpacerItem(0, 25, QSizePolicy .Minimum, QSizePolicy .Minimum))
110 column layout.addLayout(grid layout)
111 column layout.addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding)
)
112
113 control layout = QHBoxLayout()
114 control layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding
))
115 control layout .addLayout(column layout)
116 control layout .addItem(QSpacerItem(0, 0, QSizePolicy .Expanding , QSizePolicy .Expanding
))
117
118 layout = QVBoxLayout()
119 layout .addLayout(control layout)
120 layout .addLayout(bottom bar)
121
122 self .setLayout(layout)
Electronic Journal. http://diffjournal.spbu.ru/ 275Differential Equations and Control Processes, N. 1, 2021
123
124 self . lineedit t0 .textChanged.connect( self . validate t0)
125 self . lineedit t0 .textChanged.connect( self . validate t1)
126 self . lineedit t0 .textChanged.connect( self . validate dt)
127 self . lineedit dt .textChanged.connect( self . validate dt)
128 self . lineedit t1 .textChanged.connect( self . validate t0)
129 self . lineedit t1 .textChanged.connect( self . validate t1)
130 self . lineedit t1 .textChanged.connect( self . validate dt)
131 self . lineedit s .textChanged.connect( self . validate s)
132
133 def count c(self , flag : bool):
134 if flag :
135 self . info c .show()
136 self . label c .show()
137 else :
138 self . info c . hide()
139 self . label c . hide()
140
141 self .msg c. hide()
142
143 def validate form( self ):
144 if self . t0 is valid n
145 and self . dt is valid n
146 and self . t1 is valid n
147 and self . s is valid :
148 self .run btn.setEnabled(True)
149 else :
150 self .run btn.setEnabled(False)
151
152 def validate t0( self ):
153 try:
154 typed value = float( self . lineedit t0 . text())
155 if typed value >= self .t1:
156 raise ValueError()
157
158 self . t0 is valid = True
159 self .t0 = typed value
160 self .msg t0. hide()
161
162 except ValueError:
163 self . t0 is valid = False
164 self .msg t0.show()
165
166 def validate dt( self ):
167 try:
168 typed value = float( self . lineedit dt . text())
169 if typed value <= 0 n
170 or ( self .t1 − self .t0) / typed value < 1 n
171 or typed value >= 1:
172 raise ValueError()
173
174 self . dt is valid = True
175 self .dt = typed value
176 self .msg dt. hide()
177 self . validate form ()
Electronic Journal. http://diffjournal.spbu.ru/ 276Differential Equations and Control Processes, N. 1, 2021
178
179 except ValueError:
180 self . dt is valid = False
181 self .msg dt.show()
182
183 def validate t1( self ):
184 try:
185 typed value = float( self . lineedit t1 . text())
186 if typed value <= self .t0:
187 raise ValueError()
188
189 self . t1 is valid = True
190 self .t1 = typed value
191 self .msg t1. hide()
192
193 except ValueError:
194 self . t1 is valid = False
195 self .msg t1.show()
196
197 def validate s( self ):
198 try:
199 if self . lineedit s . text() == "":
200 self . s is valid = True
201 self .s = 0
202 else :
203 typed value = int( self . lineedit s . text())
204 if typed value <= 0:
205 raise ValueError()
206 self .s = typed value
207
208 self . s is valid = True
209 self .msg s. hide()
210
211 except ValueError:
212 self . s is valid = False
213 self .msg s.show()
214
215 finally :
216 self . validate form ()
6.2 Source Codes for Nonlinear Systems of It^ o SDEs
6.2.1 Source Codes for Calculation of the Fourier{Legendre Coe -
cients
Listing 43: Symbolic function of the Legendre polinomial
1 from sympy import Rational , factorial , diff
2
Electronic Journal. http://diffjournal.spbu.ru/ 277Differential Equations and Control Processes, N. 1, 2021
3
4 def polynomial(n: int):
5 """
6 Returns the Legendre polynomial in symbolic format
7 Parameters
8 ==========
9 n : int
10 degree of the Legendre polynomial
11 Returns
12 =======
13 sympy.Expr
14 """
15 from sympy.abc import x
16 return Rational(1, 2) ∗∗ n / factorial (n) ∗ diff ((x ∗∗ 2 − 1) ∗∗ n, x, n)
Listing 44: Symbolic function of the Fourier{Legendre coe cient calculation
1 from sympy import S, integrate
2
3 from mathematics.sde. nonlinear . legendre polynomial import polynomial
4
5
6 def get c(indices : tuple , weights : tuple):
7 """
8 Calculates the Fourier−Legendre coefficient depending on indices and weights
9 Parameters
10 ==========
11 indices : tuple
12 indices of the Fourier−Legendre coefficient
13 weights : tuple
14 weights of the Fourier−Legendre coefficient
15 Returns
16 =======
17 sympy.Rational
18 """
19 from sympy.abc import x, y
20 # multiplicity of iterated integral which is the Fourier−Legendre coefficient
21 n = len(indices)
22 w = list (reversed(weights))
23 c = S.One
24
25 for i in reversed(range(1, n)):
26 c = integrate(polynomial(indices [ i ]) ∗ (x + 1) ∗∗ w[ i ] ∗ c, (x, −1, y)).subs(y, x)
27 c = integrate(polynomial(indices [0]) ∗ (x + 1) ∗∗ w[0] ∗ c, (x, −1, 1))
28
29 if sum(w) % 2 == 0:
30 return c
31 else :
32 return −c
Listing 45: Symbolic function of the Fourier{Legendre coe cient
1 import logging
Electronic Journal. http://diffjournal.spbu.ru/ 278Differential Equations and Control Processes, N. 1, 2021
2
3 from sympy import sympify , Function
4
5 import tools .database as db
6 from mathematics.sde. nonlinear .c import get c
7
8
9 class C(Function):
10 """
11 Gives the Fourier−Legendre coefficient with requested indices and weights
12 """
13 preloaded = dict()
14
15 def new (cls , indices : tuple , weights : tuple , to float=True, ∗∗kwargs):
16 """
17 Creates the Fourier−Legendre coefficient object with needed indices and weights
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C
27 calculated value or symbolic expression
28 """
29 if not len(indices) == len(weights):
30 return super(C, cls ). new (cls , indices , weights , ∗∗kwargs)
31
32 index = f"f ': '. join ([ str(i) for i in indices ])g f ': '. join ([ str(i) for i in weights ])g
"
33 try:
34 return cls . value(index , to float )
35
36 except KeyError:
37 respond = cls . download one(index)
38 if len(respond) != 0:
39 cls . preloaded [respond [0][0]] = respond [0][1]
40 return cls . value(index , to float )
41 else :
42 new c = cls . calculate(index , indices , weights)
43 cls . upload one(new c)
44 cls . preloaded [new c [0]] = new c[1]
45 return cls . value(index , to float )
46
47 @classmethod
48 def calculate(cls , index , indices , weights):
49 new c = get c(indices , weights)
50 return index , (new c , sympify(new c). evalf ())
51
52 @classmethod
53 def upload one(cls , c):
54 logging . info(f"C: ADDING NEW Cfc[0]g = fc [1][0]g")
55 db. execute(f"INSERT INTO `C` (`index ` , `value ` , `value f `) VALUES ('fc[0]g ' , 'fc
Electronic Journal. http://diffjournal.spbu.ru/ 279Differential Equations and Control Processes, N. 1, 2021
[1][0]g ' , fc [1][1]g)")
56
57 @classmethod
58 def unpack(cls , rows):
59 return [(rows[ i ][0] , (rows[ i ][1] , rows[ i ][2]) ) for i in range(len(rows))]
60
61 @classmethod
62 def value(cls , index , to float ):
63 c = cls . preloaded [index]
64 if to float :
65 return c[1]
66 else :
67 return sympify(c[0])
68
69 @classmethod
70 def download one(cls , index):
71 logging . info(f"C: MISSING PRELOADED VERSION OF C findexg")
72 respond = db. execute(
73 f"SELECT `index ` , `value ` , `value f ` FROM `C`"
74 f"WHERE REGEXP(`index ` , '^findexg$ ')"
75 )
76 return cls . unpack(respond)
77
78 @classmethod
79 def preload(cls , ∗args):
80 """
81 Updates dictionary of the preloaded Fourier−Legendre coefficients
82 Note: weights are not accepted , such coefficients are loaded
83 with all available weights
84 Parameters
85 ==========
86 args
87 Indices for the Fourier−Legendre coefficients
88 to download them from database
89 """
90 logging . info(f"C: PRELOADING COEFFICIENTS fargsg")
91
92 query = []
93 for q in range(len(args)):
94 numbers = [int(char) for char in str(args [q] + 1)]
95 pattern = []
96
97 for i in range(1, len(numbers)):
98 pattern .append("[0−9]" ∗ i)
99
100 for i in range(len(numbers)):
101 p = []
102 for j in range(len(numbers)):
103 if j < i :
104 p.append(str(numbers[ j ]) )
105 elif i == j :
106 p.append(f"[0−fnumbers[ j ] − 1g]")
107 elif j > i :
108 p.append("[0−9]")
109 pattern .append("". join(p))
Electronic Journal. http://diffjournal.spbu.ru/ 280Differential Equations and Control Processes, N. 1, 2021
110
111 regex = f"^f ': '. join ([ 'j '. join(pattern) for in range(q + 2) ])g .∗$"
112 query.append(
113 f"SELECT `index ` , `value ` , `value f ` FROM `C`"
114 f"WHERE REGEXP(`index ` , 'fregexg')"
115 )
116
117 result = db. execute("nnUNIONnn". join(query))
118 cls . preloaded .update( cls . unpack(result))
119
120 def doit(self , ∗∗hints):
121 """
122 Tries to expand or calculate function
123 Returns
124 =======
125 C
126 """
127 return C(∗ self .args , ∗∗hints)
Listing 46: Calculation of the Fourier{Legendre coe cients C
000
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C000(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 4
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C000
27 calculated value or symbolic expression
28 """
29 j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
Electronic Journal. http://diffjournal.spbu.ru/ 281Differential Equations and Control Processes, N. 1, 2021
33 isinstance(j3 , Number) and
34 isinstance(dt , Number)):
35 return super(C000, cls ). new (cls , ∗args , ∗∗kwargs)
36
37 return sqrt(
38 (j1 ∗ 2 + 1) ∗
39 (j2 ∗ 2 + 1) ∗
40 (j3 ∗ 2 + 1)) ∗ n
41 dt ∗∗ 1.5 ∗ n
42 C((j3 , j2 , j1) , (0, 0, 0)) / 8
43
44 def doit(self , ∗∗hints):
45 """
46 Tries to expand or calculate function
47 Returns
48 =======
49 C000
50 """
51 return C000(∗ self .args , ∗∗hints)
Listing 47: Calculation of the Fourier{Legendre coe cients C
10
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C10(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 3
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C10
27 calculated value or symbolic expression
28 """
29 j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
Electronic Journal. http://diffjournal.spbu.ru/ 282Differential Equations and Control Processes, N. 1, 2021
32 isinstance(j2 , Number) and
33 isinstance(dt , Number)):
34 return super(C10, cls ). new (cls , ∗args , ∗∗kwargs)
35
36 return sqrt(
37 (j1 ∗ 2 + 1) ∗
38 (j2 ∗ 2 + 1)) ∗ n
39 dt ∗∗ 2 ∗ n
40 C((j2 , j1) , (1, 0)) / 8
41
42 def doit(self , ∗∗hints):
43 """
44 Tries to expand or calculate function
45 Returns
46 =======
47 C10
48 """
49 return C10(∗ self .args , ∗∗hints)
Listing 48: Calculation of the Fourier{Legendre coe cients C
01
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C01(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 3
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C01
27 calculated value or symbolic expression
28 """
29 j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
Electronic Journal. http://diffjournal.spbu.ru/ 283Differential Equations and Control Processes, N. 1, 2021
33 isinstance(dt , Number)):
34 return super(C01, cls ). new (cls , ∗args , ∗∗kwargs)
35
36 return sqrt(
37 (j1 ∗ 2 + 1) ∗
38 (j2 ∗ 2 + 1)) ∗ n
39 dt ∗∗ 2 ∗ n
40 C((j2 , j1) , (0, 1)) / 8
41
42 def doit(self , ∗∗hints):
43 """
44 Tries to expand or calculate function
45 Returns
46 =======
47 C01
48 """
49 return C01(∗ self .args , ∗∗hints)
Listing 49: Calculation of the Fourier{Legendre coe cients C
0000
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C0000(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 5
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C0000
27 calculated value or symbolic expression
28 """
29 j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
Electronic Journal. http://diffjournal.spbu.ru/ 284Differential Equations and Control Processes, N. 1, 2021
34 isinstance(j4 , Number) and
35 isinstance(dt , Number)):
36 return super(C0000, cls ). new (cls , ∗args , ∗∗kwargs)
37
38 return sqrt(
39 (j1 ∗ 2 + 1) ∗
40 (j2 ∗ 2 + 1) ∗
41 (j3 ∗ 2 + 1) ∗
42 (j4 ∗ 2 + 1)) ∗ n
43 dt ∗∗ 2 ∗ n
44 C((j4 , j3 , j2 , j1) , (0, 0, 0, 0)) / 16
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 C0000
52 """
53 return C0000(∗ self .args , ∗∗hints)
Listing 50: Calculation of the Fourier{Legendre coe cients C
100
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C100(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 4
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C100
27 calculated value or symbolic expression
28 """
29 j3 , j2 , j1 , dt = sympify(args)
30
Electronic Journal. http://diffjournal.spbu.ru/ 285Differential Equations and Control Processes, N. 1, 2021
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(dt , Number)):
35 return super(C100, cls ). new (cls , ∗args , ∗∗kwargs)
36
37 return sqrt(
38 (j1 ∗ 2 + 1) ∗
39 (j2 ∗ 2 + 1) ∗
40 (j3 ∗ 2 + 1)) ∗ n
41 dt ∗∗ 2.5 ∗ n
42 C((j3 , j2 , j1) , (1, 0, 0)) / 16
43
44 def doit(self , ∗∗hints):
45 """
46 Tries to expand or calculate function
47 Returns
48 =======
49 C100
50 """
51 return C100(∗ self .args , ∗∗hints)
Listing 51: Calculation of the Fourier{Legendre coe cients C
010
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C010(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 4
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C010
27 calculated value or symbolic expression
28 """
29 j3 , j2 , j1 , dt = sympify(args)
Electronic Journal. http://diffjournal.spbu.ru/ 286Differential Equations and Control Processes, N. 1, 2021
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(dt , Number)):
35 return super(C010, cls ). new (cls , ∗args , ∗∗kwargs)
36
37 return sqrt(
38 (j1 ∗ 2 + 1) ∗
39 (j2 ∗ 2 + 1) ∗
40 (j3 ∗ 2 + 1)) ∗ n
41 dt ∗∗ 2.5 ∗ n
42 C((j3 , j2 , j1) , (0, 1, 0)) / 16
43
44 def doit(self , ∗∗hints):
45 """
46 Tries to expand or calculate function
47 Returns
48 =======
49 C010
50 """
51 return C010(∗ self .args , ∗∗hints)
Listing 52: Calculation of the Fourier{Legendre coe cients C
001
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C001(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 4
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C001
27 calculated value or symbolic expression
28 """
Electronic Journal. http://diffjournal.spbu.ru/ 287Differential Equations and Control Processes, N. 1, 2021
29 j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(dt , Number)):
35 return super(C001, cls ). new (cls , ∗args , ∗∗kwargs)
36
37 return sqrt(
38 (j1 ∗ 2 + 1) ∗
39 (j2 ∗ 2 + 1) ∗
40 (j3 ∗ 2 + 1)) ∗ n
41 dt ∗∗ 2.5 ∗ n
42 C((j3 , j2 , j1) , (0, 0, 1)) / 16
43
44 def doit(self , ∗∗hints):
45 """
46 Tries to expand or calculate function
47 Returns
48 =======
49 C001
50 """
51 return C001(∗ self .args , ∗∗hints)
Listing 53: Calculation of the Fourier{Legendre coe cients C
00000
j
5
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C00000(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 6
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C00000
27 calculated value or symbolic expression
Electronic Journal. http://diffjournal.spbu.ru/ 288Differential Equations and Control Processes, N. 1, 2021
28 """
29 j5 , j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(j4 , Number) and
35 isinstance(j5 , Number) and
36 isinstance(dt , Number)):
37 return super(C00000, cls ). new (cls , ∗args , ∗∗kwargs)
38
39 return sqrt(
40 (j1 ∗ 2 + 1) ∗
41 (j2 ∗ 2 + 1) ∗
42 (j3 ∗ 2 + 1) ∗
43 (j4 ∗ 2 + 1) ∗
44 (j5 ∗ 2 + 1)) ∗ n
45 dt ∗∗ 2.5 ∗ n
46 C((j5 , j4 , j3 , j2 , j1) , (0, 0, 0, 0, 0)) / 32
47
48 def doit(self , ∗∗hints):
49 """
50 Tries to expand or calculate function
51 Returns
52 =======
53 C00000
54 """
55 return C00000(∗ self .args , ∗∗hints)
Listing 54: Calculation of the Fourier{Legendre coe cients C
20
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C20(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 3
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
Electronic Journal. http://diffjournal.spbu.ru/ 289Differential Equations and Control Processes, N. 1, 2021
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C20
27 calculated value or symbolic expression
28 """
29 j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(dt , Number)):
34 return super(C20, cls ). new (cls , ∗args , ∗∗kwargs)
35
36 return sqrt(
37 (j1 ∗ 2 + 1) ∗
38 (j2 ∗ 2 + 1)) ∗ n
39 dt ∗∗ 3 ∗ n
40 C((j2 , j1) , (2, 0)) / 16
41
42 def doit(self , ∗∗hints):
43 """
44 Tries to expand or calculate function
45 Returns
46 =======
47 C20
48 """
49 return C20(∗ self .args , ∗∗hints)
Listing 55: Calculation of the Fourier{Legendre coe cients C
11
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C11(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 3
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
Electronic Journal. http://diffjournal.spbu.ru/ 290Differential Equations and Control Processes, N. 1, 2021
24 Returns
25 =======
26 symbolic.Rational or C11
27 calculated value or symbolic expression
28 """
29 j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(dt , Number)):
34 return super(C11, cls ). new (cls , ∗args , ∗∗kwargs)
35
36 return sqrt(
37 (j1 ∗ 2 + 1) ∗
38 (j2 ∗ 2 + 1)) ∗ n
39 dt ∗∗ 3 ∗ n
40 C((j2 , j1) , (1, 1)) / 16
41
42 def doit(self , ∗∗hints):
43 """
44 Tries to expand or calculate function
45 Returns
46 =======
47 C11
48 """
49 return C11(∗ self .args , ∗∗hints)
Listing 56: Calculation of the Fourier{Legendre coe cients C
02
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C02(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 3
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
Electronic Journal. http://diffjournal.spbu.ru/ 291Differential Equations and Control Processes, N. 1, 2021
25 =======
26 symbolic.Rational or C02
27 calculated value or symbolic expression
28 """
29 j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(dt , Number)):
34 return super(C02, cls ). new (cls , ∗args , ∗∗kwargs)
35
36 return sqrt(
37 (j1 ∗ 2 + 1) ∗
38 (j2 ∗ 2 + 1)) ∗ n
39 dt ∗∗ 3 ∗ n
40 C((j2 , j1) , (0, 2)) / 16
41
42 def doit(self , ∗∗hints):
43 """
44 Tries to expand or calculate function
45 Returns
46 =======
47 C02
48 """
49 return C02(∗ self .args , ∗∗hints)
Listing 57: Calculation of the Fourier{Legendre coe cients C
1000
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C1000(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 5
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
Electronic Journal. http://diffjournal.spbu.ru/ 292Differential Equations and Control Processes, N. 1, 2021
26 symbolic.Rational or C1000
27 calculated value or symbolic expression
28 """
29 j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(j4 , Number) and
35 isinstance(dt , Number)):
36 return super(C1000, cls ). new (cls , ∗args , ∗∗kwargs)
37
38 return sqrt(
39 (j1 ∗ 2 + 1) ∗
40 (j2 ∗ 2 + 1) ∗
41 (j3 ∗ 2 + 1) ∗
42 (j4 ∗ 2 + 1)) ∗ n
43 dt ∗∗ 3 ∗ n
44 C((j4 , j3 , j2 , j1) , (1, 0, 0, 0)) / 32
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 C1000
52 """
53 return C1000(∗ self .args , ∗∗hints)
Listing 58: Calculation of the Fourier{Legendre coe cients C
0100
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C0100(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 5
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
Electronic Journal. http://diffjournal.spbu.ru/ 293Differential Equations and Control Processes, N. 1, 2021
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C0100
27 calculated value or symbolic expression
28 """
29 j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(j4 , Number) and
35 isinstance(dt , Number)):
36 return super(C0100, cls ). new (cls , ∗args , ∗∗kwargs)
37
38 return sqrt(
39 (j1 ∗ 2 + 1) ∗
40 (j2 ∗ 2 + 1) ∗
41 (j3 ∗ 2 + 1) ∗
42 (j4 ∗ 2 + 1)) ∗ n
43 dt ∗∗ 3 ∗ n
44 C((j4 , j3 , j2 , j1) , (0, 1, 0, 0)) / 32
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 C0100
52 """
53 return C0100(∗ self .args , ∗∗hints)
Listing 59: Calculation of the Fourier{Legendre coe cients C
0010
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C0010(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 5
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
Electronic Journal. http://diffjournal.spbu.ru/ 294Differential Equations and Control Processes, N. 1, 2021
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C0010
27 calculated value or symbolic expression
28 """
29 j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(j4 , Number) and
35 isinstance(dt , Number)):
36 return super(C0010, cls ). new (cls , ∗args , ∗∗kwargs)
37
38 return sqrt(
39 (j1 ∗ 2 + 1) ∗
40 (j2 ∗ 2 + 1) ∗
41 (j3 ∗ 2 + 1) ∗
42 (j4 ∗ 2 + 1)) ∗ n
43 dt ∗∗ 3 ∗ n
44 C((j4 , j3 , j2 , j1) , (0, 0, 1, 0)) / 32
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 C0010
52 """
53 return C0010(∗ self .args , ∗∗hints)
Listing 60: Calculation of the Fourier{Legendre coe cients C
0001
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Function , Number
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C0001(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 5
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
Electronic Journal. http://diffjournal.spbu.ru/ 295Differential Equations and Control Processes, N. 1, 2021
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C0001
27 calculated value or symbolic expression
28 """
29 j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(j4 , Number) and
35 isinstance(dt , Number)):
36 return super(C0001, cls ). new (cls , ∗args , ∗∗kwargs)
37
38 return sqrt(
39 (j1 ∗ 2 + 1) ∗
40 (j2 ∗ 2 + 1) ∗
41 (j3 ∗ 2 + 1) ∗
42 (j4 ∗ 2 + 1)) ∗ n
43 dt ∗∗ 3 ∗ n
44 C((j4 , j3 , j2 , j1) , (0, 0, 0, 1)) / 32
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 C0001
52 """
53 return C0001(∗ self .args , ∗∗hints)
Listing 61: Calculation of the Fourier{Legendre coe cients C
000000
j
6
j
5
j
4
j
3
j
2
j
1
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
6
7
8 class C000000(Function):
9 """
10 Gives the Fourier−Legendre coefficient with requested indices and weights
11 """
12 nargs = 7
13
Electronic Journal. http://diffjournal.spbu.ru/ 296Differential Equations and Control Processes, N. 1, 2021
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates the Fourier−Legendre coefficient object with needed
17 indices and weights and calculates it
18 Parameters
19 ==========
20 indices : tuple
21 requested indices
22 weights: tuple
23 requested weights
24 Returns
25 =======
26 symbolic.Rational or C000000
27 calculated value or symbolic expression
28 """
29 j6 , j5 , j4 , j3 , j2 , j1 , dt = sympify(args)
30
31 if not (isinstance(j1 , Number) and
32 isinstance(j2 , Number) and
33 isinstance(j3 , Number) and
34 isinstance(j4 , Number) and
35 isinstance(j5 , Number) and
36 isinstance(dt , Number)):
37 return super(C000000, cls ). new (cls , ∗args , ∗∗kwargs)
38
39 return sqrt(
40 (j1 ∗ 2 + 1) ∗
41 (j2 ∗ 2 + 1) ∗
42 (j3 ∗ 2 + 1) ∗
43 (j4 ∗ 2 + 1) ∗
44 (j5 ∗ 2 + 1) ∗
45 (j6 ∗ 2 + 1)) ∗ n
46 dt ∗∗ 3 ∗ n
47 C((j6 , j5 , j4 , j3 , j2 , j1) , (0, 0, 0, 0, 0, 0)) / 64
48
49 def doit(self , ∗∗hints):
50 """
51 Tries to expand or calculate function
52 Returns
53 =======
54 C000000
55 """
56 return C000000(∗ self .args , ∗∗hints)
Listing 62: Program entry for generation of new Fourier{Legendre coe cients
1 #!/usr/bin/env python
2 import logging
3 import os
4 from datetime import datetime
5 from multiprocessing import cpu count , Pool
6 from pprint import pprint
7
Electronic Journal. http://diffjournal.spbu.ru/ 297Differential Equations and Control Processes, N. 1, 2021
8 from config import csv , new c portion size
9 from mathematics.sde. nonlinear .new c import thread c , split task
10
11
12 def main() :
13 logging . basicConfig(
14 level=logging .INFO,
15 format="%(asctime)s − %(levelname)s − %(message)s",
16 datefmt="%H:%M:%S"
17 )
18 logger = logging .getLogger( name )
19
20 filename = os.path. join(csv , f"c fdatetime.now() . strftime('%d−%m −%Y %H −%M −%S ')g.csv")
21 logging . info(f"Writing to file ffilenameg")
22
23 tasks = [
24 (((57 , 58) , (57, 58) , (57, 58)) , (0, 0, 0)) ,
25 # (((0, 56) , (0, 56) , (0, 56)) , (0, 0, 0)) ,
26 #
27 # (((0, 15) , (0, 15)) , (0, 1)) ,
28 # (((0, 15) , (0, 15)) , (1, 0)) ,
29 # (((0, 15) , (0, 15) , (0, 15)) , (0, 0, 0, 0)) ,
30 #
31 # (((0, 6) , (0, 6) , (0, 6)) , (0, 0, 1)) ,
32 # (((0, 6) , (0, 6) , (0, 6)) , (0, 1, 0)) ,
33 # (((0, 6) , (0, 6) , (0, 6)) , (1, 0, 0)) ,
34 # (((0, 6) , (0, 6) , (0, 6) , (0, 6) , (0, 6)) , (0, 0, 0, 0, 0)) ,
35 #
36 # (((0, 2) , (0, 2)) , (0, 2)) ,
37 # (((0, 2) , (0, 2)) , (1, 1)) ,
38 # (((0, 2) , (0, 2)) , (2, 0)) ,
39 # (((0, 2) , (0, 2) , (0, 2) , (0, 2)) , (0, 0, 0, 1)) ,
40 # (((0, 2) , (0, 2) , (0, 2) , (0, 2)) , (0, 0, 1, 0)) ,
41 # (((0, 2) , (0, 2) , (0, 2) , (0, 2)) , (0, 1, 0, 0)) ,
42 # (((0, 2) , (0, 2) , (0, 2) , (0, 2)) , (1, 0, 0, 0)) ,
43 # (((0, 2) , (0, 2) , (0, 2) , (0, 2) , (0, 2)) , (0, 0, 0, 0, 0)) ,
44 # (((0, 2) , (0, 2) , (0, 2) , (0, 2) , (0, 2) , (0, 2)) , (0, 0, 0, 0, 0, 0)) ,
45 ]
46
47 with Pool(cpu count()) as p:
48
49 for t in tasks :
50
51 logger . info(f"Running task ftg")
52
53 for chunk in chunks( split task (t) , new c portion size):
54 c = p.map(thread c , chunk)
55 c.append("")
56
57 with open(filename , "a") as f :
58 f . write("nn". join(c))
59 f . close ()
60
61 logger . info(f"The portion of C has been written fchunk[0]g−fchunk[−1]g")
62
Electronic Journal. http://diffjournal.spbu.ru/ 298Differential Equations and Control Processes, N. 1, 2021
63 logger . info("Generation has been done")
64
65
66 def chunks(lst , n):
67 for i in range(0, len( lst ) , n):
68 yield lst [ i : i + n]
69
70
71 if name == " main ":
72 main()
Listing 63: Module for the Fourier{Legendre coe cients generation
1 from mathematics.sde. nonlinear .c import get c
2
3
4 def split task (tasks):
5 c = len(tasks [1])
6
7 if c == 2:
8 return split 2 (tasks)
9
10 if c == 3:
11 return split 3 (tasks)
12
13 if c == 4:
14 return split 4 (tasks)
15
16 if c == 5:
17 return split 5 (tasks)
18
19 if c == 6:
20 return split 6 (tasks)
21
22
23 def split 2 (ranges):
24 return [(( i , j) , ranges [1])
25 for j in range(ranges [0][1][1])
26 for i in range(ranges [0][0][1])
27 if i >= ranges [0][1][0]
28 or j >= ranges [0][0][1]]
29
30
31 def split 3 (ranges):
32 return [(( i , j , k) , ranges [1])
33 for k in range(ranges [0][2][1])
34 for j in range(ranges [0][1][1])
35 for i in range(ranges [0][0][1])
36 if k >= ranges [0][2][0]
37 or j >= ranges [0][1][0]
38 or i >= ranges [0][0][0]]
39
40
Electronic Journal. http://diffjournal.spbu.ru/ 299Differential Equations and Control Processes, N. 1, 2021
41 def split 4 (ranges):
42 return [(( i , j , k, l) , ranges [1])
43 for j in range(∗ranges [0][3])
44 for i in range(∗ranges [0][2])
45 for k in range(∗ranges [0][1])
46 for l in range(∗ranges [0][0])
47 if l >= ranges [0][3][0]
48 or k >= ranges [0][2][0]
49 or j >= ranges [0][1][0]
50 or i >= ranges [0][0][0]]
51
52
53 def split 5 (ranges):
54 return [(( i , j , k, l , m) , ranges [1])
55 for j in range(∗ranges [0][4])
56 for i in range(∗ranges [0][3])
57 for k in range(∗ranges [0][2])
58 for l in range(∗ranges [0][1])
59 for m in range(∗ranges [0][0])
60 if m>= ranges [0][4][0]
61 if l >= ranges [0][3][0]
62 or k >= ranges [0][2][0]
63 or j >= ranges [0][1][0]
64 or i >= ranges [0][0][0]]
65
66
67 def split 6 (ranges):
68 return [(( i , j , k, l , m, n) , ranges [1])
69 for j in range(∗ranges [0][5])
70 for i in range(∗ranges [0][4])
71 for k in range(∗ranges [0][3])
72 for l in range(∗ranges [0][2])
73 for m in range(∗ranges [0][1])
74 for n in range(∗ranges [0][0])
75 if n >= ranges [0][5][0]
76 if m>= ranges [0][4][0]
77 if l >= ranges [0][3][0]
78 or k >= ranges [0][2][0]
79 or j >= ranges [0][1][0]
80 or i >= ranges [0][0][0]]
81
82
83 def thread c(ranges):
84 c = len(ranges [1])
85
86 if c == 2:
87 return gen 2(∗ranges [0] , ranges [1])
88
89 if c == 3:
90 return gen 3(∗ranges [0] , ranges [1])
91
92 if c == 4:
93 return gen 4(∗ranges [0] , ranges [1])
94
95 if c == 5:
Electronic Journal. http://diffjournal.spbu.ru/ 300Differential Equations and Control Processes, N. 1, 2021
96 return gen 5(∗ranges [0] , ranges [1])
97
98 if c == 6:
99 return gen 6(∗ranges [0] , ranges [1])
100
101
102 def gen 2(i , j , w):
103 return f"n"fig:f jg fw[0]g:fw[1]gn";n"f get c ((i , j) , w)gn""
104
105
106 def gen 3(i , j , k, w):
107 return f"n"fig:f jg:fkg fw[0]g:fw[1]g:fw[2]gn";n"f get c ((i , j , k) , w)gn""
108
109
110 def gen 4(i , j , k, l , w):
111 return f"n"fig:f jg:fkg:f lg fw[0]g:fw[1]g:fw[2]g:fw[3]gn";n"f get c ((i , j , k, l) , w)gn""
112
113
114 def gen 5(i , j , k, l , m, w):
115 return f"n"fig:f jg:fkg:f lg:fmg fw[0]g:fw[1]g:fw[2]g:fw[3]g:fw[4]gn";n"f get c ((i , j , k,
l , m) , w)gn""
116
117
118 def gen 6(i , j , k, l , m, n, w):
119 return f"n"fig:f jg:fkg:f lg:fmg fw[0]g:fw[1]g:fw[2]g:fw[3]g:fw[4]g:fw[5]gn";n"f get c ((i ,
j , k, l , m, n) , w)gn""
6.2.2 Source Codes for Supplementary Differential Operators and
Functions
Listing 64: Implementation of the differential operator L
1 from sympy import Add, sympify , Number, diff
2
3 from mathematics.sde. nonlinear .symbolic. operator import Operator
4
5
6 class L(Operator):
7 nargs = 4
8
9 def new (cls , ∗args , ∗∗kwargs):
10 """
11 Creates new L object with given args
12 Parameters
13 ==========
14 args
15 bunch of necessary arguments
16 Returns
17 =======
18 sympy.Expr
Electronic Journal. http://diffjournal.spbu.ru/ 301Differential Equations and Control Processes, N. 1, 2021
19 formula to simplify and substitute
20 """
21 a, b, f , dxs = sympify(args)
22
23 if not ((isinstance(f , Number) or f .has(∗dxs)) and
24 not f .has(Operator) and a. is Matrix):
25 return super(L, cls ). new (cls , ∗args , ∗∗kwargs)
26
27 n = b.shape [0]
28 m = b.shape [1]
29 from sympy.abc import t
30
31 return Add(
32 diff (f , t) ,
33 ∗[a[i , 0] ∗ diff (f , dxs[ i ]) for i in range(n)] ,
34 ∗[0.5 ∗ b[i , j ] ∗ b[k, j ] ∗ diff (f , dxs[ i ] , dxs[k])
35 for j in range(m)
36 for i in range(n)
37 for k in range(n)]
38 )
39
40 def doit(self , ∗∗hints):
41 """
42 Tries to expand or calculate function
43 Returns
44 =======
45 L
46 """
47 return L(∗ self .args , ∗∗hints)
Listing 65: Implementation of the differential operator G
(i)
0
1 from sympy import Add, sympify , Number, diff
2
3 from mathematics.sde. nonlinear .symbolic. operator import Operator
4
5
6 class G(Operator):
7 nargs = 3
8
9 dict = dict()
10
11 def new (cls , ∗args , ∗∗kwargs):
12 """
13 Creates new G object with given args
14 Parameters
15 ==========
16 args
17 bunch of necessary arguments
18 Returns
19 =======
20 sympy.Expr
21 formula to simplify and substitute
Electronic Journal. http://diffjournal.spbu.ru/ 302Differential Equations and Control Processes, N. 1, 2021
22 """
23 c, f , dxs = sympify(args)
24
25 if not ((isinstance(f , Number) or f .has(∗dxs)) and
26 not f .has(Operator)):
27 return super(G, cls ). new (cls , ∗args , ∗∗kwargs)
28
29 return Add(∗[c[i , 0] ∗ diff (f , dxs[ i ])
30 for i in range(len(dxs)) ])
31
32 def doit(self , ∗∗hints):
33 """
34 Tries to expand or calculate function
35 Returns
36 =======
37 G
38 """
39 return G(∗ self .args , ∗∗hints)
Listing 66: Implementation of the function   a(x;t)
1 from sympy import sympify , Matrix , Add
2
3 from mathematics.sde. nonlinear .symbolic.g import G
4 from mathematics.sde. nonlinear .symbolic. operator import Operator
5
6
7 class Aj(Operator):
8 nargs = 4
9
10 def new (cls , ∗args , ∗∗kwargs):
11 """
12 Creates new Aj object with given args
13 Parameters
14 ==========
15 args
16 bunch of necessary arguments
17 Returns
18 =======
19 sympy.Expr
20 formula to simplify and substitute
21 """
22 i , a, b, dxs = sympify(args)
23 n = b.shape [0]
24 m = b.shape [1]
25
26 return Matrix([a[i , 0] −
27 (Add(∗[0.5 ∗ G(b[: , j ] , b[i , j ] , dxs)
28 for j in range(m) ]) )
29 for i in range(n) ])
Listing 67: Implementation of the differential operator
 
L
1 from sympy import sympify , Number, diff , Add
Electronic Journal. http://diffjournal.spbu.ru/ 303Differential Equations and Control Processes, N. 1, 2021
2
3 from mathematics.sde. nonlinear .symbolic. operator import Operator
4
5
6 class Lj(Operator):
7 nargs = 3
8
9 def new (cls , ∗args , ∗∗kwargs):
10 """
11 Creates new Lj object with given args
12 Parameters
13 ==========
14 args
15 bunch of necessary arguments
16 Returns
17 =======
18 sympy.Expr
19 formula to simplify and substitute
20 """
21 a, f , dxs = sympify(args)
22
23 if not (isinstance(f , Number) or (f .has(∗dxs)) and
24 not f .has(Operator)):
25 return super(Lj , cls ). new (cls , ∗args , ∗∗kwargs)
26
27 n = a.shape [0]
28 from sympy.abc import t
29 return Add( diff (f , t) , ∗[a[i , 0] ∗ diff (f , dxs[ i ])
30 for i in range(n) ])
31
32 def doit(self , ∗∗hints):
33 """
34 Tries to expand or calculate function
35 Returns
36 =======
37 Lj
38 """
39 return Lj(∗ self .args , ∗∗hints)
Listing 68: Implementation of the indicator function 1
fi
1
=i
2
g
1 from sympy import sympify , Number, Function
2
3
4 class Ind(Function):
5 """
6 Indicator function
7 """
8 nargs = 2
9
10 def new (cls , ∗args , ∗∗kwargs):
11 """
12 Creates new Ind object with given args
Electronic Journal. http://diffjournal.spbu.ru/ 304Differential Equations and Control Processes, N. 1, 2021
13 Parameters
14 ==========
15 args
16 bunch of necessary arguments
17 Returns
18 =======
19 sympy.Expr
20 formula to simplify and substitute
21 """
22 i1 , i2 = sympify(args)
23
24 if not (isinstance(i1 , Number) and
25 isinstance(i2 , Number)):
26 return super(Ind , cls ). new (cls , ∗args , ∗∗kwargs)
27
28 if i1 == i2 :
29 return 1
30 else :
31 return 0
32
33 def doit(self , ∗∗hints):
34 """
35 Tries to expand or calculate function
36 Returns
37 =======
38 Ind
39 """
40 return Ind(∗ self .args , ∗∗hints)
6.2.3 Source Codes for Iterated It^ o Stochastic Integrals Approxi-
mations Subprograms
Listing 69: Approximation of It^ o stochastic integral I
(i
1
)
(0) 
p+1
; p
1 from math import sqrt
2
3 from sympy import Function , sympify , Number
4
5
6 class I0(Function):
7 """
8 Ito stochastic integral
9 """
10 nargs = 3
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new I0 object with given args
15 Parameters
16 ==========
Electronic Journal. http://diffjournal.spbu.ru/ 305Differential Equations and Control Processes, N. 1, 2021
17 i1 : int
18 integral index
19 dt : float
20 delta time
21 ksi : numpy.ndarray
22 matrix of Gaussian random variables
23 Returns
24 =======
25 sympy.Expr
26 formula to simplify and substitute
27 """
28 i1 , dt , ksi = sympify(args)
29
30 if not isinstance(i1 , Number):
31 return super(I0 , cls ). new (cls , ∗args , ∗∗kwargs)
32
33 return ksi [0 , i1 ] ∗ sqrt(dt)
34
35 def doit(self , ∗∗hints):
36 """
37 Tries to expand or calculate function
38 Returns
39 =======
40 I0
41 """
42 return I0(∗ self .args , ∗∗hints)
Listing 70: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
)
(00) 
p+1
; p
1 from math import sqrt
2
3 from sympy import sympify , Number, Function , Add
4
5 from mathematics.sde. nonlinear .symbolic.ind import Ind
6
7
8 class I00(Function):
9 """
10 Iterated Ito stochastic integral
11 """
12 nargs = 5
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates new I00 object with given args
17 Parameters
18 ==========
19 i1 : int
20 integral index
21 i2 : int
22 integral index
23 q : int
24 amount of terms in approximation of
Electronic Journal. http://diffjournal.spbu.ru/ 306Differential Equations and Control Processes, N. 1, 2021
25 iterated Ito stochastic integral
26 dt : float
27 delta time
28 ksi : numpy.ndarray
29 matrix of Gaussian random variables
30 Returns
31 =======
32 sympy.Expr
33 formula to simplify and substitute
34 """
35 i1 , i2 , q, dt , ksi = sympify(args)
36
37 if not (isinstance(i1 , Number) and
38 isinstance(i2 , Number) and
39 isinstance(q, Number)):
40 return super(I00 , cls ). new (cls , ∗args , ∗∗kwargs)
41
42 return n
43 (ksi [0 , i1 ] ∗ ksi [0 , i2 ] +
44 Add(∗[
45 (ksi [ j1 − 1, i1 ] ∗ ksi [j1 , i2 ] −
46 ksi [j1 , i1 ] ∗ ksi [ j1 − 1, i2 ]) /
47 sqrt(j1 ∗∗ 2 ∗ 4 − 1)
48 for j1 in range(1, q + 1) ]) −
49 Ind(i1 , i2)) ∗ dt / 2
50
51 def doit(self , ∗∗hints):
52 """
53 Tries to expand or calculate function
54 Returns
55 =======
56 I00
57 """
58 return I00(∗ self .args , ∗∗hints)
Listing 71: Approximation of It^ o stochastic integral I
(i
1
)
(1) 
p+1
; p
1 from math import sqrt
2
3 from sympy import Function , sympify , Number
4
5
6 class I1(Function):
7 """
8 Ito stochastic integral
9 """
10 nargs = 3
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new I1 object with given args
15 Parameters
16 ==========
Electronic Journal. http://diffjournal.spbu.ru/ 307Differential Equations and Control Processes, N. 1, 2021
17 i1 : int
18 integral index
19 dt : float
20 delta time
21 ksi : numpy.ndarray
22 matrix of Gaussian random variables
23 Returns
24 =======
25 sympy.Expr
26 formula to simplify and substitute
27 """
28 i1 , dt , ksi = sympify(args)
29
30 if not isinstance(i1 , Number):
31 return super(I1 , cls ). new (cls , ∗args , ∗∗kwargs)
32
33 return −(ksi [0 , i1 ] + ksi [1 , i1 ] / sqrt(3)) ∗ dt ∗∗ 1.5 / 2
34
35 def doit(self , ∗∗hints):
36 """
37 Tries to expand or calculate function
38 Returns
39 =======
40 I1
41 """
42 return I1(∗ self .args , ∗∗hints)
Listing 72: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
)
(000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c000 import C000
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I000(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 6
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I000 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 q : int
Electronic Journal. http://diffjournal.spbu.ru/ 308Differential Equations and Control Processes, N. 1, 2021
25 amount of terms in approximation of
26 iterated Ito stochastic integral
27 dt : float
28 delta time
29 ksi : numpy.ndarray
30 matrix of Gaussian random variables
31 Returns
32 =======
33 sympy.Expr
34 formula to simplify and substitute
35 """
36 i1 , i2 , i3 , q, dt , ksi = sympify(args)
37
38 if not (isinstance(i1 , Number) and
39 isinstance(i2 , Number) and
40 isinstance(i3 , Number) and
41 isinstance(q, Number)):
42 return super(I000 , cls ). new (cls , ∗args , ∗∗kwargs)
43
44 return Add(∗[
45 C000(j3 , j2 , j1 , dt) ∗
46 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
47 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] −
48 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] −
49 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ])
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 I000
60 """
61 return I000(∗ self .args , ∗∗hints)
Listing 73: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
)
(10) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c10 import C10
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I10(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 5
12
13 def new (cls , ∗args , ∗∗kwargs):
Electronic Journal. http://diffjournal.spbu.ru/ 309Differential Equations and Control Processes, N. 1, 2021
14 """
15 Creates new I10 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 q : int
23 amount of terms in approximation of
24 iterated Ito stochastic integral
25 dt : float
26 delta time
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i1 , i2 , q, dt , ksi = sympify(args)
35
36 if not (isinstance(i1 , Number) and
37 isinstance(i2 , Number) and
38 isinstance(q, Number)):
39 return super(I10 , cls ). new (cls , ∗args , ∗∗kwargs)
40
41 return Add(∗[
42 C10(j2 , j1 , dt) ∗
43 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] −
44 Ind(i1 , i2) ∗ Ind(j1 , j2))
45 for j2 in range(q + 1)
46 for j1 in range(q + 1) ])
47
48 def doit(self , ∗∗hints):
49 """
50 Tries to expand or calculate function
51 Returns
52 =======
53 I10
54 """
55 return I10(∗ self .args , ∗∗hints)
Listing 74: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
)
(01) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c01 import C01
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I01(Function):
8 """
Electronic Journal. http://diffjournal.spbu.ru/ 310Differential Equations and Control Processes, N. 1, 2021
9 Iterated Ito stochastic integral
10 """
11 nargs = 5
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I01 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 q : int
23 amount of terms in approximation of
24 iterated Ito stochastic integral
25 dt : float
26 delta time
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i1 , i2 , q, dt , ksi = sympify(args)
35
36 if not (isinstance(i1 , Number) and
37 isinstance(i2 , Number) and
38 isinstance(q, Number)):
39 return super(I01 , cls ). new (cls , ∗args , ∗∗kwargs)
40
41 return Add(∗[
42 C01(j2 , j1 , dt) ∗
43 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] −
44 Ind(i1 , i2) ∗ Ind(j1 , j2))
45 for j2 in range(q + 1)
46 for j1 in range(q + 1) ])
47
48 def doit(self , ∗∗hints):
49 """
50 Tries to expand or calculate function
51 Returns
52 =======
53 I01
54 """
55 return I01(∗ self .args , ∗∗hints)
Listing 75: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
)
(0000) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0000 import C0000
Electronic Journal. http://diffjournal.spbu.ru/ 311Differential Equations and Control Processes, N. 1, 2021
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I0000(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 7
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I0000 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i4 : int
25 integral index
26 q : int
27 amount of terms in approximation of
28 iterated Ito stochastic integral
29 dt : float
30 delta time
31 ksi : numpy.ndarray
32 matrix of Gaussian random variables
33 Returns
34 =======
35 sympy.Expr
36 formula to simplify and substitute
37 """
38 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
39
40 if not (isinstance(i1 , Number) and
41 isinstance(i2 , Number) and
42 isinstance(i3 , Number) and
43 isinstance(i4 , Number) and
44 isinstance(q, Number)):
45 return super(I0000 , cls ). new (cls , ∗args , ∗∗kwargs)
46
47 return Add(∗[
48 C0000(j4 , j3 , j2 , j1 , dt) ∗
49 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
50 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
51 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] −
52 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
53 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] −
54 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] −
55 Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
56 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) +
57 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) +
58 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3))
Electronic Journal. http://diffjournal.spbu.ru/ 312Differential Equations and Control Processes, N. 1, 2021
59 for j4 in range(q + 1)
60 for j3 in range(q + 1)
61 for j2 in range(q + 1)
62 for j1 in range(q + 1) ])
63
64 def doit(self , ∗∗hints):
65 """
66 Tries to expand or calculate function
67 Returns
68 =======
69 I0000
70 """
71 return I0000(∗ self .args , ∗∗hints)
Listing 76: Approximation of It^ o stochastic integral I
(i
1
)
(2) 
p+1
; p
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5
6 class I2(Function):
7 """
8 Ito stochastic integral
9 """
10 nargs = 3
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new I2 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 dt : float
20 delta time
21 ksi : numpy.ndarray
22 matrix of Gaussian random variables
23 Returns
24 =======
25 sympy.Expr
26 formula to simplify and substitute
27 """
28 i1 , dt , ksi = sympify(args)
29
30 if not isinstance(i1 , Number):
31 return super(I2 , cls ). new (cls , ∗args , ∗∗kwargs)
32
33 return (ksi [0 , i1 ] + ksi [1 , i1 ] ∗ sqrt(3) / 2 +
34 ksi [2 , i1 ] / sqrt(5) / 2) ∗ dt ∗∗ 2.5 / 3
35
36 def doit(self , ∗∗hints):
37 """
Electronic Journal. http://diffjournal.spbu.ru/ 313Differential Equations and Control Processes, N. 1, 2021
38 Tries to expand or calculate function
39 Returns
40 =======
41 I2
42 """
43 return I2(∗ self .args , ∗∗hints)
Listing 77: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
)
(100) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c100 import C100
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I100(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 6
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I100 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 q : int
25 amount of terms in approximation of
26 iterated Ito stochastic integral
27 dt : float
28 delta time
29 ksi : numpy.ndarray
30 matrix of Gaussian random variables
31 Returns
32 =======
33 sympy.Expr
34 formula to simplify and substitute
35 """
36 i1 , i2 , i3 , q, dt , ksi = sympify(args)
37
38 if not (isinstance(i1 , Number) and
39 isinstance(i2 , Number) and
40 isinstance(i3 , Number) and
41 isinstance(q, Number)):
42 return super(I100 , cls ). new (cls , ∗args , ∗∗kwargs)
43
44 return Add(∗[
Electronic Journal. http://diffjournal.spbu.ru/ 314Differential Equations and Control Processes, N. 1, 2021
45 C100(j3 , j2 , j1 , dt) ∗
46 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
47 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] −
48 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] −
49 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ])
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 I100
60 """
61 return I100(∗ self .args , ∗∗hints)
Listing 78: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
)
(010) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c010 import C010
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I010(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 6
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I010 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 q : int
25 amount of terms in approximation of
26 iterated Ito stochastic integral
27 dt : float
28 delta time
29 ksi : numpy.ndarray
30 matrix of Gaussian random variables
31 Returns
32 =======
33 sympy.Expr
Electronic Journal. http://diffjournal.spbu.ru/ 315Differential Equations and Control Processes, N. 1, 2021
34 formula to simplify and substitute
35 """
36 i1 , i2 , i3 , q, dt , ksi = sympify(args)
37
38 if not (isinstance(i1 , Number) and
39 isinstance(i2 , Number) and
40 isinstance(i3 , Number) and
41 isinstance(q, Number)):
42 return super(I010 , cls ). new (cls , ∗args , ∗∗kwargs)
43
44 return Add(∗[
45 C010(j3 , j2 , j1 , dt) ∗
46 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
47 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] −
48 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] −
49 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ])
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 I010
60 """
61 return I010(∗ self .args , ∗∗hints)
Listing 79: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
)
(001) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c001 import C001
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I001(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 6
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I001 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
Electronic Journal. http://diffjournal.spbu.ru/ 316Differential Equations and Control Processes, N. 1, 2021
23 integral index
24 q : int
25 amount of terms in approximation of
26 iterated Ito stochastic integral
27 dt : float
28 delta time
29 ksi : numpy.ndarray
30 matrix of Gaussian random variables
31 Returns
32 =======
33 sympy.Expr
34 formula to simplify and substitute
35 """
36 i1 , i2 , i3 , q, dt , ksi = sympify(args)
37
38 if not (isinstance(i1 , Number) and
39 isinstance(i2 , Number) and
40 isinstance(i3 , Number) and
41 isinstance(q, Number)):
42 return super(I001 , cls ). new (cls , ∗args , ∗∗kwargs)
43
44 return Add(∗[
45 C001(j3 , j2 , j1 , dt) ∗
46 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
47 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] −
48 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] −
49 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ])
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 I001
60 """
61 return I001(∗ self .args , ∗∗hints)
Listing 80: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
i
5
)
(00000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c00000 import C00000
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I00000(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 8
Electronic Journal. http://diffjournal.spbu.ru/ 317Differential Equations and Control Processes, N. 1, 2021
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I00000 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i4 : int
25 integral index
26 i5 : int
27 integral index
28 q : int
29 amount of terms in approximation of
30 iterated Ito stochastic integral
31 dt : float
32 delta time
33 ksi : numpy.ndarray
34 matrix of Gaussian random variables
35 Returns
36 =======
37 sympy.Expr
38 formula to simplify and substitute
39 """
40 i1 , i2 , i3 , i4 , i5 , q, dt , ksi = sympify(args)
41
42 if not (isinstance(i1 , Number) and
43 isinstance(i2 , Number) and
44 isinstance(i3 , Number) and
45 isinstance(i4 , Number) and
46 isinstance(i5 , Number) and
47 isinstance(q, Number) and
48 isinstance(dt , Number)):
49 return super(I00000 , cls ). new (cls , ∗args , ∗∗kwargs)
50
51 return Add(∗[
52 C00000(j5 , j4 , j3 , j2 , j1 , dt) ∗
53 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
54 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
55 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
56 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] −
57 Ind(i1 , i5) ∗ Ind(j1 , j5) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
58 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
59 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] −
60 Ind(i2 , i5) ∗ Ind(j2 , j5) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
61 Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j5 , i5 ] −
62 Ind(i3 , i5) ∗ Ind(j3 , j5) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] −
63 Ind(i4 , i5) ∗ Ind(j4 , j5) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] +
64 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j5 , i5 ] +
65 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i5) ∗ Ind(j3 , j5) ∗ ksi [j4 , i4 ] +
66 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i4 , i5) ∗ Ind(j4 , j5) ∗ ksi [j3 , i3 ] +
Electronic Journal. http://diffjournal.spbu.ru/ 318Differential Equations and Control Processes, N. 1, 2021
67 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j5 , i5 ] +
68 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i5) ∗ Ind(j2 , j5) ∗ ksi [j4 , i4 ] +
69 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i4 , i5) ∗ Ind(j4 , j5) ∗ ksi [j2 , i2 ] +
70 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j5 , i5 ] +
71 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i5) ∗ Ind(j2 , j5) ∗ ksi [j3 , i3 ] +
72 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i3 , i5) ∗ Ind(j3 , j5) ∗ ksi [j2 , i2 ] +
73 Ind(i1 , i5) ∗ Ind(j1 , j5) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j4 , i4 ] +
74 Ind(i1 , i5) ∗ Ind(j1 , j5) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j3 , i3 ] +
75 Ind(i1 , i5) ∗ Ind(j1 , j5) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j2 , i2 ] +
76 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ Ind(i4 , i5) ∗ Ind(j4 , j5) ∗ ksi [j1 , i1 ] +
77 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ Ind(i3 , i5) ∗ Ind(j3 , j5) ∗ ksi [j1 , i1 ] +
78 Ind(i2 , i5) ∗ Ind(j2 , j5) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ])
79 for j5 in range(q + 1)
80 for j4 in range(q + 1)
81 for j3 in range(q + 1)
82 for j2 in range(q + 1)
83 for j1 in range(q + 1) ])
84
85 def doit(self , ∗∗hints):
86 """
87 Tries to expand or calculate function
88 Returns
89 =======
90 I00000
91 """
92 return I00000(∗ self .args , ∗∗hints)
Listing 81: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
)
(20) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c20 import C20
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I20(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 5
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I20 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 q : int
23 amount of terms in approximation of
24 iterated Ito stochastic integral
Electronic Journal. http://diffjournal.spbu.ru/ 319Differential Equations and Control Processes, N. 1, 2021
25 dt : float
26 delta time
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i1 , i2 , q, dt , ksi = sympify(args)
35
36 if not (isinstance(i1 , Number) and
37 isinstance(i2 , Number)):
38 return super(I20 , cls ). new (cls , ∗args , ∗∗kwargs)
39
40 return Add(∗[
41 C20(j2 , j1 , dt) ∗
42 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] − Ind(i1 , i2) ∗ Ind(j1 , j2))
43 for j2 in range(q + 1)
44 for j1 in range(q + 1) ])
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 I20
52 """
53 return I20(∗ self .args , ∗∗hints)
Listing 82: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
)
(02) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c02 import C02
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I02(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 5
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I02 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
Electronic Journal. http://diffjournal.spbu.ru/ 320Differential Equations and Control Processes, N. 1, 2021
22 q : int
23 amount of terms in approximation of
24 iterated Ito stochastic integral
25 dt : float
26 delta time
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i1 , i2 , q, dt , ksi = sympify(args)
35
36 if not (isinstance(i1 , Number) and
37 isinstance(i2 , Number)):
38 return super(I02 , cls ). new (cls , ∗args , ∗∗kwargs)
39
40 return Add(∗[
41 C02(j2 , j1 , dt) ∗
42 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] − Ind(i1 , i2) ∗ Ind(j1 , j2))
43 for j2 in range(q + 1)
44 for j1 in range(q + 1) ])
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 I02
52 """
53 return I02(∗ self .args , ∗∗hints)
Listing 83: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
)
(11) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c11 import C11
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I11(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 5
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I11 object with given args
16 Parameters
17 ==========
18 i1 : int
Electronic Journal. http://diffjournal.spbu.ru/ 321Differential Equations and Control Processes, N. 1, 2021
19 integral index
20 i2 : int
21 integral index
22 q : int
23 amount of terms in approximation of
24 iterated Ito stochastic integral
25 dt : float
26 delta time
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i1 , i2 , q, dt , ksi = sympify(args)
35
36 if not (isinstance(i1 , Number) and
37 isinstance(i2 , Number)):
38 return super(I11 , cls ). new (cls , ∗args , ∗∗kwargs)
39
40 return Add(∗[
41 C11(j2 , j1 , dt) ∗
42 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] − Ind(i1 , i2) ∗ Ind(j1 , j2))
43 for j2 in range(q + 1)
44 for j1 in range(q + 1) ])
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 I11
52 """
53 return I11(∗ self .args , ∗∗hints)
Listing 84: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
)
(1000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c1000 import C1000
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I1000(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 7
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I1000 object with given args
Electronic Journal. http://diffjournal.spbu.ru/ 322Differential Equations and Control Processes, N. 1, 2021
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i4 : int
25 integral index
26 q : int
27 amount of terms in approximation of
28 iterated Ito stochastic integral
29 dt : float
30 delta time
31 ksi : numpy.ndarray
32 matrix of Gaussian random variables
33 Returns
34 =======
35 sympy.Expr
36 formula to simplify and substitute
37 """
38 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
39
40 if not (isinstance(i1 , Number) and
41 isinstance(i2 , Number) and
42 isinstance(i3 , Number) and
43 isinstance(i4 , Number) and
44 isinstance(q, Number)):
45 return super(I1000 , cls ). new (cls , ∗args , ∗∗kwargs)
46
47 return Add(∗[
48 C1000(j4 , j3 , j2 , j1 , dt) ∗
49 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
50 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
51 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] −
52 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
53 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] −
54 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] −
55 Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
56 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) +
57 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) +
58 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3))
59 for j4 in range(q + 1)
60 for j3 in range(q + 1)
61 for j2 in range(q + 1)
62 for j1 in range(q + 1) ])
63
64 def doit(self , ∗∗hints):
65 """
66 Tries to expand or calculate function
67 Returns
68 =======
69 I1000
70 """
Electronic Journal. http://diffjournal.spbu.ru/ 323Differential Equations and Control Processes, N. 1, 2021
71 return I1000(∗ self .args , ∗∗hints)
Listing 85: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
)
(0100) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0100 import C0100
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I0100(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 7
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I0100 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i4 : int
25 integral index
26 q : int
27 amount of terms in approximation of
28 iterated Ito stochastic integral
29 dt : float
30 delta time
31 ksi : numpy.ndarray
32 matrix of Gaussian random variables
33 Returns
34 =======
35 sympy.Expr
36 formula to simplify and substitute
37 """
38 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
39
40 if not (isinstance(i1 , Number) and
41 isinstance(i2 , Number) and
42 isinstance(i3 , Number) and
43 isinstance(i4 , Number) and
44 isinstance(q, Number)):
45 return super(I0100 , cls ). new (cls , ∗args , ∗∗kwargs)
46
47 return Add(∗[
48 C0100(j4 , j3 , j2 , j1 , dt) ∗
49 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
Electronic Journal. http://diffjournal.spbu.ru/ 324Differential Equations and Control Processes, N. 1, 2021
50 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
51 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] −
52 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
53 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] −
54 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] −
55 Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
56 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) +
57 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) +
58 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3))
59 for j4 in range(q + 1)
60 for j3 in range(q + 1)
61 for j2 in range(q + 1)
62 for j1 in range(q + 1) ])
63
64 def doit(self , ∗∗hints):
65 """
66 Tries to expand or calculate function
67 Returns
68 =======
69 I0100
70 """
71 return I0100(∗ self .args , ∗∗hints)
Listing 86: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
)
(0010) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0010 import C0010
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I0010(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 7
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I0010 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i3 : int
25 integral index
26 q : int
27 amount of terms in approximation of
28 iterated Ito stochastic integral
Electronic Journal. http://diffjournal.spbu.ru/ 325Differential Equations and Control Processes, N. 1, 2021
29 dt : float
30 delta time
31 ksi : numpy.ndarray
32 matrix of Gaussian random variables
33 Returns
34 =======
35 sympy.Expr
36 formula to simplify and substitute
37 """
38 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
39
40 if not (isinstance(i1 , Number) and
41 isinstance(i2 , Number) and
42 isinstance(i3 , Number) and
43 isinstance(i4 , Number) and
44 isinstance(q, Number)):
45 return super(I0010 , cls ). new (cls , ∗args , ∗∗kwargs)
46
47 return Add(∗[
48 C0010(j4 , j3 , j2 , j1 , dt) ∗
49 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
50 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
51 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] −
52 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
53 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] −
54 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] −
55 Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
56 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) +
57 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) +
58 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3))
59 for j4 in range(q + 1)
60 for j3 in range(q + 1)
61 for j2 in range(q + 1)
62 for j1 in range(q + 1) ])
63
64 def doit(self , ∗∗hints):
65 """
66 Tries to expand or calculate function
67 Returns
68 =======
69 I0010
70 """
71 return I0010(∗ self .args , ∗∗hints)
Listing 87: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
)
(0001) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0001 import C0001
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I0001(Function):
Electronic Journal. http://diffjournal.spbu.ru/ 326Differential Equations and Control Processes, N. 1, 2021
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 7
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I0001 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i4 : int
25 integral index
26 q : int
27 amount of terms in approximation of
28 iterated Ito stochastic integral
29 dt : float
30 delta time
31 ksi : numpy.ndarray
32 matrix of Gaussian random variables
33 Returns
34 =======
35 sympy.Expr
36 formula to simplify and substitute
37 """
38 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
39
40 if not (isinstance(i1 , Number) and
41 isinstance(i2 , Number) and
42 isinstance(i3 , Number) and
43 isinstance(i4 , Number) and
44 isinstance(q, Number)):
45 return super(I0001 , cls ). new (cls , ∗args , ∗∗kwargs)
46
47 return Add(∗[
48 C0001(j4 , j3 , j2 , j1 , dt) ∗
49 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
50 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
51 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] −
52 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] −
53 Ind(i2 , i3) ∗ Ind(j2 , j3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] −
54 Ind(i2 , i4) ∗ Ind(j2 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] −
55 Ind(i3 , i4) ∗ Ind(j3 , j4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
56 Ind(i1 , i2) ∗ Ind(j1 , j2) ∗ Ind(i3 , i4) ∗ Ind(j3 , j4) +
57 Ind(i1 , i3) ∗ Ind(j1 , j3) ∗ Ind(i2 , i4) ∗ Ind(j2 , j4) +
58 Ind(i1 , i4) ∗ Ind(j1 , j4) ∗ Ind(i2 , i3) ∗ Ind(j2 , j3))
59 for j4 in range(q + 1)
60 for j3 in range(q + 1)
61 for j2 in range(q + 1)
62 for j1 in range(q + 1) ])
Electronic Journal. http://diffjournal.spbu.ru/ 327Differential Equations and Control Processes, N. 1, 2021
63
64 def doit(self , ∗∗hints):
65 """
66 Tries to expand or calculate function
67 Returns
68 =======
69 I0001
70 """
71 return I0001(∗ self .args , ∗∗hints)
Listing 88: Approximation of iterated It^ o stochastic integral I
(i
1
i
2
i
3
i
4
i
5
i
6
)
(000000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c000000 import C000000
4 from mathematics.sde. nonlinear .symbolic.ind import Ind
5
6
7 class I000000(Function):
8 """
9 Iterated Ito stochastic integral
10 """
11 nargs = 9
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new I000000 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 i4 : int
25 integral index
26 i5 : int
27 integral index
28 i6 : int
29 integral index
30 q : int
31 amount of terms in approximation of
32 iterated Ito stochastic integral
33 dt : float
34 delta time
35 ksi : numpy.ndarray
36 matrix of Gaussian random variables
37 Returns
38 =======
39 sympy.Expr
40 formula to simplify and substitute
41 """
Electronic Journal. http://diffjournal.spbu.ru/ 328Differential Equations and Control Processes, N. 1, 2021
42 i1 , i2 , i3 , i4 , i5 , i6 , q, dt , ksi = sympify(args)
43
44 if not (isinstance(i1 , Number) and
45 isinstance(i2 , Number) and
46 isinstance(i3 , Number) and
47 isinstance(i4 , Number) and
48 isinstance(i5 , Number) and
49 isinstance(i6 , Number) and
50 isinstance(q, Number) and
51 isinstance(dt , Number)):
52 return super(I000000 , cls ). new (cls , ∗args , ∗∗kwargs)
53
54 return Add(∗[
55 C000000(j6 , j5 , j4 , j3 , j2 , j1 , dt) ∗
56 (ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗
57 ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
58 Ind(j1 , j6) ∗ Ind(i1 , i6) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
59 Ind(j2 , j6) ∗ Ind(i2 , i6) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
60 Ind(j3 , j6) ∗ Ind(i3 , i6) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] −
61 Ind(j4 , j6) ∗ Ind(i4 , i6) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] −
62 Ind(j5 , j6) ∗ Ind(i5 , i6) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
63 Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
64 Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
65 Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
66 Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] ∗ ksi [j3 , i3 ] ∗ ksi [j6 , i6 ] −
67 Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
68 Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
69 Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j6 , i6 ] −
70 Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] −
71 Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] ∗ ksi [j6 , i6 ] −
72 Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j6 , i6 ] +
73 Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] +
74 Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j4 , i4 ] ∗ ksi [j6 , i6 ] +
75 Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j3 , i3 ] ∗ ksi [j6 , i6 ] +
76 Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] +
77 Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ ksi [j4 , i4 ] ∗ ksi [j6 , i6 ] +
78 Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j6 , i6 ] +
79 Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ] +
80 Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ ksi [j3 , i3 ] ∗ ksi [j6 , i6 ] +
81 Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j6 , i6 ] +
82 Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ ksi [j4 , i4 ] ∗ ksi [j6 , i6 ] +
83 Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ ksi [j3 , i3 ] ∗ ksi [j6 , i6 ] +
84 Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j2 , i2 ] ∗ ksi [j6 , i6 ] +
85 Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j6 , i6 ] +
86 Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j6 , i6 ] +
87 Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j6 , i6 ] +
88 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j2 , i2 ] ∗ ksi [j5 , i5 ] +
89 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] +
90 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] +
91 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] +
92 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] +
93 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] +
94 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] +
95 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] +
96 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j5 , i5 ] +
Electronic Journal. http://diffjournal.spbu.ru/ 329Differential Equations and Control Processes, N. 1, 2021
97 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] +
98 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] +
99 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] +
100 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j4 , i4 ] +
101 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
102 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j5 , i5 ] +
103 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] +
104 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ ksi [j2 , i2 ] ∗ ksi [j5 , i5 ] +
105 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] +
106 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
107 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] +
108 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ ksi [j1 , i1 ] ∗ ksi [j5 , i5 ] +
109 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] +
110 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ ksi [j2 , i2 ] ∗ ksi [j5 , i5 ] +
111 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ ksi [j3 , i3 ] ∗ ksi [j5 , i5 ] +
112 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] +
113 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ ksi [j1 , i1 ] ∗ ksi [j3 , i3 ] +
114 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ ksi [j1 , i4 ] ∗ ksi [j1 , i4 ] +
115 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] +
116 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ ksi [j2 , i2 ] ∗ ksi [j4 , i4 ] +
117 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] −
118 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) −
119 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) −
120 Ind(j6 , j1) ∗ Ind(i6 , i1) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) −
121 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) −
122 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) −
123 Ind(j6 , j2) ∗ Ind(i6 , i2) ∗ Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) −
124 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4) −
125 Ind(j6 , j3) ∗ Ind(i6 , i3) ∗ Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) −
126 Ind(j3 , j6) ∗ Ind(i3 , i6) ∗ Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ Ind(j4 , j5) ∗ Ind(i4 , i5) −
127 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j1 , j5) ∗ Ind(i1 , i5) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) −
128 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ Ind(j2 , j5) ∗ Ind(i2 , i5) −
129 Ind(j6 , j4) ∗ Ind(i6 , i4) ∗ Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ Ind(j3 , j5) ∗ Ind(i3 , i5) −
130 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j1 , j4) ∗ Ind(i1 , i4) ∗ Ind(j2 , j3) ∗ Ind(i2 , i3) −
131 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j1 , j2) ∗ Ind(i1 , i2) ∗ Ind(j3 , j4) ∗ Ind(i3 , i4) −
132 Ind(j6 , j5) ∗ Ind(i6 , i5) ∗ Ind(j1 , j3) ∗ Ind(i1 , i3) ∗ Ind(j2 , j4) ∗ Ind(i2 , i4))
133 for j6 in range(q + 1)
134 for j5 in range(q + 1)
135 for j4 in range(q + 1)
136 for j3 in range(q + 1)
137 for j2 in range(q + 1)
138 for j1 in range(q + 1) ])
139
140 def doit(self , ∗∗hints):
141 """
142 Tries to expand or calculate function
143 Returns
144 =======
145 I000000
146 """
147 return I000000(∗ self .args , ∗∗hints)
Electronic Journal. http://diffjournal.spbu.ru/ 330Differential Equations and Control Processes, N. 1, 2021
6.2.4 Source Codes for Iterated Stratonovich Stochastic Integrals
Approximations Subprograms
Listing 89: Approximation of Stratonovich stochastic integral I
 (i
1
)
(0) 
p+1
; p
1 from math import sqrt
2
3 from sympy import Function , sympify , Number
4
5
6 class J0(Function):
7 """
8 Stratonovich stochastic integral
9 """
10 nargs = 3
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J0 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 dt : float
20 delta time
21 ksi : numpy.ndarray
22 matrix of Gaussian random variables
23 Returns
24 =======
25 sympy.Expr
26 formula to simplify and substitute
27 """
28 i1 , dt , ksi = sympify(args)
29
30 if not isinstance(i1 , Number):
31 return super(J0, cls ). new (cls , ∗args , ∗∗kwargs)
32
33 return ksi [0 , i1 ] ∗ sqrt(dt)
34
35 def doit(self , ∗∗hints):
36 """
37 Tries to expand or calculate function
38 Returns
39 =======
40 J0
41 """
42 return J0(∗ self .args , ∗∗hints)
Listing 90: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
)
(00) 
p+1
; p
1 from math import sqrt
Electronic Journal. http://diffjournal.spbu.ru/ 331Differential Equations and Control Processes, N. 1, 2021
2
3 from sympy import sympify , Number, Function , Add
4
5
6 class J00(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 5
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J00 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 q : int
22 amount of terms in approximation of
23 iterated Stratonovich stochastic integral
24 dt : float
25 delta time
26 ksi : numpy.ndarray
27 matrix of Gaussian random variables
28 Returns
29 =======
30 sympy.Expr
31 formula to simplify and substitute
32 """
33 i1 , i2 , q, dt , ksi = sympify(args)
34
35 if not (isinstance(i1 , Number) and
36 isinstance(i2 , Number) and
37 isinstance(q, Number)):
38 return super(J00 , cls ). new (cls , ∗args , ∗∗kwargs)
39
40 return n
41 (ksi [0 , i1 ] ∗ ksi [0 , i2 ] +
42 Add(∗[
43 (ksi [ j1 − 1, i1 ] ∗ ksi [j1 , i2 ] −
44 ksi [j1 , i1 ] ∗ ksi [ j1 − 1, i2 ]) /
45 sqrt(j1 ∗∗ 2 ∗ 4 − 1)
46 for j1 in range(1, q + 1) ]) ) ∗ dt / 2
47
48 def doit(self , ∗∗hints):
49 """
50 Tries to expand or calculate function
51 Returns
52 =======
53 J00
54 """
55 return J00(∗ self .args , ∗∗hints)
Electronic Journal. http://diffjournal.spbu.ru/ 332Differential Equations and Control Processes, N. 1, 2021
Listing 91: Approximation of Stratonovich stochastic integral I
 (i
1
)
(1)T;t
1 from math import sqrt
2
3 from sympy import Function , sympify , Number
4
5
6 class J1(Function):
7 """
8 Stratonovich stochastic integral
9 """
10 nargs = 3
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J1 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 dt : float
20 delta time
21 ksi : numpy.ndarray
22 matrix of Gaussian random variables
23 Returns
24 =======
25 sympy.Expr
26 formula to simplify and substitute
27 """
28 i1 , dt , ksi = sympify(args)
29
30 if not isinstance(i1 , Number):
31 return super(J1, cls ). new (cls , ∗args , ∗∗kwargs)
32
33 return −(ksi [0 , i1 ] + ksi [1 , i1 ] / sqrt(3)) ∗ dt ∗∗ 1.5 / 2
34
35 def doit(self , ∗∗hints):
36 """
37 Tries to expand or calculate function
38 Returns
39 =======
40 J1
41 """
42 return J1(∗ self .args , ∗∗hints)
Listing 92: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
)
(000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c000 import C000
4
5
6 class J000(Function):
7 """
Electronic Journal. http://diffjournal.spbu.ru/ 333Differential Equations and Control Processes, N. 1, 2021
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 6
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J000 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 q : int
24 amount of terms in approximation of
25 iterated Stratonovich stochastic integral
26 dt : float
27 delta time
28 ksi : numpy.ndarray
29 matrix of Gaussian random variables
30 Returns
31 =======
32 sympy.Expr
33 formula to simplify and substitute
34 """
35 i1 , i2 , i3 , q, dt , ksi = sympify(args)
36
37 if not (isinstance(i1 , Number) and
38 isinstance(i2 , Number) and
39 isinstance(i3 , Number) and
40 isinstance(q, Number)):
41 return super(J000 , cls ). new (cls , ∗args , ∗∗kwargs)
42
43 return Add(∗[
44 C000(j3 , j2 , j1 , dt) ∗
45 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ]
46 for j3 in range(q + 1)
47 for j2 in range(q + 1)
48 for j1 in range(q + 1) ])
49
50 def doit(self , ∗∗hints):
51 """
52 Tries to expand or calculate function
53 Returns
54 =======
55 J000
56 """
57 return J000(∗ self .args , ∗∗hints)
Listing 93: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
)
(10) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
Electronic Journal. http://diffjournal.spbu.ru/ 334Differential Equations and Control Processes, N. 1, 2021
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c10 import C10
4
5
6 class J10(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 5
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J10 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 q : int
22 amount of terms in approximation of
23 iterated Stratonovich stochastic integral
24 dt : float
25 delta time
26 ksi : numpy.ndarray
27 matrix of Gaussian random variables
28 Returns
29 =======
30 sympy.Expr
31 formula to simplify and substitute
32 """
33 i1 , i2 , q, dt , ksi = sympify(args)
34
35 if not (isinstance(i1 , Number) and
36 isinstance(i2 , Number) and
37 isinstance(q, Number)):
38 return super(J10 , cls ). new (cls , ∗args , ∗∗kwargs)
39
40 return Add(∗[
41 C10(j2 , j1 , dt) ∗
42 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ]
43 for j2 in range(q + 1)
44 for j1 in range(q + 1) ])
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 J10
52 """
53 return J10(∗ self .args , ∗∗hints)
Electronic Journal. http://diffjournal.spbu.ru/ 335Differential Equations and Control Processes, N. 1, 2021
Listing 94: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
)
(01) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c01 import C01
4
5
6 class J01(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10
11 nargs = 5
12
13 def new (cls , ∗args , ∗∗kwargs):
14 """
15 Creates new J01 object with given args
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 q : int
23 amount of terms in approximation of
24 iterated Stratonovich stochastic integral
25 dt : float
26 delta time
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i1 , i2 , q, dt , ksi = sympify(args)
35
36 if not (isinstance(i1 , Number) and
37 isinstance(i2 , Number) and
38 isinstance(q, Number)):
39 return super(J01 , cls ). new (cls , ∗args , ∗∗kwargs)
40
41 return Add(∗[
42 C01(j2 , j1 , dt) ∗
43 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ]
44 for j2 in range(q + 1)
45 for j1 in range(q + 1) ])
46
47 def doit(self , ∗∗hints):
48 """
49 Tries to expand or calculate function
50 Returns
51 =======
52 J01
53 """
Electronic Journal. http://diffjournal.spbu.ru/ 336Differential Equations and Control Processes, N. 1, 2021
54 return J01(∗ self .args , ∗∗hints)
Listing 95: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
)
(0000) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0000 import C0000
4
5
6 class J0000(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 7
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J0000 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i4 : int
24 integral index
25 q : int
26 amount of terms in approximation of
27 iterated Stratonovich stochastic integral
28 dt : float
29 delta time
30 ksi : numpy.ndarray
31 matrix of Gaussian random variables
32 Returns
33 =======
34 sympy.Expr
35 formula to simplify and substitute
36 """
37 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
38
39 if not (isinstance(i1 , Number) and
40 isinstance(i2 , Number) and
41 isinstance(i3 , Number) and
42 isinstance(i4 , Number) and
43 isinstance(q, Number)):
44 return super(J0000 , cls ). new (cls , ∗args , ∗∗kwargs)
45
46 return Add(∗[
47 C0000(j4 , j3 , j2 , j1 , dt) ∗
48 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ]
49 for j4 in range(q + 1)
Electronic Journal. http://diffjournal.spbu.ru/ 337Differential Equations and Control Processes, N. 1, 2021
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 J0000
60 """
61 return J0000(∗ self .args , ∗∗hints)
Listing 96: Approximation of Stratonovich stochastic integral I
 (i
1
)
(2) 
p+1
; p
1 from math import sqrt
2
3 from sympy import sympify , Number, Function
4
5
6 class J2(Function):
7 """
8 Stratonovich stochastic integral
9 """
10 nargs = 3
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J2 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 dt : float
20 delta time
21 ksi : numpy.ndarray
22 matrix of Gaussian random variables
23 Returns
24 =======
25 sympy.Expr
26 formula to simplify and substitute
27 """
28 i1 , dt , ksi = sympify(args)
29
30 if not isinstance(i1 , Number):
31 return super(J2, cls ). new (cls , ∗args , ∗∗kwargs)
32
33 return (ksi [0 , i1 ] + ksi [1 , i1 ] ∗ sqrt(3) / 2 +
34 ksi [2 , i1 ] / sqrt(5) / 2) ∗ dt ∗∗ 2.5 / 3
35
36 def doit(self , ∗∗hints):
37 """
38 Tries to expand or calculate function
Electronic Journal. http://diffjournal.spbu.ru/ 338Differential Equations and Control Processes, N. 1, 2021
39 Returns
40 =======
41 J2
42 """
43 return J2(∗ self .args , ∗∗hints)
Listing 97: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
)
(100) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c100 import C100
4
5
6 class J100(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 6
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J100 object with given args
15
16 Parameters
17 ==========
18 i1 : int
19 integral index
20 i2 : int
21 integral index
22 i3 : int
23 integral index
24 q : int
25 amount of terms in approximation of
26 iterated Stratonovich stochastic integral
27 dt : float
28 delta time
29 ksi : numpy.ndarray
30 matrix of Gaussian random variables
31 Returns
32 =======
33 sympy.Expr
34 formula to simplify and substitute
35 """
36 i1 , i2 , i3 , q, dt , ksi = sympify(args)
37
38 if not (isinstance(i1 , Number) and
39 isinstance(i2 , Number) and
40 isinstance(i3 , Number) and
41 isinstance(q, Number)):
42 return super(J100 , cls ). new (cls , ∗args , ∗∗kwargs)
43
44 return Add(∗[
45 C100(j3 , j2 , j1 , dt) ∗
Electronic Journal. http://diffjournal.spbu.ru/ 339Differential Equations and Control Processes, N. 1, 2021
46 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ]
47 for j3 in range(q + 1)
48 for j2 in range(q + 1)
49 for j1 in range(q + 1) ])
50
51 def doit(self , ∗∗hints):
52 """
53 Tries to expand or calculate function
54 Returns
55 =======
56 J100
57 """
58 return J100(∗ self .args , ∗∗hints)
Listing 98: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
)
(010) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c010 import C010
4
5
6 class J010(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 6
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J010 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 q : int
24 amount of terms in approximation of
25 iterated Stratonovich stochastic integral
26 dt : float
27 delta time
28 ksi : numpy.ndarray
29 matrix of Gaussian random variables
30 Returns
31 =======
32 sympy.Expr
33 formula to simplify and substitute
34 """
35 i1 , i2 , i3 , q, dt , ksi = sympify(args)
36
37 if not (isinstance(i1 , Number) and
Electronic Journal. http://diffjournal.spbu.ru/ 340Differential Equations and Control Processes, N. 1, 2021
38 isinstance(i2 , Number) and
39 isinstance(i3 , Number) and
40 isinstance(q, Number)):
41 return super(J010 , cls ). new (cls , ∗args , ∗∗kwargs)
42
43 return Add(∗[
44 C010(j3 , j2 , j1 , dt) ∗
45 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ]
46 for j3 in range(q + 1)
47 for j2 in range(q + 1)
48 for j1 in range(q + 1) ])
49
50 def doit(self , ∗∗hints):
51 """
52 Tries to expand or calculate function
53 Returns
54 =======
55 J010
56 """
57 return J010(∗ self .args , ∗∗hints)
Listing 99: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
)
(001) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c001 import C001
4
5
6 class J001(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 6
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J001 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 q : int
24 amount of terms in approximation of
25 iterated Stratonovich stochastic integral
26 dt : float
27 delta time
28 ksi : numpy.ndarray
29 matrix of Gaussian random variables
30 Returns
Electronic Journal. http://diffjournal.spbu.ru/ 341Differential Equations and Control Processes, N. 1, 2021
31 =======
32 sympy.Expr
33 formula to simplify and substitute
34 """
35 i1 , i2 , i3 , q, dt , ksi = sympify(args)
36
37 if not (isinstance(i1 , Number) and
38 isinstance(i2 , Number) and
39 isinstance(i3 , Number) and
40 isinstance(q, Number)):
41 return super(J001 , cls ). new (cls , ∗args , ∗∗kwargs)
42
43 return Add(∗[
44 C001(j3 , j2 , j1 , dt) ∗
45 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ]
46 for j3 in range(q + 1)
47 for j2 in range(q + 1)
48 for j1 in range(q + 1) ])
49
50 def doit(self , ∗∗hints):
51 """
52 Tries to expand or calculate function
53 Returns
54 =======
55 J001
56 """
57 return J001(∗ self .args , ∗∗hints)
Listing 100: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
i
5
)
(00000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c00000 import C00000
4
5
6 class J00000(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 8
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J00000 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i4 : int
Electronic Journal. http://diffjournal.spbu.ru/ 342Differential Equations and Control Processes, N. 1, 2021
24 integral index
25 i5 : int
26 integral index
27 q : int
28 amount of terms in approximation of
29 iterated Stratonovich stochastic integral
30 dt : float
31 delta time
32 ksi : numpy.ndarray
33 matrix of Gaussian random variables
34 Returns
35 =======
36 sympy.Expr
37 formula to simplify and substitute
38 """
39 i1 , i2 , i3 , i4 , i5 , q, dt , ksi = sympify(args)
40
41 if not (isinstance(i1 , Number) and
42 isinstance(i2 , Number) and
43 isinstance(i3 , Number) and
44 isinstance(i4 , Number) and
45 isinstance(i5 , Number) and
46 isinstance(q, Number) and
47 isinstance(dt , Number)):
48 return super(J00000 , cls ). new (cls , ∗args , ∗∗kwargs)
49
50 return Add(∗[
51 C00000(j5 , j4 , j3 , j2 , j1 , dt) ∗
52 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ] ∗ ksi [j5 , i5 ]
53 for j5 in range(q + 1)
54 for j4 in range(q + 1)
55 for j3 in range(q + 1)
56 for j2 in range(q + 1)
57 for j1 in range(q + 1) ])
58
59 def doit(self , ∗∗hints):
60 """
61 Tries to expand or calculate function
62 Returns
63 =======
64 J00000
65 """
66 return J00000(∗ self .args , ∗∗hints)
Listing 101: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
)
(20) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c20 import C20
4
5
6 class J20(Function):
7 """
Electronic Journal. http://diffjournal.spbu.ru/ 343Differential Equations and Control Processes, N. 1, 2021
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 5
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J20 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 q : int
22 amount of terms in approximation of
23 iterated Stratonovich stochastic integral
24 dt : float
25 delta time
26 ksi : numpy.ndarray
27 matrix of Gaussian random variables
28 Returns
29 =======
30 sympy.Expr
31 formula to simplify and substitute
32 """
33 i1 , i2 , q, dt , ksi = sympify(args)
34
35 if not (isinstance(i1 , Number) and
36 isinstance(i2 , Number)):
37 return super(J20 , cls ). new (cls , ∗args , ∗∗kwargs)
38
39 return Add(∗[
40 C20(j2 , j1 , dt) ∗
41 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ]
42 for j2 in range(q + 1)
43 for j1 in range(q + 1) ])
44
45 def doit(self , ∗∗hints):
46 """
47 Tries to expand or calculate function
48 Returns
49 =======
50 J20
51 """
52 return J20(∗ self .args , ∗∗hints)
Listing 102: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
)
(02) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c02 import C02
4
5
Electronic Journal. http://diffjournal.spbu.ru/ 344Differential Equations and Control Processes, N. 1, 2021
6 class J02(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 5
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J02 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 q : int
22 amount of terms in approximation of
23 iterated Stratonovich stochastic integral
24 dt : float
25 delta time
26 ksi : numpy.ndarray
27 matrix of Gaussian random variables
28 Returns
29 =======
30 sympy.Expr
31 formula to simplify and substitute
32 """
33 i1 , i2 , q, dt , ksi = sympify(args)
34
35 if not (isinstance(i1 , Number) and
36 isinstance(i2 , Number)):
37 return super(J02 , cls ). new (cls , ∗args , ∗∗kwargs)
38
39 return Add(∗[
40 C02(j2 , j1 , dt) ∗
41 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ]
42 for j2 in range(q + 1)
43 for j1 in range(q + 1) ])
44
45 def doit(self , ∗∗hints):
46 """
47 Tries to expand or calculate function
48 Returns
49 =======
50 J02
51 """
52 return J02(∗ self .args , ∗∗hints)
Listing 103: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
)
(11) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c11 import C11
Electronic Journal. http://diffjournal.spbu.ru/ 345Differential Equations and Control Processes, N. 1, 2021
4
5
6 class J11(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 5
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J11 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 q : int
22 amount of terms in approximation of
23 iterated Stratonovich stochastic integral
24 dt : float
25 delta time
26 ksi : numpy.ndarray
27 matrix of Gaussian random variables
28 Returns
29 =======
30 sympy.Expr
31 formula to simplify and substitute
32 """
33 i1 , i2 , q, dt , ksi = sympify(args)
34
35 if not (isinstance(i1 , Number) and
36 isinstance(i2 , Number)):
37 return super(J11 , cls ). new (cls , ∗args , ∗∗kwargs)
38
39 return Add(∗[
40 C11(j2 , j1 , dt) ∗
41 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ]
42 for j2 in range(q + 1)
43 for j1 in range(q + 1) ])
44
45 def doit(self , ∗∗hints):
46 """
47 Tries to expand or calculate function
48 Returns
49 =======
50 J11
51 """
52 return J11(∗ self .args , ∗∗hints)
Listing 104: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
)
(1000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
Electronic Journal. http://diffjournal.spbu.ru/ 346Differential Equations and Control Processes, N. 1, 2021
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c1000 import C1000
4
5
6 class J1000(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 7
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J1000 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i4 : int
24 integral index
25 q : int
26 amount of terms in approximation of
27 iterated Stratonovich stochastic integral
28 dt : float
29 delta time
30 ksi : numpy.ndarray
31 matrix of Gaussian random variables
32 Returns
33 =======
34 sympy.Expr
35 formula to simplify and substitute
36 """
37 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
38
39 if not (isinstance(i1 , Number) and
40 isinstance(i2 , Number) and
41 isinstance(i3 , Number) and
42 isinstance(i4 , Number) and
43 isinstance(q, Number)):
44 return super(J1000 , cls ). new (cls , ∗args , ∗∗kwargs)
45
46 return Add(∗[
47 C1000(j4 , j3 , j2 , j1 , dt) ∗
48 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ]
49 for j4 in range(q + 1)
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
Electronic Journal. http://diffjournal.spbu.ru/ 347Differential Equations and Control Processes, N. 1, 2021
57 Returns
58 =======
59 J1000
60 """
61 return J1000(∗ self .args , ∗∗hints)
Listing 105: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
)
(0100) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0100 import C0100
4
5
6 class J0100(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 7
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J0100 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i4 : int
24 integral index
25 q : int
26 amount of terms in approximation of
27 iterated Stratonovich stochastic integral
28 dt : float
29 delta time
30 ksi : numpy.ndarray
31 matrix of Gaussian random variables
32 Returns
33 =======
34 sympy.Expr
35 formula to simplify and substitute
36 """
37 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
38
39 if not (isinstance(i1 , Number) and
40 isinstance(i2 , Number) and
41 isinstance(i3 , Number) and
42 isinstance(i4 , Number) and
43 isinstance(q, Number)):
44 return super(J0100 , cls ). new (cls , ∗args , ∗∗kwargs)
45
Electronic Journal. http://diffjournal.spbu.ru/ 348Differential Equations and Control Processes, N. 1, 2021
46 return Add(∗[
47 C0100(j4 , j3 , j2 , j1 , dt) ∗
48 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ]
49 for j4 in range(q + 1)
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 J0100
60 """
61 return J0100(∗ self .args , ∗∗hints)
Listing 106: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
)
(0010) 
p+1
; p
1 from sympy import Function , sympify , Number, Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0010 import C0010
4
5
6 class J0010(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 7
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J0010 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i3 : int
24 integral index
25 q : int
26 amount of terms in approximation of
27 iterated Stratonovich stochastic integral
28 dt : float
29 delta time
30 ksi : numpy.ndarray
31 matrix of Gaussian random variables
32 Returns
33 =======
34 sympy.Expr
Electronic Journal. http://diffjournal.spbu.ru/ 349Differential Equations and Control Processes, N. 1, 2021
35 formula to simplify and substitute
36 """
37 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
38
39 if not (isinstance(i1 , Number) and
40 isinstance(i2 , Number) and
41 isinstance(i3 , Number) and
42 isinstance(i4 , Number) and
43 isinstance(q, Number)):
44 return super(J0010 , cls ). new (cls , ∗args , ∗∗kwargs)
45
46 return Add(∗[
47 C0010(j4 , j3 , j2 , j1 , dt) ∗
48 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ]
49 for j4 in range(q + 1)
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 J0010
60 """
61 return J0010(∗ self .args , ∗∗hints)
Listing 107: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
)
(0001) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c0001 import C0001
4
5
6 class J0001(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 7
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new J0001 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i4 : int
Electronic Journal. http://diffjournal.spbu.ru/ 350Differential Equations and Control Processes, N. 1, 2021
24 integral index
25 q : int
26 amount of terms in approximation of
27 iterated Stratonovich stochastic integral
28 dt : float
29 delta time
30 ksi : numpy.ndarray
31 matrix of Gaussian random variables
32 Returns
33 =======
34 sympy.Expr
35 formula to simplify and substitute
36 """
37 i1 , i2 , i3 , i4 , q, dt , ksi = sympify(args)
38
39 if not (isinstance(i1 , Number) and
40 isinstance(i2 , Number) and
41 isinstance(i3 , Number) and
42 isinstance(i4 , Number) and
43 isinstance(q, Number)):
44 return super(J0001 , cls ). new (cls , ∗args , ∗∗kwargs)
45
46 return Add(∗[
47 C0001(j4 , j3 , j2 , j1 , dt) ∗
48 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗ ksi [j4 , i4 ]
49 for j4 in range(q + 1)
50 for j3 in range(q + 1)
51 for j2 in range(q + 1)
52 for j1 in range(q + 1) ])
53
54 def doit(self , ∗∗hints):
55 """
56 Tries to expand or calculate function
57 Returns
58 =======
59 J0001
60 """
61 return J0001(∗ self .args , ∗∗hints)
Listing 108: Approximation of iterated Stratonovich stochastic integral I
 (i
1
i
2
i
3
i
4
i
5
i
6
)
(000000) 
p+1
; p
1 from sympy import Function , Number, sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. coefficients .c000000 import C000000
4
5
6 class J000000(Function):
7 """
8 Iterated Stratonovich stochastic integral
9 """
10 nargs = 9
11
12 def new (cls , ∗args , ∗∗kwargs):
Electronic Journal. http://diffjournal.spbu.ru/ 351Differential Equations and Control Processes, N. 1, 2021
13 """
14 Creates new J000000 object with given args
15 Parameters
16 ==========
17 i1 : int
18 integral index
19 i2 : int
20 integral index
21 i3 : int
22 integral index
23 i4 : int
24 integral index
25 i5 : int
26 integral index
27 i6 : int
28 integral index
29 q : int
30 amount of terms in approximation of
31 iterated Stratonovich stochastic integral
32 dt : float
33 delta time
34 ksi : numpy.ndarray
35 matrix of Gaussian random variables
36 Returns
37 =======
38 sympy.Expr
39 formula to simplify and substitute
40 """
41 i1 , i2 , i3 , i4 , i5 , i6 , q, dt , ksi = sympify(args)
42
43 if not (isinstance(i1 , Number) and
44 isinstance(i2 , Number) and
45 isinstance(i3 , Number) and
46 isinstance(i4 , Number) and
47 isinstance(i5 , Number) and
48 isinstance(i6 , Number) and
49 isinstance(q, Number) and
50 isinstance(dt , Number)):
51 return super(J000000 , cls ). new (cls , ∗args , ∗∗kwargs)
52
53 return Add(∗[
54 C000000(j6 , j5 , j4 , j3 , j2 , j1 , dt) ∗
55 ksi [j1 , i1 ] ∗ ksi [j2 , i2 ] ∗ ksi [j3 , i3 ] ∗
56 ksi [j4 , i4 ] ∗ ksi [j5 , i5 ] ∗ ksi [j6 , i6 ]
57 for j6 in range(q + 1)
58 for j5 in range(q + 1)
59 for j4 in range(q + 1)
60 for j3 in range(q + 1)
61 for j2 in range(q + 1)
62 for j1 in range(q + 1) ])
63
64 def doit(self , ∗∗hints):
65 """
66 Tries to expand or calculate function
67 Returns
Electronic Journal. http://diffjournal.spbu.ru/ 352Differential Equations and Control Processes, N. 1, 2021
68 =======
69 J000000
70 """
71 return J000000(∗ self .args , ∗∗hints)
6.2.5 Source Codes for Calculation of the Numbers q; q
1
,:::, q
15
Listing 109: Calculation of the numbers q; q
1
,:::, q
15
1 from mathematics.sde. nonlinear .symbolic. coefficients .c import C
2
3
4 def solve q(i):
5 """
6 Calculates value for iteration of loop
7 Parameters
8 ==========
9 i : int
10 amount of members
11 Returns
12 =======
13 values : float
14 value for iteration of loop that calculates amount of q
15 """
16 return 1 / 4 − 1 / 2 ∗ sum([
17 1 / (4 ∗ j ∗∗ 2 − 1)
18 for j in range(1, i + 1)
19 ])
20
21
22 def solve q1(i):
23 """
24 Calculates value for iteration of loop
25 Parameters
26 ==========
27 i : int
28 amount of members
29 Returns
30 =======
31 values : float
32 value for iteration of loop that calculates amount of q
33 """
34 return 1 / 6 − 1 / 64 ∗ sum([
35 (2 ∗ j1 + 1) ∗
36 (2 ∗ j2 + 1) ∗
37 (2 ∗ j3 + 1) ∗
38 C((j1 , j2 , j3) , (0, 0, 0)) ∗∗ 2
39 for j1 in range(i + 1)
40 for j2 in range(i + 1)
41 for j3 in range(i + 1)
42 ])
Electronic Journal. http://diffjournal.spbu.ru/ 353Differential Equations and Control Processes, N. 1, 2021
43
44
45 def solve q2(i):
46 """
47 Calculates value for iteration of loop
48 Parameters
49 ==========
50 i : int
51 amount of members
52 Returns
53 =======
54 values : float
55 value for iteration of loop that calculates amount of q
56 """
57 return 1 / 4 − 1 / 64 ∗ sum([
58 (2 ∗ j1 + 1) ∗
59 (2 ∗ j2 + 1) ∗
60 (C((j1 , j2) , (0, 1)) ∗∗ 2)
61 for j1 in range(i + 1)
62 for j2 in range(i + 1)
63 ])
64
65
66 def solve q2 optional(i):
67 """
68 Calculates value for iteration of loop
69 Parameters
70 ==========
71 i : int
72 amount of members
73 Returns
74 =======
75 values : float
76 value for iteration of loop that calculates amount of q
77 """
78 return 1 / 12 − 1 / 64 ∗ sum([
79 (2 ∗ j1 + 1) ∗
80 (2 ∗ j2 + 1) ∗
81 (C((j1 , j2) , (1, 0)) ∗∗ 2)
82 for j1 in range(i + 1)
83 for j2 in range(i + 1)
84 ])
85
86
87 def solve q3(i):
88 """
89 Calculates value for iteration of loop
90 Parameters
91 ==========
92 i : int
93 amount of members
94 Returns
95 =======
96 values : float
97 value for iteration of loop that calculates amount of q
Electronic Journal. http://diffjournal.spbu.ru/ 354Differential Equations and Control Processes, N. 1, 2021
98 """
99 return 1 / 24 − 1 / 256 ∗ sum([
100 (2 ∗ j1 + 1) ∗
101 (2 ∗ j2 + 1) ∗
102 (2 ∗ j3 + 1) ∗
103 (2 ∗ j4 + 1) ∗
104 (C((j1 , j2 , j3 , j4) , (0, 0, 0, 0)) ∗∗ 2)
105 for j1 in range(i + 1)
106 for j2 in range(i + 1)
107 for j3 in range(i + 1)
108 for j4 in range(i + 1)
109 ])
110
111
112 def solve q4(i):
113 """
114 Calculates value for iteration of loop
115 Parameters
116 ==========
117 i : int
118 amount of members
119 Returns
120 =======
121 values : float
122 value for iteration of loop that calculates amount of q
123 """
124 return 1 / 120 − 1 / (32 ∗∗ 2) ∗ sum([
125 (2 ∗ j1 + 1) ∗
126 (2 ∗ j2 + 1) ∗
127 (2 ∗ j3 + 1) ∗
128 (2 ∗ j4 + 1) ∗
129 (2 ∗ j5 + 1) ∗
130 (C((j1 , j2 , j3 , j4 , j5) , (0, 0, 0, 0, 0)) ∗∗ 2)
131 for j1 in range(i + 1)
132 for j2 in range(i + 1)
133 for j3 in range(i + 1)
134 for j4 in range(i + 1)
135 for j5 in range(i + 1)
136 ])
137
138
139 def solve q5(i):
140 """
141 Calculates value for iteration of loop
142 Parameters
143 ==========
144 i : int
145 amount of members
146 Returns
147 =======
148 values : float
149 value for iteration of loop that calculates amount of q
150 """
151 return 1 / 60 − 1 / 256 ∗ sum([
152 (2 ∗ j1 + 1) ∗
Electronic Journal. http://diffjournal.spbu.ru/ 355Differential Equations and Control Processes, N. 1, 2021
153 (2 ∗ j2 + 1) ∗
154 (C((j1 , j2) , (2, 0)) ∗∗ 2)
155 for j1 in range(i + 1)
156 for j2 in range(i + 1)
157 ])
158
159
160 def solve q6(i):
161 """
162 Calculates value for iteration of loop
163 Parameters
164 ==========
165 i : int
166 amount of members
167 Returns
168 =======
169 values : float
170 value for iteration of loop that calculates amount of q
171 """
172 return 1 / 18 − 1 / 256 ∗ sum([
173 (2 ∗ j1 + 1) ∗
174 (2 ∗ j2 + 1) ∗
175 (C((j1 , j2) , (1, 1)) ∗∗ 2)
176 for j1 in range(i + 1)
177 for j2 in range(i + 1)
178 ])
179
180
181 def solve q7(i):
182 """
183 Calculates value for iteration of loop
184 Parameters
185 ==========
186 i : int
187 amount of members
188 Returns
189 =======
190 values : float
191 value for iteration of loop that calculates amount of q
192 """
193 return 1 / 6 − 1 / 256 ∗ sum([
194 (2 ∗ j1 + 1) ∗
195 (2 ∗ j2 + 1) ∗
196 (C((j1 , j2) , (0, 2)) ∗∗ 2)
197 for j1 in range(i + 1)
198 for j2 in range(i + 1)
199 ])
200
201
202 def solve q8(i):
203 """
204 Calculates value for iteration of loop
205 Parameters
206 ==========
207 i : int
Electronic Journal. http://diffjournal.spbu.ru/ 356Differential Equations and Control Processes, N. 1, 2021
208 amount of members
209 Returns
210 =======
211 values : float
212 value for iteration of loop that calculates amount of q
213 """
214 return 1 / 10 − 1 / 256 ∗ sum([
215 (2 ∗ j1 + 1) ∗
216 (2 ∗ j2 + 1) ∗
217 (2 ∗ j3 + 1) ∗
218 (C((j1 , j2 , j3) , (0, 0, 1)) ∗∗ 2)
219 for j1 in range(i + 1)
220 for j2 in range(i + 1)
221 for j3 in range(i + 1)
222 ])
223
224
225 def solve q9(i):
226 """
227 Calculates value for iteration of loop
228 Parameters
229 ==========
230 i : int
231 amount of members
232 Returns
233 =======
234 values : float
235 value for iteration of loop that calculates amount of q
236 """
237 return 1 / 20 − 1 / 256 ∗ sum([
238 (2 ∗ j1 + 1) ∗
239 (2 ∗ j2 + 1) ∗
240 (2 ∗ j3 + 1) ∗
241 (C((j1 , j2 , j3) , (0, 1, 0)) ∗∗ 2)
242 for j1 in range(i + 1)
243 for j2 in range(i + 1)
244 for j3 in range(i + 1)
245 ])
246
247
248 def solve q10(i):
249 """
250 Calculates value for iteration of loop
251 Parameters
252 ==========
253 i : int
254 amount of members
255 Returns
256 =======
257 values : float
258 value for iteration of loop that calculates amount of q
259 """
260 return 1 / 60 − 1 / 256 ∗ sum([
261 (2 ∗ j1 + 1) ∗
262 (2 ∗ j2 + 1) ∗
Electronic Journal. http://diffjournal.spbu.ru/ 357Differential Equations and Control Processes, N. 1, 2021
263 (2 ∗ j3 + 1) ∗
264 (C((j1 , j2 , j3) , (1, 0, 0)) ∗∗ 2)
265 for j1 in range(i + 1)
266 for j2 in range(i + 1)
267 for j3 in range(i + 1)
268 ])
269
270
271 def solve q11(i):
272 """
273 Calculates value for iteration of loop
274 Parameters
275 ==========
276 i : int
277 amount of members
278 Returns
279 =======
280 values : float
281 value for iteration of loop that calculates amount of q
282 """
283 return 1 / 36 − 1 / (32 ∗∗ 2) ∗ sum([
284 (2 ∗ j1 + 1) ∗
285 (2 ∗ j2 + 1) ∗
286 (2 ∗ j3 + 1) ∗
287 (2 ∗ j4 + 1) ∗
288 (C((j1 , j2 , j3 , j4) , (0, 0, 0, 1)) ∗∗ 2)
289 for j1 in range(i + 1)
290 for j2 in range(i + 1)
291 for j3 in range(i + 1)
292 for j4 in range(i + 1)
293 ])
294
295
296 def solve q12(i):
297 """
298 Calculates value for iteration of loop
299 Parameters
300 ==========
301 i : int
302 amount of members
303 Returns
304 =======
305 values : float
306 value for iteration of loop that calculates amount of q
307 """
308 return 1 / 60 − 1 / (32 ∗∗ 2) ∗ sum([
309 (2 ∗ j1 + 1) ∗
310 (2 ∗ j2 + 1) ∗
311 (2 ∗ j3 + 1) ∗
312 (2 ∗ j4 + 1) ∗
313 (C((j1 , j2 , j3 , j4) , (0, 0, 1, 0)) ∗∗ 2)
314 for j1 in range(i + 1)
315 for j2 in range(i + 1)
316 for j3 in range(i + 1)
317 for j4 in range(i + 1)
Electronic Journal. http://diffjournal.spbu.ru/ 358Differential Equations and Control Processes, N. 1, 2021
318 ])
319
320
321 def solve q13(i):
322 """
323 Calculates value for iteration of loop
324 Parameters
325 ==========
326 i : int
327 amount of members
328 Returns
329 =======
330 values : float
331 value for iteration of loop that calculates amount of q
332 """
333 return 1 / 120 − 1 / (32 ∗∗ 2) ∗ sum([
334 (2 ∗ j1 + 1) ∗
335 (2 ∗ j2 + 1) ∗
336 (2 ∗ j3 + 1) ∗
337 (2 ∗ j4 + 1) ∗
338 (C((j1 , j2 , j3 , j4) , (0, 1, 0, 0)) ∗∗ 2)
339 for j1 in range(i + 1)
340 for j2 in range(i + 1)
341 for j3 in range(i + 1)
342 for j4 in range(i + 1)
343 ])
344
345
346 def solve q14(i):
347 """
348 Calculates value for iteration of loop
349 Parameters
350 ==========
351 i : int
352 amount of members
353 Returns
354 =======
355 values : float
356 value for iteration of loop that calculates amount of q
357 """
358 return 1 / 360 − 1 / (32 ∗∗ 2) ∗ sum([
359 (2 ∗ j1 + 1) ∗
360 (2 ∗ j2 + 1) ∗
361 (2 ∗ j3 + 1) ∗
362 (2 ∗ j4 + 1) ∗
363 (C((j1 , j2 , j3 , j4) , (1, 0, 0, 0)) ∗∗ 2)
364 for j1 in range(i + 1)
365 for j2 in range(i + 1)
366 for j3 in range(i + 1)
367 for j4 in range(i + 1)
368 ])
369
370
371 def solve q15(i):
372 """
Electronic Journal. http://diffjournal.spbu.ru/ 359Differential Equations and Control Processes, N. 1, 2021
373 Calculates value for iteration of loop
374 Parameters
375 ==========
376 i : int
377 amount of members
378 Returns
379 =======
380 values : float
381 value for iteration of loop that calculates amount of q
382 """
383 return 1 / 720 − 1 / (64 ∗∗ 2) ∗ sum([
384 (2 ∗ j1 + 1) ∗
385 (2 ∗ j2 + 1) ∗
386 (2 ∗ j3 + 1) ∗
387 (2 ∗ j4 + 1) ∗
388 (2 ∗ j5 + 1) ∗
389 (2 ∗ j6 + 1) ∗
390 (C((j1 , j2 , j3 , j4 , j5 , j6) , (0, 0, 0, 0, 0, 0)) ∗∗ 2)
391 for j1 in range(i + 1)
392 for j2 in range(i + 1)
393 for j3 in range(i + 1)
394 for j4 in range(i + 1)
395 for j5 in range(i + 1)
396 for j6 in range(i + 1)
397 ])
398
399
400 solvers = [
401 solve q , solve q1 , solve q2 , solve q3 , solve q8 ,
402 solve q9 , solve q10 , solve q4 , solve q7 , solve q6 ,
403 solve q5 , solve q11 , solve q12 , solve q13 ,
404 solve q14 , solve q15 ,
405 ]
406
407 dt degrees = [
408 [1] ,
409 [2 , 1] ,
410 [3 , 2, 1, 1] ,
411 [4 , 3, 2, 2, 1, 1, 1, 1] ,
412 [5 , 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1] ,
413 ]
414
415 q ranges = [
416 1, 2, 4, 8, 16
417 ]
418
419
420 def loop(dt: float , k: float , degree : int , solver):
421 """
422 Loop that chooses amount of q that provides necessary accuracy
423 Parameters
424 ==========
425 dt : float
426 delta time
427 k : float
Electronic Journal. http://diffjournal.spbu.ru/ 360Differential Equations and Control Processes, N. 1, 2021
428 user chosen coefficient of accuracy
429 degree : int
430 degree of dt depending on q
431 solver : function
432 function that
433 Returns
434 =======
435 i : int
436 amount of q
437 """
438 i = 0
439 while True:
440 if solver(i) <= k ∗ dt ∗∗ degree :
441 break
442 i += 1
443 return i
444
445
446 def get q(dt: float , k: float , r: float):
447 """
448 Iterates solvers and get q values necessary to
449 achieve given accuracy
450 Parameters
451 ==========
452 dt: float
453 integration step
454 k: float
455 user chosen coefficient of accuracy
456 r: float
457 strong numerical scheme order
458 Returns
459 =======
460 qs result : tuple
461 q values
462 """
463 qs result = []
464
465 degree = int(r ∗ 2)
466 range id = degree − 2
467
468 for q id in range(q ranges [ range id ]) :
469 qs result .append(loop(dt , k, dt degrees [ range id ][ q id ] , solvers [ q id ]) )
470
471 return tuple(qs result)
6.2.6 Source Codes for Strong Taylor{It^ o Numerical Schemes with
Convergence Orders 0:5, 1:0, 1:5, 2:0, 2:5, and 3:0 for It^ o SDEs
Listing 110: Euler scheme modeling subprogram
1 import logging
Electronic Journal. http://diffjournal.spbu.ru/ 361Differential Equations and Control Processes, N. 1, 2021
2 from time import time
3
4 import numpy as np
5 from sympy import lambdify , Matrix , symbols , MatrixSymbol , Symbol
6
7 from mathematics.sde. nonlinear .symbolic.schemes. euler import Euler
8
9
10 def euler(y0: np.array , a: Matrix , b: Matrix , times: tuple):
11 """
12 Performs modeling of Euler scheme
13 Parameters
14 ==========
15 y0 : numpy.ndarray
16 initial conditions
17 a : numpy.ndarray
18 vector function a
19 b : numpy.ndarray
20 matrix function b
21 times : tuple
22 integration limits and step
23 Returns
24 =======
25 y : numpy.ndarray
26 vector of solution
27 t : list
28 list of time moments
29 """
30 start time = time()
31
32 logger = logging .getLogger( name )
33
34 logger . info(f"[f(time() − start time) :.3 fg seconds ] Euler start")
35
36 # Ranges
37 n = b.shape [0]
38 m = b.shape [1]
39 t1 = times [0]
40 dt = times [1]
41 t2 = times [2]
42
43 # Defining context
44 args = symbols(f"x1:fn + 1g")
45 ticks = int((t2 − t1) / dt)
46
47 # Symbols
48 sym i , sym t = Symbol("i") , Symbol("t")
49 sym ksi = MatrixSymbol("ksi", 1, m)
50 sym y = Euler(sym i , Matrix(args) , a, b, dt , sym ksi)
51
52 args extended = list ()
53 args extended .extend(args)
54 args extended .extend ([sym t , sym ksi ])
55
56 # Compilation of formulas
Electronic Journal. http://diffjournal.spbu.ru/ 362Differential Equations and Control Processes, N. 1, 2021
57 y compiled = list ()
58 for tr in range(n):
59 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
60
61 logger . info(f"[f(time() − start time) :.3 fg seconds ] Euler subs are finished")
62
63 # Substitution values
64 t = [t1 + i ∗ dt for i in range(ticks)]
65 y = np. zeros ((n, ticks))
66 y[: , 0] = y0[: , 0]
67
68 # Dynamic substitutions with integration
69 for p in range(ticks − 1):
70 values = [∗y[: , p] , t[p] , np.random.randn(1, m)]
71 for tr in range(n):
72 y[tr , p + 1] = y compiled[ tr ](∗ values)
73
74 logger . info(f"[f(time() − start time) :.3 fg seconds ] Euler calculations are finished")
75
76 return y, t
Listing 111: Euler scheme
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. ito . i0 import I0
4
5
6 class Euler(Function):
7 """
8 Euler scheme
9 """
10 nargs = 6
11
12 def new (cls , ∗args , ∗∗kwargs):
13 """
14 Creates new Euler object with given args
15 Parameters
16 ==========
17 i : int
18 component of stochastic process
19 yp : numpy.ndarray
20 initial conditions
21 a : numpy.ndarray
22 algebraic , given in the variables x and t
23 b : numpy.ndarray
24 algebraic , given in the variables x and t
25 dt : float
26 integration step
27 ksi : numpy.ndarray
28 matrix of Gaussian random variables
29 Returns
30 =======
Electronic Journal. http://diffjournal.spbu.ru/ 363Differential Equations and Control Processes, N. 1, 2021
31 sympy.Expr
32 formula to simplify and substitute
33 """
34 i , yp, a, b, dt , ksi = sympify(args)
35 n, m = b.shape[0] , b.shape [1]
36
37 return Add(
38
39 yp[i , 0] , a[i , 0] ∗ dt ,
40
41 ∗[b[i , i1 ] ∗ I0(i1 , dt , ksi)
42 for i1 in range(m)]
43
44 )
45
46 def doit(self , ∗∗hints):
47 """
48 Tries to expand or calculate function
49 Returns
50 =======
51 sympy.Expr
52 """
53 return Euler(∗ self .args , ∗∗hints)
Listing 112: Milstein scheme modeling subprogram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import symbols , MatrixSymbol , Matrix , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. milstein import Milstein
9
10
11 def milstein(y0: np.array , a: Matrix , b: Matrix , k: float , times: tuple):
12 """
13 Performs modeling of Milstein scheme
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 q : tuple
23 amount of independent random variables
24 times : tuple
25 integration limits and step
26 Returns
27 =======
Electronic Journal. http://diffjournal.spbu.ru/ 364Differential Equations and Control Processes, N. 1, 2021
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Milstein start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 1)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 2, m)
57 sym y = Milstein(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Milstein subs are finished")
69
70 # Substitution values
71 t = [t1 + i ∗ dt for i in range(ticks)]
72 y = np. zeros ((n, ticks))
73 y[: , 0] = y0[: , 0]
74
75 # Dynamic substitutions with integration
76 for p in range(ticks − 1):
77 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 2, m)]
78 for tr in range(n):
79 y[tr , p + 1] = y compiled[ tr ](∗ values)
80
81 logger . info(f"[f(time() − start time) :.3 fg seconds ] Milstein calculations are finished"
)
Electronic Journal. http://diffjournal.spbu.ru/ 365Differential Equations and Control Processes, N. 1, 2021
82
83 return y, t
Listing 113: Milstein scheme
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic.g import G
4 from mathematics.sde. nonlinear .symbolic. ito . i0 import I0
5 from mathematics.sde. nonlinear .symbolic. ito . i00 import I00
6
7
8 class Milstein(Function):
9 """
10 Milstein scheme
11 """
12 nargs = 8
13
14 def new (cls , ∗args , ∗∗kwargs):
15 """
16 Creates new Milstein object with given args
17 Parameters
18 ==========
19 i : int
20 component of stochastic process
21 yp : numpy.ndarray
22 initial conditions
23 a : numpy.ndarray
24 algebraic , given in the variables x and t
25 b : numpy.ndarray
26 algebraic , given in the variables x and t
27 dt : float
28 integration step
29 ksi : numpy.ndarray
30 matrix of Gaussian random variables
31 q : tuple
32 amounts of q for integrals approximations
33 Returns
34 =======
35 sympy.Expr
36 formula to simplify and substitute
37 """
38 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
39 n, m = b.shape[0] , b.shape [1]
40
41 return Add(
42
43 yp[i , 0] , a[i , 0] ∗ dt ,
44
45 ∗[b[i , i1 ] ∗ I0(i1 , dt , ksi)
46 for i1 in range(m)] ,
47
48 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
Electronic Journal. http://diffjournal.spbu.ru/ 366Differential Equations and Control Processes, N. 1, 2021
49 I00(i1 , i2 , q[0] , dt , ksi)
50 for i2 in range(m)
51 for i1 in range(m)]
52
53 )
54
55 def doit(self , ∗∗hints):
56 """
57 Tries to expand or calculate function
58 Returns
59 =======
60 sympy.Expr
61 """
62 return Milstein(∗ self .args , ∗∗hints)
Listing 114: Strong Taylor{It^ o scheme with convergence order 1:5 modeling subpro-
gram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import Matrix , symbols , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor ito 1p5 import
StrongTaylorIto1p5
9
10
11 def strong taylor ito 1p5(y0: np.array , a: Matrix , b: Matrix , k: float , times: tuple):
12 """
13 Performs modeling of Strong Taylor−Ito scheme with convergence order 1.5
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
Electronic Journal. http://diffjournal.spbu.ru/ 367Differential Equations and Control Processes, N. 1, 2021
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 1.5 start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 1.5)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 2, m)
57 sym y = StrongTaylorIto1p5(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 1.5 subs are
finished")
69
70 # Substitution values
71 t = [t1 + i ∗ dt for i in range(ticks)]
72 y = np. zeros ((n, ticks))
73 y[: , 0] = y0[: , 0]
74
75 # Dynamic substitutions with integration
76 for p in range(ticks − 1):
77 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 2, m)]
78 for tr in range(n):
79 y[tr , p + 1] = y compiled[ tr ](∗ values)
80
81 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 1.5 calculations
are finished")
82
83 return y, t
Listing 115: Strong Taylor{It^ o scheme with convergence order 1:5
1 from sympy import Function , sympify , Add
Electronic Journal. http://diffjournal.spbu.ru/ 368Differential Equations and Control Processes, N. 1, 2021
2
3 from mathematics.sde. nonlinear .symbolic.g import G
4 from mathematics.sde. nonlinear .symbolic. ito . i0 import I0
5 from mathematics.sde. nonlinear .symbolic. ito . i00 import I00
6 from mathematics.sde. nonlinear .symbolic. ito . i000 import I000
7 from mathematics.sde. nonlinear .symbolic. ito . i1 import I1
8 from mathematics.sde. nonlinear .symbolic. l import L
9
10
11 class StrongTaylorIto1p5(Function):
12 """
13 Strong Taylor−Ito scheme with convergence order 1.5
14 """
15 nargs = 8
16
17 def new (cls , ∗args , ∗∗kwargs):
18 """
19 Creates new StrongTaylorIto1p5 object with given args
20 Parameters
21 ==========
22 i : int
23 component of stochastic process
24 yp : numpy.ndarray
25 initial conditions
26 a : numpy.ndarray
27 algebraic , given in the variables x and t
28 b : numpy.ndarray
29 algebraic , given in the variables x and t
30 dt : float
31 integration step
32 ksi : numpy.ndarray
33 matrix of Gaussian random variables
34 q : tuple
35 amounts of q for stochastic integrals approximations
36 Returns
37 =======
38 sympy.Expr
39 formula to simplify and substitute
40 """
41 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
42 n, m = b.shape[0] , b.shape [1]
43
44 return Add(
45
46 yp[i , 0] , a[i , 0] ∗ dt ,
47
48 ∗[b[i , i1 ] ∗ I0(i1 , dt , ksi)
49 for i1 in range(m)] ,
50
51 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
52 I00(i1 , i2 , q[0] , dt , ksi)
53 for i2 in range(m)
54 for i1 in range(m)] ,
55
56 ∗[G(b[: , i1 ] , a[i , 0] , dxs) ∗
Electronic Journal. http://diffjournal.spbu.ru/ 369Differential Equations and Control Processes, N. 1, 2021
57 (dt ∗ I0(i1 , dt , ksi) + I1(i1 , dt , ksi)) −
58 L(a, b, b[i , i1 ] , dxs) ∗
59 I1(i1 , dt , ksi)
60 for i1 in range(m)] ,
61
62 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
63 I000(i1 , i2 , i3 , q[1] , dt , ksi)
64 for i3 in range(m)
65 for i2 in range(m)
66 for i1 in range(m)] ,
67
68 dt ∗∗ 2 / 2 ∗ L(a, b, a[i , 0] , dxs)
69
70 )
71
72 def doit(self , ∗∗hints):
73 """
74 Tries to expand or calculate function
75 Returns
76 =======
77 sympy.Expr
78 """
79 return StrongTaylorIto1p5(∗ self .args , ∗∗hints)
Listing 116: Strong Taylor{It^ o scheme with convergence order 2:0 modeling subpro-
gram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import symbols , Matrix , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor ito 2p0 import
StrongTaylorIto2p0
9
10
11 def strong taylor ito 2p0(y0: np.array , a: Matrix , b: Matrix , k: float , times: tuple):
12 """
13 Performs modeling of Strong Taylor−Ito scheme with convergence order 2.0
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
Electronic Journal. http://diffjournal.spbu.ru/ 370Differential Equations and Control Processes, N. 1, 2021
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 2.0 start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 2)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 2, m)
57 sym y = StrongTaylorIto2p0(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 2.0 subs are
finished")
69
70 # Substitution values
71 t = [t1 + i ∗ dt for i in range(ticks)]
72 y = np. zeros ((n, ticks))
73 y[: , 0] = y0[: , 0]
74
75 # Dynamic substitutions with integration
76 for p in range(ticks − 1):
77 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 2, m)]
78 for tr in range(n):
79 y[tr , p + 1] = y compiled[ tr ](∗ values)
Electronic Journal. http://diffjournal.spbu.ru/ 371Differential Equations and Control Processes, N. 1, 2021
80
81 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 2.0 calculations
are finished")
82
83 return y, t
Listing 117: Strong Taylor{It^ o scheme with convergence order 2:0
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic.g import G
4 from mathematics.sde. nonlinear .symbolic. ito . i0 import I0
5 from mathematics.sde. nonlinear .symbolic. ito . i00 import I00
6 from mathematics.sde. nonlinear .symbolic. ito . i000 import I000
7 from mathematics.sde. nonlinear .symbolic. ito . i0000 import I0000
8 from mathematics.sde. nonlinear .symbolic. ito . i01 import I01
9 from mathematics.sde. nonlinear .symbolic. ito . i1 import I1
10 from mathematics.sde. nonlinear .symbolic. ito . i10 import I10
11 from mathematics.sde. nonlinear .symbolic. l import L
12
13
14 class StrongTaylorIto2p0(Function):
15 """
16 Strong Taylor−Ito scheme with convergence order 2.0
17 """
18 nargs = 8
19
20 def new (cls , ∗args , ∗∗kwargs):
21 """
22 Creates new StrongTaylorIto2p0 object with given args
23 Parameters
24 ==========
25 i : int
26 component of stochastic process
27 yp : numpy.ndarray
28 initial conditions
29 a : numpy.ndarray
30 algebraic , given in the variables x and t
31 b : numpy.ndarray
32 algebraic , given in the variables x and t
33 dt : float
34 integration step
35 ksi : numpy.ndarray
36 matrix of Gaussian random variables
37 q : tuple
38 amounts of q for stochastic integrals approximations
39 Returns
40 =======
41 sympy.Expr
42 formula to simplify and substitute
43 """
44 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
45 n, m = b.shape[0] , b.shape [1]
Electronic Journal. http://diffjournal.spbu.ru/ 372Differential Equations and Control Processes, N. 1, 2021
46
47 return Add(
48
49 yp[i , 0] , a[i , 0] ∗ dt ,
50
51 ∗[b[i , i1 ] ∗ I0(i1 , dt , ksi)
52 for i1 in range(m)] ,
53
54 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
55 I00(i1 , i2 , q[0] , dt , ksi)
56 for i2 in range(m)
57 for i1 in range(m)] ,
58
59 ∗[G(b[: , i1 ] , a[i , 0] , dxs) ∗
60 (dt ∗ I0(i1 , dt , ksi) + I1(i1 , dt , ksi)) −
61 L(a, b, b[i , i1 ] , dxs) ∗
62 I1(i1 , dt , ksi)
63 for i1 in range(m)] ,
64
65 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
66 I000(i1 , i2 , i3 , q[1] , dt , ksi)
67 for i3 in range(m)
68 for i2 in range(m)
69 for i1 in range(m)] ,
70
71 dt ∗∗ 2 / 2 ∗ L(a, b, a[i , 0] , dxs) ,
72
73 ∗[G(b[: , i1 ] , L(a, b, b[i , i2 ] , dxs) , dxs) ∗
74 (I10(i1 , i2 , q[2] , dt , ksi) − I01(i1 , i2 , q[2] , dt , ksi)) −
75 L(a, b, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) ∗ I10(i1 , i2 , q[2] , dt , ksi) +
76 G(b[: , i1 ] , G(b[: , i2 ] , a[i , 0] , dxs) , dxs) ∗
77 (I01(i1 , i2 , q[2] , dt , ksi) + dt ∗ I00(i1 , i2 , q[0] , dt , ksi))
78 for i2 in range(m)
79 for i1 in range(m)] ,
80
81 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) ∗
82 I0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi)
83 for i4 in range(m)
84 for i3 in range(m)
85 for i2 in range(m)
86 for i1 in range(m)]
87
88 )
89
90 def doit(self , ∗∗hints):
91 """
92 Tries to expand or calculate function
93 Returns
94 =======
95 sympy.Expr
96 """
97 return StrongTaylorIto2p0(∗ self .args , ∗∗hints)
Electronic Journal. http://diffjournal.spbu.ru/ 373Differential Equations and Control Processes, N. 1, 2021
Listing 118: Strong Taylor{It^ o scheme with convergence order 2:5 modeling subpro-
gram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import symbols , Matrix , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor ito 2p5 import
StrongTaylorIto2p5
9
10
11 def strong taylor ito 2p5(y0: np.array , a: Matrix , b: Matrix , k: float , times: tuple):
12 """
13 Performs modeling of Strong Taylor−Ito scheme with convergence order 2.5
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 2.5 start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 2.5)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
Electronic Journal. http://diffjournal.spbu.ru/ 374Differential Equations and Control Processes, N. 1, 2021
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 3, m)
57 sym y = StrongTaylorIto2p5(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 2.5 subs are
finished")
69
70 # Substitution values
71 t = [t1 + i ∗ dt for i in range(ticks)]
72 y = np. zeros ((n, ticks))
73 y[: , 0] = y0[: , 0]
74
75 # Dynamic substitutions with integration
76 for p in range(ticks − 1):
77 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 3, m)]
78 for tr in range(n):
79 y[tr , p + 1] = y compiled[ tr ](∗ values)
80
81 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 2.5 calculations
are finished")
82
83 return y, t
Listing 119: Strong Taylor{It^ o scheme with convergence order 2:5
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic.g import G
4 from mathematics.sde. nonlinear .symbolic. ito . i0 import I0
5 from mathematics.sde. nonlinear .symbolic. ito . i00 import I00
6 from mathematics.sde. nonlinear .symbolic. ito . i000 import I000
7 from mathematics.sde. nonlinear .symbolic. ito . i0000 import I0000
8 from mathematics.sde. nonlinear .symbolic. ito . i00000 import I00000
9 from mathematics.sde. nonlinear .symbolic. ito . i001 import I001
10 from mathematics.sde. nonlinear .symbolic. ito . i01 import I01
11 from mathematics.sde. nonlinear .symbolic. ito . i010 import I010
12 from mathematics.sde. nonlinear .symbolic. ito . i1 import I1
13 from mathematics.sde. nonlinear .symbolic. ito . i10 import I10
14 from mathematics.sde. nonlinear .symbolic. ito . i100 import I100
15 from mathematics.sde. nonlinear .symbolic. ito . i2 import I2
Electronic Journal. http://diffjournal.spbu.ru/ 375Differential Equations and Control Processes, N. 1, 2021
16 from mathematics.sde. nonlinear .symbolic. l import L
17
18
19 class StrongTaylorIto2p5(Function):
20 """
21 Strong Taylor−Ito scheme with convergence order 2.5
22 """
23 nargs = 8
24
25 def new (cls , ∗args , ∗∗kwargs):
26 """
27 Creates new StrongTaylorIto2p5 object with given args
28 Parameters
29 ==========
30 i : int
31 component of stochastic process
32 yp : numpy.ndarray
33 initial conditions
34 a : numpy.ndarray
35 algebraic , given in the variables x and t
36 b : numpy.ndarray
37 algebraic , given in the variables x and t
38 dt : float
39 integration step
40 ksi : numpy.ndarray
41 matrix of Gaussian random variables
42 q : tuple
43 amounts of q for stochastic integrals approximations
44 Returns
45 =======
46 sympy.Expr
47 formula to simplify and substitute
48 """
49 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
50 n, m = b.shape[0] , b.shape [1]
51
52 return Add(
53
54 yp[i , 0] , a[i , 0] ∗ dt ,
55
56 ∗[b[i , i1 ] ∗ I0(i1 , dt , ksi)
57 for i1 in range(m)] ,
58
59 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
60 I00(i1 , i2 , q[0] , dt , ksi)
61 for i2 in range(m)
62 for i1 in range(m)] ,
63
64 ∗[G(b[: , i1 ] , a[i , 0] , dxs) ∗
65 (dt ∗ I0(i1 , dt , ksi) + I1(i1 , dt , ksi)) −
66 L(a, b, b[i , i1 ] , dxs) ∗
67 I1(i1 , dt , ksi)
68 for i1 in range(m)] ,
69
70 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
Electronic Journal. http://diffjournal.spbu.ru/ 376Differential Equations and Control Processes, N. 1, 2021
71 I000(i1 , i2 , i3 , q[1] , dt , ksi)
72 for i3 in range(m)
73 for i2 in range(m)
74 for i1 in range(m)] ,
75
76 dt ∗∗ 2 / 2 ∗ L(a, b, a[i , 0] , dxs) ,
77 ∗[G(b[: , i1 ] , L(a, b, b[i , i2 ] , dxs) , dxs) ∗
78 (I10(i1 , i2 , q[2] , dt , ksi) − I01(i1 , i2 , q[2] , dt , ksi)) −
79 L(a, b, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) ∗ I10(i1 , i2 , q[2] , dt , ksi) +
80 G(b[: , i1 ] , G(b[: , i2 ] , a[i , 0] , dxs) , dxs) ∗
81 (I01(i1 , i2 , q[2] , dt , ksi) + dt ∗ I00(i1 , i2 , q[0] , dt , ksi))
82 for i2 in range(m)
83 for i1 in range(m)] ,
84
85 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) ∗
86 I0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi)
87 for i4 in range(m)
88 for i3 in range(m)
89 for i2 in range(m)
90 for i1 in range(m)] ,
91
92 ∗[G(b[: , i1 ] , L(a, b, a[i , 0] , dxs) , dxs) ∗
93 (I2(i1 , dt , ksi) / 2 + dt ∗ I1(i1 , dt , ksi) + dt ∗∗ 2 / 2 ∗ I0(i1 , dt , ksi)) +
94 L(a, b, L(a, b, b[i , i1 ] , dxs) , dxs) ∗ I2(i1 , dt , ksi) / 2 −
95 L(a, b, G(b[: , i1 ] , a[i , 0] , dxs) , dxs) ∗ (I2(i1 , dt , ksi) + dt ∗ I1(i1 , dt , ksi))
96 for i1 in range(m)] ,
97
98 ∗[G(b[: , i1 ] , L(a, b, G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
99 (I100(i1 , i2 , i3 , q[6] , dt , ksi) − I010(i1 , i2 , i3 , q[5] , dt , ksi)) +
100 G(b[: , i1 ] , G(b[: , i2 ] , L(a, b, b[i , i3 ] , dxs) , dxs) , dxs) ∗
101 (I010(i1 , i2 , i3 , q[5] , dt , ksi) − I001(i1 , i2 , i3 , q[4] , dt , ksi)) +
102 G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , a[i , 0] , dxs) , dxs) , dxs) ∗
103 (dt ∗ I000(i1 , i2 , i3 , q[1] , dt , ksi) + I001(i1 , i2 , i3 , q[4] , dt , ksi)) −
104 L(a, b, G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
105 I100(i1 , i2 , i3 , q[6] , dt , ksi)
106 for i3 in range(m)
107 for i2 in range(m)
108 for i1 in range(m)] ,
109
110 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(
111 b[: , i4 ] , b[i , i5 ] , dxs) , dxs) , dxs) , dxs) ∗
112 I00000(i1 , i2 , i3 , i4 , i5 , q[7] , dt , ksi)
113 for i5 in range(m)
114 for i4 in range(m)
115 for i3 in range(m)
116 for i2 in range(m)
117 for i1 in range(m)] ,
118
119 dt ∗∗ 3 / 6 ∗ L(a, b, L(a, b, a[i , 0] , dxs) , dxs)
120
121 )
122
123 def doit(self , ∗∗hints):
124 """
125 Tries to expand or calculate function
Electronic Journal. http://diffjournal.spbu.ru/ 377Differential Equations and Control Processes, N. 1, 2021
126 Returns
127 =======
128 sympy.Expr
129 """
130 return StrongTaylorIto2p5(∗ self .args , ∗∗hints)
Listing 120: Strong Taylor{It^ o scheme with convergence order 3:0 modeling subpro-
gram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import Matrix , symbols , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor ito 3p0 import
StrongTaylorIto3p0
9
10
11 def strong taylor ito 3p0(y0: np.array , a: Matrix , b: Matrix , k: float , times: tuple):
12 """
13 Performs modeling of Strong Taylor−Ito scheme with convergence order 3.0
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 3.0 start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
Electronic Journal. http://diffjournal.spbu.ru/ 378Differential Equations and Control Processes, N. 1, 2021
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 3)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 3, m)
57 sym y = StrongTaylorIto3p0(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 3.0 subs are
finished")
69
70 # Substitution values
71 t = [t1 + i ∗ dt for i in range(ticks)]
72 y = np. zeros ((n, ticks))
73 y[: , 0] = y0[: , 0]
74
75 # Dynamic substitutions with integration
76 for p in range(ticks − 1):
77 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 3, m)]
78 for tr in range(n):
79 y[tr , p + 1] = y compiled[ tr ](∗ values)
80
81 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Ito 3.0 calculations
are finished")
82
83 return y, t
Listing 121: Strong Taylor{It^ o scheme with convergence order 3:0
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic.g import G
4 from mathematics.sde. nonlinear .symbolic. ito . i0 import I0
5 from mathematics.sde. nonlinear .symbolic. ito . i00 import I00
6 from mathematics.sde. nonlinear .symbolic. ito . i000 import I000
7 from mathematics.sde. nonlinear .symbolic. ito . i0000 import I0000
8 from mathematics.sde. nonlinear .symbolic. ito . i00000 import I00000
Electronic Journal. http://diffjournal.spbu.ru/ 379Differential Equations and Control Processes, N. 1, 2021
9 from mathematics.sde. nonlinear .symbolic. ito . i000000 import I000000
10 from mathematics.sde. nonlinear .symbolic. ito . i0001 import I0001
11 from mathematics.sde. nonlinear .symbolic. ito . i001 import I001
12 from mathematics.sde. nonlinear .symbolic. ito . i0010 import I0010
13 from mathematics.sde. nonlinear .symbolic. ito . i01 import I01
14 from mathematics.sde. nonlinear .symbolic. ito . i010 import I010
15 from mathematics.sde. nonlinear .symbolic. ito . i0100 import I0100
16 from mathematics.sde. nonlinear .symbolic. ito . i02 import I02
17 from mathematics.sde. nonlinear .symbolic. ito . i1 import I1
18 from mathematics.sde. nonlinear .symbolic. ito . i10 import I10
19 from mathematics.sde. nonlinear .symbolic. ito . i100 import I100
20 from mathematics.sde. nonlinear .symbolic. ito . i1000 import I1000
21 from mathematics.sde. nonlinear .symbolic. ito . i11 import I11
22 from mathematics.sde. nonlinear .symbolic. ito . i2 import I2
23 from mathematics.sde. nonlinear .symbolic. ito . i20 import I20
24 from mathematics.sde. nonlinear .symbolic. l import L
25
26
27 class StrongTaylorIto3p0(Function):
28 """
29 Strong Taylor−Ito scheme with convergence order 3.0
30 """
31 nargs = 8
32
33 def new (cls , ∗args , ∗∗kwargs):
34 """
35 Creates new StrongTaylorIto3p0 object with given args
36 Parameters
37 ==========
38 i : int
39 component of stochastic process
40 yp : numpy.ndarray
41 initial conditions
42 a : numpy.ndarray
43 algebraic , given in the variables x and t
44 b : numpy.ndarray
45 algebraic , given in the variables x and t
46 dt : float
47 integration step
48 ksi : numpy.ndarray
49 matrix of Gaussian random variables
50 q : tuple
51 amounts of q for stochastic integrals approximations
52 Returns
53 =======
54 sympy.Expr
55 formula to simplify and substitute
56 """
57 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
58 n, m = b.shape[0] , b.shape [1]
59
60 return Add(
61
62 yp[i , 0] , a[i , 0] ∗ dt ,
63
Electronic Journal. http://diffjournal.spbu.ru/ 380Differential Equations and Control Processes, N. 1, 2021
64 ∗[b[i , i1 ] ∗ I0(i1 , dt , ksi)
65 for i1 in range(m)] ,
66
67 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
68 I00(i1 , i2 , q[0] , dt , ksi)
69 for i2 in range(m)
70 for i1 in range(m)] ,
71
72 ∗[G(b[: , i1 ] , a[i , 0] , dxs) ∗
73 (dt ∗ I0(i1 , dt , ksi) + I1(i1 , dt , ksi)) −
74 L(a, b, b[i , i1 ] , dxs) ∗
75 I1(i1 , dt , ksi)
76 for i1 in range(m)] ,
77
78 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
79 I000(i1 , i2 , i3 , q[1] , dt , ksi)
80 for i3 in range(m)
81 for i2 in range(m)
82 for i1 in range(m)] ,
83
84 dt ∗∗ 2 / 2 ∗ L(a, b, a[i , 0] , dxs) ,
85
86 ∗[G(b[: , i1 ] , L(a, b, b[i , i2 ] , dxs) , dxs) ∗
87 (I10(i1 , i2 , q[2] , dt , ksi) − I01(i1 , i2 , q[2] , dt , ksi)) −
88 L(a, b, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) ∗ I10(i1 , i2 , q[2] , dt , ksi) +
89 G(b[: , i1 ] , G(b[: , i2 ] , a[i , 0] , dxs) , dxs) ∗
90 (I01(i1 , i2 , q[2] , dt , ksi) + dt ∗ I00(i1 , i2 , q[0] , dt , ksi))
91 for i2 in range(m)
92 for i1 in range(m)] ,
93
94 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) ∗
95 I0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi)
96 for i4 in range(m)
97 for i3 in range(m)
98 for i2 in range(m)
99 for i1 in range(m)] ,
100
101 ∗[G(b[: , i1 ] , L(a, b, a[i , 0] , dxs) , dxs) ∗
102 (I2(i1 , dt , ksi) / 2 + dt ∗ I1(i1 , dt , ksi) + dt ∗∗ 2 / 2 ∗ I0(i1 , dt , ksi)) +
103 L(a, b, L(a, b, b[i , i1 ] , dxs) , dxs) ∗ I2(i1 , dt , ksi) / 2 −
104 L(a, b, G(b[: , i1 ] , a[i , 0] , dxs) , dxs) ∗ (I2(i1 , dt , ksi) + dt ∗ I1(i1 , dt , ksi))
105 for i1 in range(m)] ,
106
107 ∗[G(b[: , i1 ] , L(a, b, G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
108 (I100(i1 , i2 , i3 , q[6] , dt , ksi) − I010(i1 , i2 , i3 , q[5] , dt , ksi)) +
109 G(b[: , i1 ] , G(b[: , i2 ] , L(a, b, b[i , i3 ] , dxs) , dxs) , dxs) ∗
110 (I010(i1 , i2 , i3 , q[5] , dt , ksi) − I001(i1 , i2 , i3 , q[4] , dt , ksi)) +
111 G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , a[i , 0] , dxs) , dxs) , dxs) ∗
112 (dt ∗ I000(i1 , i2 , i3 , q[1] , dt , ksi) + I001(i1 , i2 , i3 , q[4] , dt , ksi)) −
113 L(a, b, G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
114 I100(i1 , i2 , i3 , q[6] , dt , ksi)
115 for i3 in range(m)
116 for i2 in range(m)
117 for i1 in range(m)] ,
118
Electronic Journal. http://diffjournal.spbu.ru/ 381Differential Equations and Control Processes, N. 1, 2021
119 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(
120 b[: , i4 ] , b[i , i5 ] , dxs) , dxs) , dxs) , dxs) ∗
121 I00000(i1 , i2 , i3 , i4 , i5 , q[7] , dt , ksi)
122 for i5 in range(m)
123 for i4 in range(m)
124 for i3 in range(m)
125 for i2 in range(m)
126 for i1 in range(m)] ,
127
128 dt ∗∗ 3 / 6 ∗ L(a, b, L(a, b, a[i , 0] , dxs) , dxs) ,
129
130 ∗[G(b[: , i1 ] , G(b[: , i2 ] , L(a, b, a[i , 0] , dxs) , dxs) , dxs) ∗
131 (I02(i1 , i2 , q[6] , dt , ksi) / 2 + dt ∗ I01(i1 , i2 , q[2] , dt , ksi) +
132 dt ∗∗ 2 / 2 ∗ I00(i1 , i2 , q[2] , dt , ksi)) +
133 L(a, b, L(a, b, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) , dxs) / 2 ∗
134 I20(i1 , i2 , q[10] , dt , ksi) +
135 G(b[: , i1 ] , L(a, b, G(b[: , i2 ] , a[i , 0] , dxs) , dxs) , dxs) ∗
136 (I11(i1 , i2 , q[9] , dt , ksi) − I02(i1 , i2 , q[8] , dt , ksi) +
137 dt ∗ (I10(i1 , i2 , q[2] , dt , ksi) − I01(i1 , i2 , q[2] , dt , ksi))) +
138 L(a, b, G(b[: , i1 ] , L(a, b, b[i , i2 ] , dxs) , dxs) , dxs) ∗
139 (I11(i1 , i2 , q[9] , dt , ksi) − I20(i1 , i2 , q[10] , dt , ksi)) +
140 G(b[: , i1 ] , L(a, b, L(a, b, b[i , i2 ] , dxs) , dxs) , dxs) ∗
141 (I02(i1 , i2 , q[8] , dt , ksi) / 2 + I20(i1 , i2 , q[10] , dt , ksi) / 2 −
142 I11(i1 , i2 , q[9] , dt , ksi)) −
143 L(a, b, G(b[: , i1 ] , G(b[: , i2 ] , a[i , 0] , dxs) , dxs) , dxs) ∗
144 (dt ∗ I10(i1 , i2 , q[2] , dt , ksi) + I11(i1 , i2 , q[9] , dt , ksi))
145 for i2 in range(m)
146 for i1 in range(m)] ,
147
148 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(b[: , i4 ] , a[i , 0] , dxs) , dxs) , dxs) , dxs) ∗
149 (dt ∗ I0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi) +
150 I0001(i1 , i2 , i3 , i4 , q[11] , dt , ksi)) +
151 G(b[: , i1 ] , G(b[: , i2 ] , L(a, b, G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
152 (I0100(i1 , i2 , i3 , i4 , q[13] , dt , ksi) − I0010(i1 , i2 , i3 , i4 , q[12] , dt , ksi)) −
153 L(a, b, G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
154 I1000(i1 , i2 , i3 , i4 , q[14] , dt , ksi) +
155 G(b[: , i1 ] , L(a, b, G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
156 (I1000(i1 , i2 , i3 , i4 , q[14] , dt , ksi) − I0100(i1 , i2 , i3 , i4 , q[13] , dt , ksi)) +
157 G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , L(a, b, b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
158 (I0010(i1 , i2 , i3 , i4 , q[12] , dt , ksi) − I0001(i1 , i2 , i3 , i4 , q[11] , dt , ksi))
159 for i4 in range(m)
160 for i3 in range(m)
161 for i2 in range(m)
162 for i1 in range(m)] ,
163
164 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(b[: , i4 ] , G(
165 b[: , i5 ] , b[i , i6 ] , dxs) , dxs) , dxs) , dxs) , dxs) ∗
166 I000000(i1 , i2 , i3 , i4 , i5 , i6 , q[15] , dt , ksi)
167 for i6 in range(m)
168 for i5 in range(m)
169 for i4 in range(m)
170 for i3 in range(m)
171 for i2 in range(m)
172 for i1 in range(m)]
173
Electronic Journal. http://diffjournal.spbu.ru/ 382Differential Equations and Control Processes, N. 1, 2021
174 )
175
176 def doit(self , ∗∗hints):
177 """
178 Tries to expand or calculate function
179 Returns
180 =======
181 sympy.Expr
182 """
183 return StrongTaylorIto3p0(∗ self .args , ∗∗hints)
6.2.7 Source Codes for Strong Taylor{Stratonovich Numerical
Schemes with Convergence Orders 1:0, 1:5, 2:0, 2:5, and 3:0
for It^ o SDEs
Listing 122: Strong Taylor{Stratonovich scheme with convergence order 1:0 modeling
subprogram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import Matrix , symbols , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor stratonovich 1p0 import
StrongTaylorStratonovich1p0
9
10
11 def strong taylor stratonovich 1p0(y0: np.array , a: Matrix , b: Matrix , k: float , times:
tuple):
12 """
13 Performs modeling of Strong Taylor−Stratonovich scheme with convergence order 1.0
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
Electronic Journal. http://diffjournal.spbu.ru/ 383Differential Equations and Control Processes, N. 1, 2021
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Taylor−Stratonovich 1.0 start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 1)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 2, m)
57 sym y = StrongTaylorStratonovich1p0(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
69 f"Taylor−Stratonovich 1.0 subs are finished")
70
71 # Substitution values
72 t = [t1 + i ∗ dt for i in range(ticks)]
73 y = np. zeros ((n, ticks))
74 y[: , 0] = y0[: , 0]
75
76 # Dynamic substitutions with integration
77 for p in range(ticks − 1):
78 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 2, m)]
79 for tr in range(n):
80 y[tr , p + 1] = y compiled[ tr ](∗ values)
81
82 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
83 f"Taylor−Stratonovich 1.0 calculations are finished")
84
Electronic Journal. http://diffjournal.spbu.ru/ 384Differential Equations and Control Processes, N. 1, 2021
85 return y, t
Listing 123: Strong Taylor{Stratonovich scheme with convergence order 1:0
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. aj import Aj
4 from mathematics.sde. nonlinear .symbolic.g import G
5 from mathematics.sde. nonlinear .symbolic. stratonovich . j0 import J0
6 from mathematics.sde. nonlinear .symbolic. stratonovich . j00 import J00
7
8
9 class StrongTaylorStratonovich1p0(Function):
10 """
11 Strong Taylor−Stratonovich scheme with convergence order 1.0
12 """
13 nargs = 8
14
15 def new (cls , ∗args , ∗∗kwargs):
16 """
17 Creates new StrongTaylorStratonovich1p0 object with given args
18 Parameters
19 ==========
20 i : int
21 component of stochastic process
22 yp : numpy.ndarray
23 initial conditions
24 a : numpy.ndarray
25 algebraic , given in the variables x and t
26 b : numpy.ndarray
27 algebraic , given in the variables x and t
28 dt : float
29 integration step
30 ksi : numpy.ndarray
31 matrix of Gaussian random variables
32 q : tuple
33 amounts of q for stochastic integrals approximations
34 Returns
35 =======
36 sympy.Expr
37 formula to simplify and substitute
38 """
39 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
40 n, m = b.shape[0] , b.shape [1]
41
42 aj = Aj(i , a, b, dxs)
43
44 return Add(
45
46 yp[i , 0] , aj [i , 0] ∗ dt ,
47
48 ∗[b[i , i1 ] ∗ J0(i1 , dt , ksi)
49 for i1 in range(m)] ,
Electronic Journal. http://diffjournal.spbu.ru/ 385Differential Equations and Control Processes, N. 1, 2021
50
51 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
52 J00(i1 , i2 , q[0] , dt , ksi)
53 for i2 in range(m)
54 for i1 in range(m)]
55
56 )
57
58 def doit(self , ∗∗hints):
59 """
60 Tries to expand or calculate function
61 Returns
62 =======
63 sympy.Expr
64 """
65 return StrongTaylorStratonovich1p0(∗ self .args , ∗∗hints)
Listing 124: Strong Taylor{Stratonovich scheme with convergence order 1:5 modeling
subprogram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import Matrix , MatrixSymbol , symbols , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor stratonovich 1p5 import
StrongTaylorStratonovich1p5
9
10
11 def strong taylor stratonovich 1p5(y0: np.array , a: Matrix , b: Matrix , k: float , times:
tuple):
12 """
13 Performs modeling of Strong Taylor−Stratonovich scheme with convergence order 1.5
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
Electronic Journal. http://diffjournal.spbu.ru/ 386Differential Equations and Control Processes, N. 1, 2021
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Stratonovich 1.5
start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 1.5)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 2, m)
57 sym y = StrongTaylorStratonovich1p5(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
69 f"Taylor−Stratonovich 1.5 subs are finished")
70
71 # Substitution values
72 t = [t1 + i ∗ dt for i in range(ticks)]
73 y = np. zeros ((n, ticks))
74 y[: , 0] = y0[: , 0]
75
76 # Dynamic substitutions with integration
77 for p in range(ticks − 1):
78 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 2, m)]
79 for tr in range(n):
80 y[tr , p + 1] = y compiled[ tr ](∗ values)
81
82 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
83 f"Taylor−Stratonovich 1.5 calculations are finished")
84
85 return y, t
Electronic Journal. http://diffjournal.spbu.ru/ 387Differential Equations and Control Processes, N. 1, 2021
Listing 125: Strong Taylor{Stratonovich scheme with convergence order 1:5
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. aj import Aj
4 from mathematics.sde. nonlinear .symbolic.g import G
5 from mathematics.sde. nonlinear .symbolic. l import L
6 from mathematics.sde. nonlinear .symbolic. lj import Lj
7 from mathematics.sde. nonlinear .symbolic. stratonovich . j0 import J0
8 from mathematics.sde. nonlinear .symbolic. stratonovich . j00 import J00
9 from mathematics.sde. nonlinear .symbolic. stratonovich . j000 import J000
10 from mathematics.sde. nonlinear .symbolic. stratonovich . j1 import J1
11
12
13 class StrongTaylorStratonovich1p5(Function):
14 """
15 Strong Taylor−Stratonovich scheme with convergence order 1.5
16 """
17 nargs = 8
18
19 def new (cls , ∗args , ∗∗kwargs):
20 """
21 Creates new StrongTaylorStratonovich1p5 object with given args
22 Parameters
23 ==========
24 i : int
25 component of stochastic process
26 yp : numpy.ndarray
27 initial conditions
28 a : numpy.ndarray
29 algebraic , given in the variables x and t
30 b : numpy.ndarray
31 algebraic , given in the variables x and t
32 dt : float
33 integration step
34 ksi : numpy.ndarray
35 matrix of Gaussian random variables
36 q : tuple
37 amounts of q for stochastic integrals approximations
38 Returns
39 =======
40 sympy.Expr
41 formula to simplify and substitute
42 """
43 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
44 n, m = b.shape[0] , b.shape [1]
45
46 aj = Aj(i , a, b, dxs)
47
48 return Add(
49
50 yp[i , 0] , aj [i , 0] ∗ dt ,
51
52 ∗[b[i , i1 ] ∗ J0(i1 , dt , ksi)
53 for i1 in range(m)] ,
Electronic Journal. http://diffjournal.spbu.ru/ 388Differential Equations and Control Processes, N. 1, 2021
54
55 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
56 J00(i1 , i2 , q[0] , dt , ksi)
57 for i2 in range(m)
58 for i1 in range(m)] ,
59
60 ∗[G(b[: , i1 ] , aj [i , 0] , dxs) ∗
61 (dt ∗ J0(i1 , dt , ksi) + J1(i1 , dt , ksi)) −
62 Lj(a, b[i , i1 ] , dxs) ∗
63 J1(i1 , dt , ksi)
64 for i1 in range(m)] ,
65
66 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
67 J000(i1 , i2 , i3 , q[1] , dt , ksi)
68 for i3 in range(m)
69 for i2 in range(m)
70 for i1 in range(m)] ,
71
72 dt ∗∗ 2 / 2 ∗ L(a, b, a[i , 0] , dxs)
73
74 )
75
76 def doit(self , ∗∗hints):
77 """
78 Tries to expand or calculate function
79 Returns
80 =======
81 sympy.Expr
82 """
83 return StrongTaylorStratonovich1p5(∗ self .args , ∗∗hints)
Listing 126: Strong Taylor{Stratonovich scheme with convergence order 2:0 modeling
subprogram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import symbols , Matrix , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor stratonovich 2p0 import
StrongTaylorStratonovich2p0
9
10
11 def strong taylor stratonovich 2p0(y0: np.array , a: Matrix , b: Matrix , k: float , times:
tuple):
12 """
13 Performs modeling of Strong Taylor−Stratonovich scheme with convergence order 2.0
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
Electronic Journal. http://diffjournal.spbu.ru/ 389Differential Equations and Control Processes, N. 1, 2021
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Stratonovich 2.0
start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 2)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 2, m)
57 sym y = StrongTaylorStratonovich2p0(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
69 f"Taylor−Stratonovich 2.0 subs are finished")
70
71 # Substitution values
Electronic Journal. http://diffjournal.spbu.ru/ 390Differential Equations and Control Processes, N. 1, 2021
72 t = [t1 + i ∗ dt for i in range(ticks)]
73 y = np. zeros ((n, ticks))
74 y[: , 0] = y0[: , 0]
75
76 # Dynamic substitutions with integration
77 for p in range(ticks − 1):
78 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 2, m)]
79 for tr in range(n):
80 y[tr , p + 1] = y compiled[ tr ](∗ values)
81
82 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
83 f"Taylor−Stratonovich 2.0 calculations are finished")
84
85 return y, t
Listing 127: Strong Taylor{Stratonovich scheme with convergence order 2:0
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. aj import Aj
4 from mathematics.sde. nonlinear .symbolic.g import G
5 from mathematics.sde. nonlinear .symbolic. lj import Lj
6 from mathematics.sde. nonlinear .symbolic. stratonovich . j0 import J0
7 from mathematics.sde. nonlinear .symbolic. stratonovich . j00 import J00
8 from mathematics.sde. nonlinear .symbolic. stratonovich . j000 import J000
9 from mathematics.sde. nonlinear .symbolic. stratonovich . j0000 import J0000
10 from mathematics.sde. nonlinear .symbolic. stratonovich . j01 import J01
11 from mathematics.sde. nonlinear .symbolic. stratonovich . j1 import J1
12 from mathematics.sde. nonlinear .symbolic. stratonovich . j10 import J10
13
14
15 class StrongTaylorStratonovich2p0(Function):
16 """
17 Strong Taylor−Stratonovich scheme with convergence order 2.0
18 """
19 nargs = 8
20
21 def new (cls , ∗args , ∗∗kwargs):
22 """
23 Creates new StrongTaylorStratonovich2p0 object with given args
24 Parameters
25 ==========
26 i : int
27 component of stochastic process
28 yp : numpy.ndarray
29 initial conditions
30 a : numpy.ndarray
31 algebraic , given in the variables x and t
32 b : numpy.ndarray
33 algebraic , given in the variables x and t
34 dt : float
35 integration step
36 ksi : numpy.ndarray
Electronic Journal. http://diffjournal.spbu.ru/ 391Differential Equations and Control Processes, N. 1, 2021
37 matrix of Gaussian random variables
38 q : tuple
39 amounts of q for stochastic integrals approximations
40 Returns
41 =======
42 sympy.Expr
43 formula to simplify and substitute
44 """
45 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
46 n, m = b.shape[0] , b.shape [1]
47
48 aj = Aj(i , a, b, dxs)
49
50 return Add(
51
52 yp[i , 0] , aj [i , 0] ∗ dt ,
53
54 ∗[b[i , i1 ] ∗ J0(i1 , dt , ksi)
55 for i1 in range(m)] ,
56
57 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
58 J00(i1 , i2 , q[0] , dt , ksi)
59 for i2 in range(m)
60 for i1 in range(m)] ,
61
62 ∗[G(b[: , i1 ] , aj [i , 0] , dxs) ∗
63 (dt ∗ J0(i1 , dt , ksi) + J1(i1 , dt , ksi)) −
64 Lj(a, b[i , i1 ] , dxs) ∗
65 J1(i1 , dt , ksi)
66 for i1 in range(m)] ,
67
68 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
69 J000(i1 , i2 , i3 , q[1] , dt , ksi)
70 for i3 in range(m)
71 for i2 in range(m)
72 for i1 in range(m)] ,
73
74 dt ∗∗ 2 / 2 ∗ Lj(a, aj [i , 0] , dxs) ,
75
76 ∗[G(b[: , i1 ] , Lj(a, b[i , i2 ] , dxs) , dxs) ∗
77 (J10(i1 , i2 , q[2] , dt , ksi) − J01(i1 , i2 , q[2] , dt , ksi)) −
78 Lj(a, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) ∗ J10(i1 , i2 , q[2] , dt , ksi) +
79 G(b[: , i1 ] , G(b[: , i2 ] , aj [i , 0] , dxs) , dxs) ∗
80 (J01(i1 , i2 , q[2] , dt , ksi) + dt ∗ J00(i1 , i2 , q[0] , dt , ksi))
81 for i2 in range(m)
82 for i1 in range(m)] ,
83
84 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) ∗
85 J0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi)
86 for i4 in range(m)
87 for i3 in range(m)
88 for i2 in range(m)
89 for i1 in range(m)]
90
91 )
Electronic Journal. http://diffjournal.spbu.ru/ 392Differential Equations and Control Processes, N. 1, 2021
92
93 def doit(self , ∗∗hints):
94 """
95 Tries to expand or calculate function
96 Returns
97 =======
98 sympy.Expr
99 """
100 return StrongTaylorStratonovich2p0(∗ self .args , ∗∗hints)
Listing 128: Strong Taylor{Stratonovich scheme with convergence order 2:5 modeling
subprogram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import Matrix , symbols , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor stratonovich 2p5 import
StrongTaylorStratonovich2p5
9
10
11 def strong taylor stratonovich 2p5(y0: np.array , a: Matrix , b: Matrix , k: float , times:
tuple):
12 """
13 Performs modeling of Strong Taylor−Stratonovich scheme with convergence order 2.5
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Stratonovich 2.5
start")
Electronic Journal. http://diffjournal.spbu.ru/ 393Differential Equations and Control Processes, N. 1, 2021
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 2.5)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 3, m)
57 sym y = StrongTaylorStratonovich2p5(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
69 f"Taylor−Stratonovich 2.5 subs are finished")
70
71 # Substitution values
72 t = [t1 + i ∗ dt for i in range(ticks)]
73 y = np. zeros ((n, ticks))
74 y[: , 0] = y0[: , 0]
75
76 # Dynamic substitutions with integration
77 for p in range(ticks − 1):
78 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 3, m)]
79 for tr in range(n):
80 y[tr , p + 1] = y compiled[ tr ](∗ values)
81
82 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
83 f"Taylor−Stratonovich 2.5 calculations are finished")
84
85 return y, t
Listing 129: Strong Taylor{Stratonovich scheme with convergence order 2:5
1 from sympy import Function , sympify , Add
2
Electronic Journal. http://diffjournal.spbu.ru/ 394Differential Equations and Control Processes, N. 1, 2021
3 from mathematics.sde. nonlinear .symbolic. aj import Aj
4 from mathematics.sde. nonlinear .symbolic.g import G
5 from mathematics.sde. nonlinear .symbolic. l import L
6 from mathematics.sde. nonlinear .symbolic. lj import Lj
7 from mathematics.sde. nonlinear .symbolic. stratonovich . j0 import J0
8 from mathematics.sde. nonlinear .symbolic. stratonovich . j00 import J00
9 from mathematics.sde. nonlinear .symbolic. stratonovich . j000 import J000
10 from mathematics.sde. nonlinear .symbolic. stratonovich . j0000 import J0000
11 from mathematics.sde. nonlinear .symbolic. stratonovich . j00000 import J00000
12 from mathematics.sde. nonlinear .symbolic. stratonovich . j001 import J001
13 from mathematics.sde. nonlinear .symbolic. stratonovich . j01 import J01
14 from mathematics.sde. nonlinear .symbolic. stratonovich . j010 import J010
15 from mathematics.sde. nonlinear .symbolic. stratonovich . j1 import J1
16 from mathematics.sde. nonlinear .symbolic. stratonovich . j10 import J10
17 from mathematics.sde. nonlinear .symbolic. stratonovich . j100 import J100
18 from mathematics.sde. nonlinear .symbolic. stratonovich . j2 import J2
19
20
21 class StrongTaylorStratonovich2p5(Function):
22 """
23 Strong Taylor−Stratonovich scheme with convergence order 2.5
24 """
25 nargs = 8
26
27 def new (cls , ∗args , ∗∗kwargs):
28 """
29 Creates new StrongTaylorStratonovich2p5 object with given args
30 Parameters
31 ==========
32 i : int
33 component of stochastic process
34 yp : numpy.ndarray
35 initial conditions
36 a : numpy.ndarray
37 algebraic , given in the variables x and t
38 b : numpy.ndarray
39 algebraic , given in the variables x and t
40 dt : float
41 integration step
42 ksi : numpy.ndarray
43 matrix of Gaussian random variables
44 q : tuple
45 amounts of q for stochastic integrals approximations
46 Returns
47 =======
48 sympy.Expr
49 formula to simplify and substitute
50 """
51 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
52 n, m = b.shape[0] , b.shape [1]
53
54 aj = Aj(i , a, b, dxs)
55
56 return Add(
57
Electronic Journal. http://diffjournal.spbu.ru/ 395Differential Equations and Control Processes, N. 1, 2021
58 yp[i , 0] , aj [i , 0] ∗ dt ,
59
60 ∗[b[i , i1 ] ∗ J0(i1 , dt , ksi)
61 for i1 in range(m)] ,
62
63 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
64 J00(i1 , i2 , q[0] , dt , ksi)
65 for i2 in range(m)
66 for i1 in range(m)] ,
67
68 ∗[G(b[: , i1 ] , aj [i , 0] , dxs) ∗
69 (dt ∗ J0(i1 , dt , ksi) + J1(i1 , dt , ksi)) −
70 Lj(a, b[i , i1 ] , dxs) ∗
71 J1(i1 , dt , ksi)
72 for i1 in range(m)] ,
73
74 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
75 J000(i1 , i2 , i3 , q[1] , dt , ksi)
76 for i3 in range(m)
77 for i2 in range(m)
78 for i1 in range(m)] ,
79
80 dt ∗∗ 2 / 2 ∗ Lj(a, aj [i , 0] , dxs) ,
81
82 ∗[G(b[: , i1 ] , Lj(a, b[i , i2 ] , dxs) , dxs) ∗
83 (J10(i1 , i2 , q[2] , dt , ksi) − J01(i1 , i2 , q[2] , dt , ksi)) −
84 Lj(a, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) ∗ J10(i1 , i2 , q[2] , dt , ksi) +
85 G(b[: , i1 ] , G(b[: , i2 ] , aj [i , 0] , dxs) , dxs) ∗
86 (J01(i1 , i2 , q[2] , dt , ksi) + dt ∗ J00(i1 , i2 , q[0] , dt , ksi))
87 for i2 in range(m)
88 for i1 in range(m)] ,
89
90 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) ∗
91 J0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi)
92 for i4 in range(m)
93 for i3 in range(m)
94 for i2 in range(m)
95 for i1 in range(m)] ,
96
97 ∗[G(b[: , i1 ] , Lj(a, aj [i , 0] , dxs) , dxs) ∗
98 (J2(i1 , dt , ksi) / 2 + dt ∗ J1(i1 , dt , ksi) + dt ∗∗ 2 / 2 ∗ J0(i1 , dt , ksi)) +
99 Lj(a, Lj(a, b[i , i1 ] , dxs) , dxs) ∗ J2(i1 , dt , ksi) / 2 −
100 Lj(a, G(b[: , i1 ] , aj [i , 0] , dxs) , dxs) ∗ (J2(i1 , dt , ksi) + dt ∗ J1(i1 , dt , ksi))
101 for i1 in range(m)] ,
102
103 ∗[G(b[: , i1 ] , Lj(a, G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
104 (J100(i1 , i2 , i3 , q[6] , dt , ksi) − J010(i1 , i2 , i3 , q[5] , dt , ksi)) +
105 G(b[: , i1 ] , G(b[: , i2 ] , Lj(a, b[i , i3 ] , dxs) , dxs) , dxs) ∗
106 (J010(i1 , i2 , i3 , q[5] , dt , ksi) − J001(i1 , i2 , i3 , q[4] , dt , ksi)) +
107 G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , aj [i , 0] , dxs) , dxs) , dxs) ∗
108 (dt ∗ J000(i1 , i2 , i3 , q[1] , dt , ksi) + J001(i1 , i2 , i3 , q[4] , dt , ksi)) −
109 Lj(a, G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
110 J100(i1 , i2 , i3 , q[6] , dt , ksi)
111 for i3 in range(m)
112 for i2 in range(m)
Electronic Journal. http://diffjournal.spbu.ru/ 396Differential Equations and Control Processes, N. 1, 2021
113 for i1 in range(m)] ,
114
115 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(
116 b[: , i4 ] , b[i , i5 ] , dxs) , dxs) , dxs) , dxs) ∗
117 J00000(i1 , i2 , i3 , i4 , i5 , q[7] , dt , ksi)
118 for i5 in range(m)
119 for i4 in range(m)
120 for i3 in range(m)
121 for i2 in range(m)
122 for i1 in range(m)] ,
123
124 dt ∗∗ 3 / 6 ∗ L(a, b, L(a, b, a[i , 0] , dxs) , dxs)
125
126 )
127
128 def doit(self , ∗∗hints):
129 """
130 Tries to expand or calculate function
131 Returns
132 =======
133 sympy.Expr
134 """
135 return StrongTaylorStratonovich2p5(∗ self .args , ∗∗hints)
Listing 130: Strong Taylor{Stratonovich scheme with convergence order 3:0 modeling
subprogram
1 import logging
2 from time import time
3
4 import numpy as np
5 from sympy import Matrix , symbols , MatrixSymbol , lambdify
6
7 from mathematics.sde. nonlinear .q import get q
8 from mathematics.sde. nonlinear .symbolic.schemes. strong taylor stratonovich 3p0 import
StrongTaylorStratonovich3p0
9
10
11 def strong taylor stratonovich 3p0(y0: np.array , a: Matrix , b: Matrix , k: float , times:
tuple):
12 """
13 Performs modeling of Strong Taylor−Stratonovich scheme with convergence order 3.0
14 Parameters
15 ==========
16 y0 : numpy.ndarray
17 initial conditions
18 a : numpy.ndarray
19 vector function a
20 b : numpy.ndarray
21 matrix function b
22 k : float
23 precision constant
24 times : tuple
Electronic Journal. http://diffjournal.spbu.ru/ 397Differential Equations and Control Processes, N. 1, 2021
25 integration limits and step
26 Returns
27 =======
28 y : numpy.ndarray
29 vector of solution
30 t : list
31 list of time moments
32 """
33 start time = time()
34
35 logger = logging .getLogger( name )
36
37 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong Taylor−Stratonovich 3.0
start")
38
39 # Ranges
40 n = b.shape [0]
41 m = b.shape [1]
42 t1 = times [0]
43 dt = times [1]
44 t2 = times [2]
45
46 # Defining context
47 args = symbols(f"x1:fn + 1g")
48 ticks = int((t2 − t1) / dt)
49 q = get q(dt , k, 3)
50 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using C = fkg")
51 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using dt = fdtg")
52 logger . info(f"[f(time() − start time) :.3 fg seconds ] Using q = fqg")
53
54 # Symbols
55 sym i , sym t = symbols("i t")
56 sym ksi = MatrixSymbol("ksi", q[0] + 3, m)
57 sym y = StrongTaylorStratonovich3p0(sym i , Matrix(args) , a, b, dt , sym ksi , args , q)
58
59 args extended = list ()
60 args extended .extend(args)
61 args extended .extend ([sym t , sym ksi ])
62
63 # Compilation of formulas
64 y compiled = list ()
65 for tr in range(n):
66 y compiled.append(lambdify(args extended , sym y.subs(sym i , tr) , "numpy"))
67
68 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
69 f"Taylor−Stratonovich 3.0 subs are finished")
70
71 # Substitution values
72 t = [t1 + i ∗ dt for i in range(ticks)]
73 y = np. zeros ((n, ticks))
74 y[: , 0] = y0[: , 0]
75
76 # Dynamic substitutions with integration
77 for p in range(ticks − 1):
78 values = [∗y[: , p] , t[p] , np.random.randn(q[0] + 3, m)]
Electronic Journal. http://diffjournal.spbu.ru/ 398Differential Equations and Control Processes, N. 1, 2021
79 for tr in range(n):
80 y[tr , p + 1] = y compiled[ tr ](∗ values)
81
82 logger . info(f"[f(time() − start time) :.3 fg seconds ] Strong "
83 f"Taylor−Stratonovich 3.0 calculations are finished")
84
85 return y, t
Listing 131: Strong Taylor{Stratonovich scheme with convergence order 3:0
1 from sympy import Function , sympify , Add
2
3 from mathematics.sde. nonlinear .symbolic. aj import Aj
4 from mathematics.sde. nonlinear .symbolic.g import G
5 from mathematics.sde. nonlinear .symbolic. lj import Lj
6 from mathematics.sde. nonlinear .symbolic. stratonovich . j0 import J0
7 from mathematics.sde. nonlinear .symbolic. stratonovich . j00 import J00
8 from mathematics.sde. nonlinear .symbolic. stratonovich . j000 import J000
9 from mathematics.sde. nonlinear .symbolic. stratonovich . j0000 import J0000
10 from mathematics.sde. nonlinear .symbolic. stratonovich . j00000 import J00000
11 from mathematics.sde. nonlinear .symbolic. stratonovich . j000000 import J000000
12 from mathematics.sde. nonlinear .symbolic. stratonovich . j0001 import J0001
13 from mathematics.sde. nonlinear .symbolic. stratonovich . j001 import J001
14 from mathematics.sde. nonlinear .symbolic. stratonovich . j0010 import J0010
15 from mathematics.sde. nonlinear .symbolic. stratonovich . j01 import J01
16 from mathematics.sde. nonlinear .symbolic. stratonovich . j010 import J010
17 from mathematics.sde. nonlinear .symbolic. stratonovich . j0100 import J0100
18 from mathematics.sde. nonlinear .symbolic. stratonovich . j02 import J02
19 from mathematics.sde. nonlinear .symbolic. stratonovich . j1 import J1
20 from mathematics.sde. nonlinear .symbolic. stratonovich . j10 import J10
21 from mathematics.sde. nonlinear .symbolic. stratonovich . j100 import J100
22 from mathematics.sde. nonlinear .symbolic. stratonovich . j1000 import J1000
23 from mathematics.sde. nonlinear .symbolic. stratonovich . j11 import J11
24 from mathematics.sde. nonlinear .symbolic. stratonovich . j2 import J2
25 from mathematics.sde. nonlinear .symbolic. stratonovich . j20 import J20
26
27
28 class StrongTaylorStratonovich3p0(Function):
29 """
30 Strong Taylor−Stratonovich scheme with convergence order 3.0
31 """
32 nargs = 8
33
34 def new (cls , ∗args , ∗∗kwargs):
35 """
36 Creates new StrongTaylorStratonovich3p0 object with given args
37 Parameters
38 ==========
39 i : int
40 component of stochastic process
41 yp : numpy.ndarray
42 initial conditions
43 a : numpy.ndarray
Electronic Journal. http://diffjournal.spbu.ru/ 399Differential Equations and Control Processes, N. 1, 2021
44 algebraic , given in the variables x and t
45 b : numpy.ndarray
46 algebraic , given in the variables x and t
47 dt : float
48 integration step
49 ksi : numpy.ndarray
50 matrix of Gaussian random variables
51 q : tuple
52 amounts of q for stochastic integrals approximations
53 Returns
54 =======
55 sympy.Expr
56 formula to simplify and substitute
57 """
58 i , yp, a, b, dt , ksi , dxs , q = sympify(args)
59 n, m = b.shape[0] , b.shape [1]
60
61 aj = Aj(i , a, b, dxs)
62
63 return Add(
64
65 yp[i , 0] , aj [i , 0] ∗ dt ,
66
67 ∗[b[i , i1 ] ∗ J0(i1 , dt , ksi)
68 for i1 in range(m)] ,
69
70 ∗[G(b[: , i1 ] , b[i , i2 ] , dxs) ∗
71 J00(i1 , i2 , q[0] , dt , ksi)
72 for i2 in range(m)
73 for i1 in range(m)] ,
74
75 ∗[G(b[: , i1 ] , aj [i , 0] , dxs) ∗
76 (dt ∗ J0(i1 , dt , ksi) + J1(i1 , dt , ksi)) −
77 Lj(a, b[i , i1 ] , dxs) ∗
78 J1(i1 , dt , ksi)
79 for i1 in range(m)] ,
80
81 ∗[G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) ∗
82 J000(i1 , i2 , i3 , q[1] , dt , ksi)
83 for i3 in range(m)
84 for i2 in range(m)
85 for i1 in range(m)] ,
86
87 dt ∗∗ 2 / 2 ∗ Lj(a, aj [i , 0] , dxs) ,
88
89 ∗[G(b[: , i1 ] , Lj(a, b[i , i2 ] , dxs) , dxs) ∗
90 (J10(i1 , i2 , q[2] , dt , ksi) − J01(i1 , i2 , q[2] , dt , ksi)) −
91 Lj(a, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) ∗ J10(i1 , i2 , q[2] , dt , ksi) +
92 G(b[: , i1 ] , G(b[: , i2 ] , aj [i , 0] , dxs) , dxs) ∗
93 (J01(i1 , i2 , q[2] , dt , ksi) + dt ∗ J00(i1 , i2 , q[0] , dt , ksi))
94 for i2 in range(m)
95 for i1 in range(m)] ,
96
97 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) ∗
98 J0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi)
Electronic Journal. http://diffjournal.spbu.ru/ 400Differential Equations and Control Processes, N. 1, 2021
99 for i4 in range(m)
100 for i3 in range(m)
101 for i2 in range(m)
102 for i1 in range(m)] ,
103
104 ∗[G(b[: , i1 ] , Lj(a, aj [i , 0] , dxs) , dxs) ∗
105 (J2(i1 , dt , ksi) / 2 + dt ∗ J1(i1 , dt , ksi) + dt ∗∗ 2 / 2 ∗ J0(i1 , dt , ksi)) +
106 Lj(a, Lj(a, b[i , i1 ] , dxs) , dxs) ∗ J2(i1 , dt , ksi) / 2 −
107 Lj(a, G(b[: , i1 ] , aj [i , 0] , dxs) , dxs) ∗ (J2(i1 , dt , ksi) + dt ∗ J1(i1 , dt , ksi))
108 for i1 in range(m)] ,
109
110 ∗[G(b[: , i1 ] , Lj(a, G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
111 (J100(i1 , i2 , i3 , q[6] , dt , ksi) − J010(i1 , i2 , i3 , q[5] , dt , ksi)) +
112 G(b[: , i1 ] , G(b[: , i2 ] , Lj(a, b[i , i3 ] , dxs) , dxs) , dxs) ∗
113 (J010(i1 , i2 , i3 , q[5] , dt , ksi) − J001(i1 , i2 , i3 , q[4] , dt , ksi)) +
114 G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , aj [i , 0] , dxs) , dxs) , dxs) ∗
115 (dt ∗ J000(i1 , i2 , i3 , q[1] , dt , ksi) + J001(i1 , i2 , i3 , q[4] , dt , ksi)) −
116 Lj(a, G(b[: , i1 ] , G(b[: , i2 ] , b[i , i3 ] , dxs) , dxs) , dxs) ∗
117 J100(i1 , i2 , i3 , q[6] , dt , ksi)
118 for i3 in range(m)
119 for i2 in range(m)
120 for i1 in range(m)] ,
121
122 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(
123 b[: , i4 ] , b[i , i5 ] , dxs) , dxs) , dxs) , dxs) ∗
124 J00000(i1 , i2 , i3 , i4 , i5 , q[7] , dt , ksi)
125 for i5 in range(m)
126 for i4 in range(m)
127 for i3 in range(m)
128 for i2 in range(m)
129 for i1 in range(m)] ,
130
131 dt ∗∗ 3 / 6 ∗ Lj(a, Lj(a, aj [i , 0] , dxs) , dxs) ,
132
133 ∗[G(b[: , i1 ] , G(b[: , i2 ] , Lj(a, aj [i , 0] , dxs) , dxs) , dxs) ∗
134 (J02(i1 , i2 , q[6] , dt , ksi) / 2 + dt ∗ J01(i1 , i2 , q[2] , dt , ksi) +
135 dt ∗∗ 2 / 2 ∗ J00(i1 , i2 , q[2] , dt , ksi)) +
136 Lj(a, Lj(a, G(b[: , i1 ] , b[i , i2 ] , dxs) , dxs) , dxs) / 2 ∗
137 J20(i1 , i2 , q[10] , dt , ksi) +
138 G(b[: , i1 ] , Lj(a, G(b[: , i2 ] , aj [i , 0] , dxs) , dxs) , dxs) ∗
139 (J11(i1 , i2 , q[9] , dt , ksi) − J02(i1 , i2 , q[8] , dt , ksi) +
140 dt ∗ (J10(i1 , i2 , q[2] , dt , ksi) − J01(i1 , i2 , q[2] , dt , ksi))) +
141 Lj(a, G(b[: , i1 ] , Lj(a, b[i , i2 ] , dxs) , dxs) , dxs) ∗
142 (J11(i1 , i2 , q[9] , dt , ksi) − J20(i1 , i2 , q[10] , dt , ksi)) +
143 G(b[: , i1 ] , Lj(a, Lj(a, b[i , i2 ] , dxs) , dxs) , dxs) ∗
144 (J02(i1 , i2 , q[8] , dt , ksi) / 2 + J20(i1 , i2 , q[10] , dt , ksi) / 2 −
145 J11(i1 , i2 , q[9] , dt , ksi)) −
146 Lj(a, G(b[: , i1 ] , G(b[: , i2 ] , aj [i , 0] , dxs) , dxs) , dxs) ∗
147 (dt ∗ J10(i1 , i2 , q[2] , dt , ksi) + J11(i1 , i2 , q[9] , dt , ksi))
148 for i2 in range(m)
149 for i1 in range(m)] ,
150
151 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(
152 b[: , i4 ] , aj [i , 0] , dxs) , dxs) , dxs) , dxs) ∗
153 (dt ∗ J0000(i1 , i2 , i3 , i4 , q[3] , dt , ksi) +
Electronic Journal. http://diffjournal.spbu.ru/ 401Differential Equations and Control Processes, N. 1, 2021
154 J0001(i1 , i2 , i3 , i4 , q[11] , dt , ksi)) +
155 G(b[: , i1 ] , G(b[: , i2 ] , Lj(a, G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
156 (J0100(i1 , i2 , i3 , i4 , q[13] , dt , ksi) − J0010(i1 , i2 , i3 , i4 , q[12] , dt , ksi)) −
157 Lj(a, G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
158 J1000(i1 , i2 , i3 , i4 , q[14] , dt , ksi) +
159 G(b[: , i1 ] , Lj(a, G(b[: , i2 ] , G(b[: , i3 ] , b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
160 (J1000(i1 , i2 , i3 , i4 , q[14] , dt , ksi) − J0100(i1 , i2 , i3 , i4 , q[13] , dt , ksi)) +
161 G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , Lj(a, b[i , i4 ] , dxs) , dxs) , dxs) , dxs) ∗
162 (J0010(i1 , i2 , i3 , i4 , q[12] , dt , ksi) − J0001(i1 , i2 , i3 , i4 , q[11] , dt , ksi))
163 for i4 in range(m)
164 for i3 in range(m)
165 for i2 in range(m)
166 for i1 in range(m)] ,
167
168 ∗[G(b[: , i1 ] , G(b[: , i2 ] , G(b[: , i3 ] , G(b[: , i4 ] , G(
169 b[: , i5 ] , b[i , i6 ] , dxs) , dxs) , dxs) , dxs) , dxs) ∗
170 J000000(i1 , i2 , i3 , i4 , i5 , i6 , q[15] , dt , ksi)
171 for i6 in range(m)
172 for i5 in range(m)
173 for i4 in range(m)
174 for i3 in range(m)
175 for i2 in range(m)
176 for i1 in range(m)]
177
178 )
179
180 def doit(self , ∗∗hints):
181 """
182 Tries to expand or calculate function
183 Returns
184 =======
185 sympy.Expr
186 """
187 return StrongTaylorStratonovich3p0(∗ self .args , ∗∗hints)
6.3 Source Codes for Linear Stationary Systems of It^ o SDEs
Listing 132: Implementation of supplementary functions
1 import numpy as np
2
3
4 class NotASquareMatrix(Exception):
5 pass
6
7
8 def vec to eye(vector):
9 """
10 Converts vector to eye matrix
11 Parameters
12 ==========
Electronic Journal. http://diffjournal.spbu.ru/ 402Differential Equations and Control Processes, N. 1, 2021
13 vector : iterable
14 Returns
15 =======
16 numpy.ndarray
17 """
18 n = len(vector)
19 matrix = np. zeros ((n, n))
20
21 for i in range(len(matrix)):
22 matrix[ i ][ i ] = vector [ i ]
23
24 return matrix
25
26
27 def diagonal to column(matrix):
28 """
29 Converts diagonal matrix to column vector
30 Parameters
31 ==========
32 matrix : numpy.ndarray
33 Returns
34 =======
35 column : numpy.ndarray
36 """
37 height = np.shape(matrix) [0]
38 if height != np.shape(matrix) [1]:
39 raise NotASquareMatrix()
40
41 column = np. zeros ((height , 1))
42 for i in range(height):
43 column[ i ][0] = matrix[ i ][ i ]
44
45 return column
Listing 133: Implementation of Algorithm 11.2 [61]
1 import numpy as np
2 import scipy . linalg as sci
3
4
5 def dindet(n: int , k: int , m a: np.ndarray , m b: np.ndarray , dt: float):
6 """
7 Algorithm 11.2 [61]
8 Parameters
9 ==========
10 n : int
11 k : int
12 m a : numpy.array
13 m b : numpy.array
14 dt : float
15 Returns
16 =======
17 m ad : numpy.array
Electronic Journal. http://diffjournal.spbu.ru/ 403Differential Equations and Control Processes, N. 1, 2021
18 m bd : numpy.array
19 """
20 m okn = np. zeros ((k, n))
21 m okk = np. zeros ((k, k))
22 m idt = np.eye(n + k) ∗ dt
23 m aa = np. vstack((np. hstack((m a, m b)) ,
24 np. hstack((m okn, m okk))))
25 m ex aah = sci .expm(m aa.dot(m idt))
26 m ad = m ex aah [:n, :n]
27 m bd = m ex aah [:n, n:(n + k)]
28 return m ad, m bd
Listing 134: Implementation of Algorithm 11.6 [61]
1 import numpy as np
2
3 from mathematics.sde. linear . dindet import dindet
4 from mathematics.sde. linear .matrix import vec to eye
5
6
7 def stoch(n: int , m a: np.ndarray , m f: np.ndarray , dt: float):
8 """
9 Root function for set of algorithms implemented below
10 Parameters
11 ==========
12 n : int
13 m a : numpy.ndarray
14 m f : numpy.ndarray
15 dt : float
16 Returns
17 =======
18 numpy.ndarray
19 """
20 v l2 , m s, m d1 = algorithm 11 2(n, m a, m f , dt)
21 mat l = vec to eye(np. sqrt(v l2))
22 return m s.dot(mat l)
23
24
25 def algorithm 11 2(n: int , m a: np.ndarray , m f: np.ndarray , dt: float):
26 """
27 Parameters
28 ==========
29 n : int
30 m a : numpy.ndarray
31 m f : numpy.ndarray
32 dt : float
33 Returns
34 =======
35 eigenvalues : numpy.ndarray
36 eigenvectors : numpy.ndarray
37 m d1 : numpy.ndarray
38 """
39 m ac = algorithm 11 5(n, m a)
Electronic Journal. http://diffjournal.spbu.ru/ 404Differential Equations and Control Processes, N. 1, 2021
40 m g = m f.dot(np. transpose(m f))
41 m gv = algorithm 11 3(n, m g)
42 m dd, m dv = dindet(int(n ∗ (n + 1) / 2) , 1, m ac, m gv, dt)
43 m d1 = algorithm 11 4(n, m dv)
44 eigenvalues , eigenvectors = np. linalg . eig(m d1)
45 return eigenvalues , eigenvectors , m d1
46
47
48 def algorithm 11 3(n: int , m g: np.ndarray):
49 """
50 Algorithm 11.3 [61]
51 Parameters
52 −−−−−−−−−−
53 n : int
54 m g : numpy.ndarray
55 Returns
56 −−−−−−−
57 m vec : numpy.ndarray
58 column vector
59 """
60 i2 = 0
61 v size = 0
62 for i in range(n):
63 n2 = n − i
64 for j in range(n2):
65 if v size < j + i2 :
66 v size = j + i2
67 i2 = i2 + n − i
68
69 m vec = np.ndarray(( v size + 1, 1))
70
71 i2 = 0
72 for i in range(n):
73 n2 = n − i
74 for j in range(n2):
75 m vec[ j + i2 ][0] = m g[ j ][ j + i ]
76 i2 = i2 + n − i
77
78 return m vec
79
80
81 def algorithm 11 4(n: int , m dv: np.ndarray):
82 """
83 Algorithm 11.4 [61]
84 Parameters
85 −−−−−−−−−−
86 n : int
87 m dv : numpy.ndarray
88 Returns
89 −−−−−−−
90 m d1 : numpy.ndarray
91 """
92 i2 = 0
93 size = 0
94 for i in range(n):
Electronic Journal. http://diffjournal.spbu.ru/ 405Differential Equations and Control Processes, N. 1, 2021
95 n2 = n − i
96 for j in range(n2):
97 if size < j + i :
98 size = j + i
99 i2 = i2 + n − i
100
101 m d1 = np.ndarray(( size + 1, size + 1))
102
103 i2 = 0
104 for i in range(n):
105 n2 = n − i
106 for j in range(n2):
107 m d1[ j ][ j + i ] = m dv[ j + i2 ][0]
108 m d1[ j + i ][ j ] = m dv[ j + i2 ][0]
109 i2 = i2 + n − i
110
111 return m d1
112
113
114 def algorithm 11 5(n: int , m a: np.ndarray):
115 """
116 Algorithm 11.5 [61]
117 Parameters
118 −−−−−−−−−−
119 n : int
120 m a : numpy.ndarray
121 Returns
122 −−−−−−−
123 m ac : numpy.ndarray
124 """
125 r = 0
126 v size = 0
127 h size = 0
128
129 for i in range(n):
130 n2 = n − i
131 for j in range(n2):
132 o = 0
133 for k in range(n):
134 n3 = n − k
135 for m in range(n3):
136 if v size < m + o:
137 v size = m + o
138 if h size < r:
139 h size = r
140 o = o + n − k
141 r = r + 1
142
143 m ones = np. zeros ((n, n))
144 m ac = np.ndarray(( v size + 1, h size + 1))
145
146 r = 0
147 for i in range(n):
148 n2 = n − i
149 for j in range(n2):
Electronic Journal. http://diffjournal.spbu.ru/ 406Differential Equations and Control Processes, N. 1, 2021
150 i2 = j + i
151 m ones[ j ][ i2 ] = 1
152 m ones[ i2 ][ j ] = 1
153 m one a = m ones.dot(np. transpose(m a)) + m a.dot(m ones)
154 o = 0
155 for k in range(n):
156 n3 = n − k
157 for m in range(n3):
158 m ac[m + o][ r] = m one a[m][m + k]
159 o = o + n − k
160 m ones = np. zeros ((n, n))
161 r = r + 1
162
163 return m ac
Listing 135: Implementation of the vector function u(t)
1 import numpy as np
2 from sympy import lambdify , sympify
3
4
5 class AbstractDistortion :
6 def t(self , t: float):
7 raise NotImplementedError("Method t is not implemented")
8
9
10 class Symbolic(AbstractDistortion):
11
12 def init (self , fn : str):
13 from sympy.abc import t
14 self . u = lambdify(t , sympify(fn) , "numpy")
15
16 def t(self , t):
17 return self . u(t)
18
19
20 class ComplexDistortion(AbstractDistortion):
21 """
22 Vector function u(t)
23 """
24
25 def init (self , n: int , mat u: np.ndarray):
26 self . mat u = mat u
27 self . mat ut = np.ndarray(shape=(n, 1) , dtype=float)
28
29 def t(self , t: float):
30 """
31 Provides vector function u(t) at moment t
32
33 Parameters
34 −−−−−−−−−−
35 t : float
36 moment of time
Electronic Journal. http://diffjournal.spbu.ru/ 407Differential Equations and Control Processes, N. 1, 2021
37 Returns
38 −−−−−−−
39 numpy.ndarray
40 column u(t)
41 """
42 for i in range( self . mat u.shape [0]) :
43 self . mat ut[ i ][0] = self . mat u[ i ][0]. t(t)
44 return self . mat ut
Listing 136: Modeling of linear system of It^ o SDEs
1 import numpy as np
2 from numpy import transpose
3
4 from mathematics.sde. linear .matrix import diagonal to column
5
6
7 class Integral :
8 """
9 Provides numerical integration
10 """
11
12 def init (self , n: int):
13 self .n, self .t0 , self .tk , self .dt , self .t = n
14 n, 0, 0, 0, 0
15 self .m a, self .m ad, self .m bd, self .m h, self .m fd , self . distortion = n
16 None, None, None, None, None, None
17 self .m x0, self .m mx0, self .m dx0, self .m xt, self .m mx, self .m dx = n
18 None, None, None, np.ndarray((n, 0)) , np.ndarray((n, 0)) , np.ndarray((n, 0))
19 self .v yt , self .v my, self .v dy , self . v t = n
20 [] , [] , [] , []
21 self . v ry = []
22
23 def integrate( self ):
24 """
25 Performs numerical integration
26 """
27 higher limit = self .t + int(( self .tk − self .t0) / self .dt + 1)
28 lower limit = self .t
29
30 self .m xt = np. hstack(( self .m xt, np.ndarray(( self .n, higher limit − lower limit))))
31 self .m mx = np. hstack(( self .m mx, np.ndarray(( self .n, higher limit − lower limit))))
32 self .m dx = np. hstack(( self .m dx, np.ndarray(( self .n, higher limit − lower limit))))
33
34 for self .t in range(lower limit , higher limit):
35 t = self .t0 + self .t ∗ self .dt
36 ft = np.random.randn( self .n, 1)
37 mat ut = self . distortion .t(t)
38
39 # solution of sde
40 xt = self .m ad.dot( self .m x0) + self .m bd.dot(mat ut) + self .m fd.dot( ft )
41 # exit process of stochastic system
42 self .m xt[: , self .t] = xt [: , 0]
Electronic Journal. http://diffjournal.spbu.ru/ 408Differential Equations and Control Processes, N. 1, 2021
43 self . v yt .append( self .m h.dot(xt) [0][0])
44
45 # expectation of solution of sde
46 mx = self .m ad.dot( self .m mx0) + self .m bd.dot(mat ut)
47 # expectation of exit process
48 self .m mx[: , self .t] = mx[: , 0]
49 self .v my.append( self .m h.dot(mx) [0][0])
50
51 # dispersion of solution of sde
52 dx = self .m ad.dot( self .m dx0).dot(np. transpose( self .m ad)) + self .m fd.dot(np.
transpose( self .m fd))
53 # dispersion of exit process
54 self .m dx[: , self .t] = diagonal to column(dx) [: , 0]
55 self .v dy.append( self .m h.dot(dx).dot(transpose( self .m h)) [0][0])
56
57 self . v t .append(t)
58
59 self .m x0, self .m mx0, self .m dx0 = xt , mx, dx
6.4 Source Codes for Utilities and Initialization
Listing 137: Initialization module
1 from config import database
2 from init .database import initdb
3 from tools .database import connect , disconnect
4
5
6 def initialization () :
7 """
8 Initializes various components of application
9 """
10 connect(database)
11 initdb ()
12 disconnect()
Listing 138: Module for database initialization
1 import csv
2 import logging
3 import os
4
5 import sympy as sp
6
7 import config as c
8 from tools import fsys
9 from tools .database import execute
10 from tools . fsys import get files
11
12 logger = logging .getLogger( name )
Electronic Journal. http://diffjournal.spbu.ru/ 409Differential Equations and Control Processes, N. 1, 2021
13
14
15 def initdb () :
16 """
17 Initializes database with necessary table drivers
18 """
19
20 if not fsys . is locked(".db. lock"):
21 logger . info("Initializing database ... ")
22 create files table ()
23 create c table ()
24 fsys . lock(".db. lock")
25 else :
26 logger . info("Updating database ... ")
27 update coefficients ()
28
29
30 def create files table () :
31 """
32 Initializes the Fourier−Legendre coefficients table
33 """
34 execute("DROP TABLE IF EXISTS ` files `")
35 execute(
36 "CREATE TABLE ` files ` ("
37 " `id ` integer PRIMARY KEY AUTOINCREMENT,"
38 " `name` text unique"
39 ")"
40 )
41
42
43 def create c table () :
44 """
45 Initializes the Fourier−Legendre coefficients table
46 """
47 execute("DROP TABLE IF EXISTS `C`")
48 execute(
49 "CREATE TABLE `C` ("
50 " `id ` integer PRIMARY KEY AUTOINCREMENT,"
51 " `index ` text unique ,"
52 " `value ` text ,"
53 " `value f ` double"
54 ")"
55 )
56
57 update coefficients ()
58
59
60 def update coefficients () :
61 """
62 Updates the Fourier−Legendre coefficients table
63 """
64 files = get files (c.csv , r 'c .∗n. csv ')
65 loaded files = [ record [0] for record in execute("SELECT `name` FROM ` files `")]
66 difference = [ f for f in files if f not in loaded files ]
67
Electronic Journal. http://diffjournal.spbu.ru/ 410Differential Equations and Control Processes, N. 1, 2021
68 rows = []
69 for file in difference :
70
71 with open(os.path. join( file )) as f :
72 reader = csv. reader(f , delimiter='; ' , quotechar='"')
73 for row in reader :
74 if len(rows) > c. read buffer size :
75 execute(f"INSERT INTO `C` (`index ` , `value ` , `value f `) VALUES f ' , '. join(rows)g
")
76 rows. clear ()
77
78 rows.append(f"('frow[0]g ' , 'frow[1]g ' , ffloat (sp.sympify(row[1]) . evalf ())g)")
79
80 execute(f"INSERT INTO ` files ` (`name`) VALUES ('f fileg')")
81
82 if len(rows) > 0:
83 execute(f"INSERT INTO `C` (`index ` , `value ` , `value f `) VALUES f ' , '. join(rows)g")
Listing 139: Database module
1 import logging
2 import re
3 import sqlite3
4
5 logger = logging .getLogger( name )
6
7 connection : sqlite3 .Connection
8 cursor : sqlite3 .Cursor
9
10
11 def is connected () :
12 """
13 Checks if application is connected to database
14 Returns
15 =======
16 True or False
17 """
18 global connection
19 if connection is None:
20 return False
21 else :
22 return True
23
24
25 def connect(db: str):
26 """
27 Connects application to database
28 Parameters
29 ==========
30 db : str
31 path to database file
32 """
33 try:
Electronic Journal. http://diffjournal.spbu.ru/ 411Differential Equations and Control Processes, N. 1, 2021
34 global connection
35 global cursor
36
37 connection = sqlite3 .connect(db)
38 connection . create function("REGEXP", 2, regex)
39
40 cursor = connection . cursor()
41 logger . info(f"SQLite Database is successfully connected")
42
43 query = "select sqlite version () ;"
44 cursor . execute(query)
45 record = cursor . fetchall ()
46 logger . info(f"SQLite Database Version is : frecord [0][0]g")
47
48 query = "PRAGMA foreign keys = ON;"
49 cursor . execute(query)
50
51 except sqlite3 .Error as error :
52 logger . error(f"Error while connecting to sqlite : ferrorg")
53
54
55 def disconnect() :
56 """
57 Disconnects application from database
58 """
59 try:
60 global connection
61 global cursor
62
63 connection . close ()
64 logger . info("The SQLite connection is closed")
65
66 except sqlite3 .Error as error :
67 logger . error(f"Error while connecting to sqlite : ferrorg")
68
69
70 def execute(query: str):
71 """
72 Sends query to database and receives data
73 Parameters
74 ==========
75 query : str
76 query to database
77 Returns
78 =======
79 list of tuples (rows)
80 """
81 try:
82 global connection
83 global cursor
84
85 cursor . execute(query)
86 records = cursor . fetchall ()
87 connection .commit()
88 return records
Electronic Journal. http://diffjournal.spbu.ru/ 412Differential Equations and Control Processes, N. 1, 2021
89
90 except sqlite3 .Error as error :
91 logger . error(f"Error while connecting to sqlite : ferrorg")
92
93
94 def regex(value , pattern):
95 """
96 Regular expression for search in database
97 Parameters
98 ==========
99 value
100 column to apply
101 pattern
102 regular expression
103 Returns
104 =======
105 Search results
106 """
107 c pattern = re .compile(r"nb" + pattern .lower() + r"nb")
108 return c pattern . search(value) is not None
Listing 140: File system utilities
1 import os
2 import re
3
4 import config as c
5
6
7 def get files (path , pattern):
8 """
9 Gives list of files containing the Fourier−Legendre coefficients
10 Returns
11 =======
12 list
13 list of available files
14 """
15 return [os.path. join(path , f)
16 for f in os. listdir (path) if re .match(pattern , f)]
17
18
19 def is locked(filename : str):
20 """
21 Checks if lock is set
22 Parameters
23 ==========
24 filename : str
25 name of lock file
26 Returns
27 =======
28 True of False
29 """
30 if os.path. isfile (os.path. join(c. resources , filename)):
Electronic Journal. http://diffjournal.spbu.ru/ 413Differential Equations and Control Processes, N. 1, 2021
31 return True
32 else :
33 return False
34
35
36 def lock(filename):
37 """
38 Performs locking
39 Parameters
40 ==========
41 filename : str
42 name of lock file
43 """
44 f = open(os.path. join(c. resources , filename) , "w")
45 f . close ()
46
47
48 def unlock(filename):
49 """
50 Performs unlocking
51 Parameters
52 ==========
53 filename : str
54 name of lock file
55 """
56 os.remove(os.path. join(c. resources , filename))
7 Future Work
Considering the future work, it is important to say that symbolic algebra gives a
wide  eld for optimizations of modeling process. Symbolic operations is actually
operations with strings. Such operations has relatively high complexity and
slows down modeling process signi cantly. One of possible ways to improve
modeling performance is to parallelize computations. Since strong numerical
schemes for It^ o SDEs have massive amount of terms this idea appears justi ed.
The strong numerical schemes for It^ o SDEs seem to be easily optimizable,
on the other hand, superpositions of the differential operators (4), (5), and (23)
are not. They are called recursively during calculation process which is more
di cult to parallelize than strong numerical schemes for It^ o SDEs. Differential
operators obviously include differentiating which is high cost and optimization
of them is a dedicated issue.
In the future, it is possible to improve the SDE-MATH software package in
a number of other directions. In particular, high-order strong numerical meth-
ods of the Runge-Kutta type [2], [7], [42], [61] (including multistep numerical
Electronic Journal. http://diffjournal.spbu.ru/ 414Differential Equations and Control Processes, N. 1, 2021
methods [2], [7], [42], [61]) for It^ o SDEs can be implemented. In addition, soft-
ware for solving the  ltering problem and the problem of stochastic optimal
control can also be developed. These improvements will lead to changes of the
graphical user interface due to new features.
Bibliography
[1] Ito, K. On Stochastic Differential Equations. Memoirs of the American
Mathematical Society, 4 (1951), 1-51.
[2] Kloeden, P.E., Platen, E. Numerical Solution of Stochastic Differential
Equations. Springer, Berlin, 1992, 632 pp.
[3] Kloeden, P.E., Platen, E., Schurz, H. Numerical Solution of SDE Through
Computer Experiments. Springer, Berlin, 1994, 292 pp.
[4] Arato, M. Linear Stochastic Systems with Constant Coe cients. A Sta-
tistical Approach. Springer-Verlag, Berlin, Heidelberg, N.Y., 1982, 289
pp.
[5] Shiryaev, A.N. Essentials of Stochastic Finance: Facts, Models, Theory.
World Scienti c Publishing Co United States, 1999, 852 pp.
[6] Karatzas, I., Shreve, S. Methods of Mathematical Finance. Springer-
Verlag, New York, 1998, 415 pp.
[7] Platen, E., Bruti-Liberati, N. Numerical Solution of Stochastic Differen-
tial Equations with Jumps in Finance. Springer, Berlin, Heidelberg, 2010,
868 pp.
[8] Han, X., Kloeden, P.E., Random Ordinary Differential Equations and
Their Numerical Solution. Springer, Singapore, 2017, 250 pp.
[9] Allen, E. Modeling with Ito Stochastic Differential Equations. Springer,
Dordrecht, 2007, 230 pp.
[10] Merton, R.C. Continuous-Time Finance. Blackwell, Oxford, 1992, 754 pp.
[11] Heston, S.L. A closed-form solution for options with stochastic volatility
with applications to bond and currency options, Rev. Financial Studies,
6, 2 (1993), 327{343.
Electronic Journal. http://diffjournal.spbu.ru/ 415Differential Equations and Control Processes, N. 1, 2021
[12] Cox, J.C., Ingersoll, J.E., Ross, S.A. A Theory of the term structure of
interest rates, Econometrica, 53 (1985), 385-408.
[13] Kimura, M., Ohta, T. Theoretical aspects of Population genetics. Prince-
ton Univ. Press, Boston, 1971, 232 pp.
[14] Iacus, S.M. Simulation and Inference for Stochastic Differential Equations.
With R Examples. Springer-Verlag, New York, 2008, 285 pp.
[15] Ricciardi, L.M. Diffusion Processes and Related Topics in Biology, Lecture
Notes in Biomathematics. Springer, New York, 1977, 202 pp.
[16] Stratonovich, R.L., Selected Problems of Fluctuations Theory in Radio
Engineering. [In Russian]. Sovetskoe Radio, Moscow, 1961, 556 pp.
[17] Liptser, R.Sh., Shirjaev, A.N. Statistics of stochastic processes: nonlinear
 ltering and related problems. [In Russian]. Nauka, Moscow, 1974, 696
pp.
[18] Nasyrov, F.S. Local times, symmetric integrals and stochastic analysis.
[In Russian]. Fizmatlit Publ., Moscow, 2011, 212 pp.
[19] Kagirova, G.R., Nasyrov, F.S. On an optimal  ltration problem for one-
dimensional diffusion processes. Siberian Adv. Math., 28, 3 (2018), 155-
165.
[20] Chugai, K.N., Kosachev, I.M., Rybakov, K.A. Approximate  ltering
methods in continuous-time stochastic systems. Smart Innovation, Sys-
tems and Technologies, vol. 173, Eds. Jain L.C., Favorskaya M.N., Nikitin
I.S., Reviznikov D.L. Springer, 2020, pp. 351-371. DOI: http://doi.org/
10.1007/978-981-15-2600-8 24
[21] Averina, T.A., Rybakov, K.A. Using maximum cross section method for
 ltering jump-diffusion random processes. Russian Journal of Numerical
Analysis and Mathematical Modelling. 35, 2 (2020), 55-67. DOI: http:
//doi.org/10.1515/rnam-2020-0005
[22] Kloeden, P.E., Platen, E., Schurz, H., Sorensen, M. On effects of dis-
cretization on estimators of drift parameters for diffusion processes. J.
Appl. Probab., 33 (1996), 1061-1076.
[23] Clark, J.M.C., Cameron, R.J. The maximum rate of convergence of dis-
crete approximations for stochastic differential equations. Stochastic Dif-
ferential Systems Filtering and Control. Lecture Notes in Control and
Electronic Journal. http://diffjournal.spbu.ru/ 416Differential Equations and Control Processes, N. 1, 2021
Information Sciences, vol 25. Ed. Grigelionis B. Springer, Berlin, Heidel-
berg, 1980, pp. 162-171.
[24] Kulchitskiy, O.Yu., Kuznetsov, D.F. The uni ed Taylor{Ito expansion.
Journal of Mathematical Sciences (New York), 99, 2 (2000), 1130-1140.
DOI: http://doi.org/10.1007/BF02673635
[25] Kuznetsov, D.F. New representations of the Taylor{Stratonovich expan-
sion. Journal of Mathematical Sciences (New York), 118, 6 (2003), 5586-
5596. DOI: http://doi.org/10.1023/A:1026138522239
[26] Kuznetsov, D.F. Strong approximation of iterated Ito and Stratonovich
stochastic integrals based on generalized multiple Fourier series. Applica-
tion to numerical solution of Ito SDEs and semilinear SPDEs. Differen-
cialnie Uravnenia i Protsesy Upravlenia, 4 (2020), A.1-A.606. Available
at: http://diffjournal.spbu.ru/EN/numbers/2020.4/article.1.8.html
[27] Milstein, G.N. Numerical Integration of Stochastic Differential Equations.
[In Russian]. Ural University Press, Sverdlovsk, 1988, 225 pp.
[28] Kloeden, P.E., Platen, E., Wright, I.W. The approximation of multiple
stochastic integrals. Stochastic Analysis and Applications, 10, 4 (1992),
431-441.
[29] Averina, T.A., Prigarin, S.M. Calculation of stochastic integrals of Wiener
processes. [In Russian]. Preprint 1048. Novosibirsk, Institute of Compu-
tational Mathematics and Mathematical Geophysics of Siberian Branch
of the Russian Academy of Sciences, 1995, 15 pp.
[30] Prigarin, S.M., Belov, S.M. One application of series expansions of Wiener
process. [In Russian]. Preprint 1107. Novosibirsk, Institute of Computa-
tional Mathematics and Mathematical Geophysics of Siberian Branch of
the Russian Academy of Sciences, 1998, 16 pp.
[31] Wiktorsson, M. Joint characteristic function and simultaneous simulation
of iterated Ito integrals for multiple independent Brownian motions. The
Annals of Applied Probability, 11, 2 (2001), 470-487.
[32] Ryden, T., Wiktorsson, M. On the simulation of iterated Ito integrals.
Stochastic Processes and their Applications, 91, 1 (2001), 151-168.
[33] Gaines, J.G., Lyons, T.J. Random generation of stochastic area integrals.
SIAM J. Appl. Math., 54 (1994), 1132-1146.
Electronic Journal. http://diffjournal.spbu.ru/ 417Differential Equations and Control Processes, N. 1, 2021
[34] Milstein, G.N., Tretyakov, M.V. Stochastic Numerics for Mathematical
Physics. Springer, Berlin, 2004, 616 pp.
[35] Allen, E. Approximation of triple stochastic integrals through region sub-
division. Communications in Applied Analysis (Special Tribute Issue to
Professor V. Lakshmikantham), 17 (2013), 355-366.
[36] Rybakov, K.A. Applying spectral form of mathematical description for
representation of iterated stochastic integrals. [In Russian]. Differencialnie
Uravnenia i Protsesy Upravlenia, 4 (2019), 1-31. Available at: http://
diffjournal.spbu.ru/EN/numbers/2019.4/article.1.1.html
[37] Tang, X., Xiao, A. Asymptotically optimal approximation of some sto-
chastic integrals and its applications to the strong second-order methods.
Advances in Computational Mathematics, 45 (2019), 813-846.
[38] Zahri, M. Multidimensional Milstein scheme for solving a stochastic model
for prebiotic evolution. Journal of Taibah University for Science, 8, 2
(2014), 186-198.
[39] Li, C.W., Liu, X.Q. Approximation of multiple stochastic integrals and
its application to stochastic differential equations. Nonlinear Anal. Theor.
Meth. Appl., 30, 2 (1997), 697-708.
[40] Rybakov K. Application of Walsh series to represent iterated Stratonovich
stochastic integrals. IOP Conference Series: Materials science and
engineering. 2020, vol. 927, id 012080. DOI: http://doi.org/10.1088/
1757-899X/927/1/012080
[41] Rybakov, K.A. Modeling and analysis of output processes of linear con-
tinuous stochastic systems based on orthogonal expansions of random
functions. J. of Computer and Systems Sci. Int., 59, 3 (2020), 322-337.
DOI: http://doi.org/10.1134/S1064230720030156
[42] Kuznetsov, D.F. Numerical Integration of Stochastic Differential Equa-
tions. 2. [In Russian]. Polytechnical University Publishing House, Saint-
Petersburg, 2006, 764 pp. DOI: http://doi.org/10.18720/SPBPU/2/
s17-227
[43] Kuznetsov, D.F. A method of expansion and approximation of repeated
stochastic Stratonovich integrals based on multiple Fourier series on full
orthonormal systems. [In Russian]. Differencialnie Uravnenia i Protsesy
Electronic Journal. http://diffjournal.spbu.ru/ 418Differential Equations and Control Processes, N. 1, 2021
Upravlenia, 1 (1997), 18-77. Available at: http://diffjournal.spbu.ru/EN/
numbers/1997.1/article.1.2.html
[44] Kuznetsov, D.F. Comparative analysis of the e ciency of application
of Legendre polynomials and trigonometric functions to the numeri-
cal integration of Ito stochastic differential equations. Computational
Mathematics and Mathematical Physics, 59, 8 (2019), 1236-1250. DOI:
http://doi.org/10.1134/S0965542519080116
[45] Kuznetsov, D.F. Application of the method of approximation of iterated
stochastic It^ o integrals based on generalized multiple Fourier series to
the high-order strong numerical methods for non-commutative semilinear
stochastic partial differential equations. Differencialnie Uravnenia i Prot-
sesy Upravlenia, 3 (2019), 18-62. Available at: http://diffjournal.spbu.
ru/EN/numbers/2019.3/article.1.2.html
[46] Kuznetsov, D.F. Application of multiple Fourier{Legendre series to strong
exponential Milstein and Wagner{Platen methods for non-commutative
semilinear stochastic partial differential equations. Differencialnie Urav-
nenia i Protsesy Upravlenia, 3 (2020), 129-162. Available at: http:
//diffjournal.spbu.ru/EN/numbers/2020.3/article.1.6.html
[47] Jentzen, A., R ockner, M. A Milstein scheme for SPDEs. Foundations
Comp. Math., 15, 2 (2015), 313-362.
[48] Becker, S., Jentzen, A., Kloeden, P.E. An exponential Wagner{Platen
type scheme for SPDEs. SIAM J. Numer. Anal., 54, 4 (2016), 2389-2426.
[49] Mishura, Y.S., Shevchenko, G.M. Approximation schemes for stochastic
differential equations in a Hilbert space. Theor. Prob. Appl., 51, 3 (2007),
442-458.
[50] Bao, J., Reisinger, C., Renz, P., Stockinger, W. First order convergence of
Milstein schemes for McKean equations and interacting particle systems
arXiv:2004.03325v1 [math.PR], 2020, 27 pp.
[51] Son, L.N., Tuan, A.H., Dung, T.N., Yin G. Milstein-type procedures for
numerical solutions of stochastic differential equations with Markovian
switching. SIAM J. Numer. Anal., 55, 2 (2017), 953{979.
[52] Sun, Y., Yang, J., Zhao W. Ito{Taylor schemes for solving mean- eld
stochastic differential equations. Numer. Math. Theor. Meth. Appl., 10,
4 (2017), 798-828.
Electronic Journal. http://diffjournal.spbu.ru/ 419Differential Equations and Control Processes, N. 1, 2021
[53] Higham, D.J. An Algorithmic Introduction to Numerical Simulation of
Stochastic Differential Equations. SIAM Rev., 43, 3 (2001), 525{546.
[54] Cyganowski, S., Grune, L., Kloeden, P.E. Maple for stochastic differential
equations. Theory and Numerics of Differential Equations. Eds. Blowey,
J.F., Coleman, J.P., Craig, A.W. Universitext. Springer, Berlin, Heidel-
berg, 2001, pp. 127-177.
[55] Higham, D.J., Kloeden, P.E. MAPLE and MATLAB for stochastic dif-
ferential equations in  nance. Programming Languages and Systems in
Computational Economics and Finance. Advances in Computational Eco-
nomics, vol 18, Ed. Nielsen, S.S. Springer, Boston, MA, 2002, pp. 233-269.
[56] Cyganowski, S., Grune, L., Kloeden P.E. MAPLE for jump-diffusion
stochastic differential equations in  nance. Programming Languages and
Systems in Computational Economics and Finance. Advances in Compu-
tational Economics, vol. 18, Ed. Nielsen, S.S. Springer, Boston, MA, 2002,
pp. 441-460.
[57] Gilsing, H., Shardlow, T. SDELab: A package for solving stochastic dif-
ferential equations in MATLAB. Journal of Computational and Applied
Mathematics, 2, 205 (2007), 1002-1018.
[58] Kuznetsov, D.F. Stochastic Differential Equations: Theory and Practice
of Numerical Solution. With MatLab programs, 3rd Edition. [In Russian].
Polytechnical University Publishing House, Saint-Petersburg, 2009, 768
pp. DOI: http://doi.org/10.18720/SPBPU/2/s17-230
[59] Kiesewetter, S., Polkinghorne, R., Opanchuk, B., Drummond, P.D. xSP-
DE: Extensible software for stochastic equations. SoftwareX, 5 (2016),
12-15.
[60] Gevorkyan, M.N., Velieva, T.R., Korolkova, A.V., Kulyabov, D.S., Sev-
astyanov, L.A. Stochastic Runge{Kutta software package for stochas-
tic differential equations. Dependability Engineering and Complex Sys-
tems. DepCoS-RELCOMEX 2016. Advances in Intelligent Systems and
Computing, vol. 470, Eds. Zamojski, W., Mazurkiewicz, J., Sugier, J.,
Walkowiak, T., Kacprzyk, J. Springer, Cham, 2016, pp. 169-179.
[61] Kuznetsov, D.F. Stochastic differential equations: theory and practice of
numerical solution. With MATLAB programs, 6th Edition. [In Russian].
Differencialnie Uravnenia i Protsesy Upravlenia, 4 (2018), A.1-A.1073.
Electronic Journal. http://diffjournal.spbu.ru/ 420Differential Equations and Control Processes, N. 1, 2021
Available at: http://diffjournal.spbu.ru/EN/numbers/2018.4/article.2.1.
html
[62] Kulchitskiy, O.Yu., Kuznetsov, D.F. Numerical Simulation of Stochastic
Systems of Linear Stationary Differential Equations. [In Russian]. Differ-
encialnie Uravnenia i Protsesy Upravlenia, 1 (1998), 41-65. Available at:
http://diffjournal.spbu.ru/pdf/j010.pdf
[63] Gihman, I.I., Skorohod A.V. Stochastic Differential Equations and its
Applications. [In Russian]. Naukova Dumka, Kiev, 1982, 612 pp.
[64] Kuznetsov, D.F. On Numerical Modeling of the Multidimensional Dy-
namic Systems Under Random Perturbations With the 1.5 and 2.0 Orders
of Strong Convergence. Automation and Remote Control, 79, 7 (2018),
1240-1254. DOI: http://doi.org/10.1134/S0005117918070056
[65] Kuznetsov, D.F. On Numerical Modeling of the Multidimentional Dy-
namic Systems Under Random Perturbations With the 2.5 Order of
Strong Convergence. Automation and Remote Control, 80, 5 (2019), 867-
881. DOI: http://doi.org/10.1134/S0005117919050060
[66] Kuznetsov, D.F. Explicit one-step mumerical method with the strong
convergence order of 2.5 for Ito stochastic differential equations with a
multi-dimensional nonadditive noise based on the Taylor{Stratonovich
expansion. Computational Mathematics and Mathematical Physics, 60,
3 (2020), 379-389. DOI: http://doi.org/10.1134/S0965542520030100
[67] Kuznetsov, D.F. Strong approximation of iterated Ito and Stratonovich
stochastic integrals based on generalized multiple Fourier series. Ap-
plication to numerical solution of Ito SDEs and semilinear SPDEs.
arXiv:2003.14184 [math.PR], 2020, 652 pp.
[68] Kuznetsov, D.F. Multiple Ito and Stratonovich stochastic integrals: ap-
proximations, properties, formulas. Polytechnical University Publishing
House: St.-Petersburg, 2013, 382 pp. DOI: http://doi.org/10.18720/
SPBPU/2/s17-234
[69] Kuznetsov, D.F. Expansion of iterated Stratonovich stochastic integrals
based on generalized multiple Fourier series. Ufa Mathematical Journal,
11, 4 (2019), 49-77. DOI: http://doi.org/10.13108/2019-11-4-49 Available
at: http://matem.anrb.ru/en/article?art id=604
Electronic Journal. http://diffjournal.spbu.ru/ 421Differential Equations and Control Processes, N. 1, 2021
[70] Kuznetsov, D.F. Development and application of the Fourier method for
the numerical solution of Ito stochastic differential equations. Computa-
tional Mathematics and Mathematical Physics, 58, 7 (2018), 1058-1070.
DOI: http://doi.org/10.1134/S0965542518070096
[71] Kuznetsov, D.F. Mean Square Approximation of Solutions of Stochastic
Differential Equations Using Legendres Polynomials. Journal of Automa-
tion and Information Sciences (Begell House), 32, Issue 12, (2000), 69-86.
DOI: http://doi.org/10.1615/JAutomatInfScien.v32.i12.80
[72] Kuznetsov, D.F. Multiple Ito and Stratonovich stochastic integrals: Fou-
rier{Legendre and trigonometric expansions, approximations, formulas.
Differencialnie Uravnenia i Protsesy Upravlenia, 1 (2017), A.1{A.385.
Available at: http://diffjournal.spbu.ru/EN/numbers/2017.1/article.2.1.
html
[73] Kuznetsov, M.D., Kuznetsov, D.F. Optimization of the mean-square ap-
proximation procedures for iterated Ito stochastic integrals of multiplic-
ities 1 to 5 from the uni ed Taylor{Ito expansion based on multiple
Fourier{Legendre series arXiv:2010.13564 [math.PR], 2020, 59 pp.
[74] Kuznetsov, M.D., Kuznetsov, D.F. Implementation of strong numeri-
cal methods of orders 0.5, 1.0, 1.5, 2.0, 2.5, and 3.0 for Ito SDEs
with non-commutative noise based on the uni ed Taylor{Ito and
Taylor{Stratonovich expansions and multiple Fourier{Legendre series.
arXiv:2009.14011 [math.PR], 2020, 188 pp.
[75] Kuznetsov, D.F., Kuznetsov, M.D. A software package for implementa-
tion of strong numerical methods of convergence orders 0.5, 1.0, 1.5, 2.0,
2.5, and 3.0 for Ito SDEs with non-commutative multi-dimensional noise.
19th International Conference "Aviation and Cosmonautics" (AviaSpace-
2020). Abstracts (Moscow, MAI, 23-27 November, 2020), Publishing
house "Pero", 2020, 569-570.
[76] Kuznetsov, D.F., Kuznetsov, M.D. Mean-square approximation of iter-
ated stochastic integrals from strong exponential Milstein and Wagner-
Platen methods for non-commutative semilinear SPDEs based on multiple
Fourier-Legendre series. Springer Proceedings in Mathematics & Statis-
tics. Recent Developments in Stochastic Methods and Applications. Ed.
Shiryaev, A.N. Samouylov, K.E, Kozyrev, D.V., 2021 (to appear).
Electronic Journal. http://diffjournal.spbu.ru/ 422
