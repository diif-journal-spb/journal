ДИФФЕРЕНЦИАЛЬНЫЕ 
УРАВНЕНИЯ 
И 
ПРОЦЕССЫ УПРАВЛЕНИЯ 
N. 1, 2024 
Электронный журнал, 
рег. Эл № ФС77-39410 от 15.04.2010 
ISSN 1817-2172 
 
http://diffjournal.spbu.ru/ 
e-mail: jodiff@mail.ru 
 
 
 
Информационные системы и процессы 
 
Обобщенный алгоритм суммирования перечислителей в задачах 
дискретной оптимизации в контексте управления мастер-
данными 
 
Кузнецов С.В.
 1,2*
, Кознов Д.В.
 2**
 
 
1
ООО «Юнидата» 
2
Санкт-Петербургский государственный университет 
 
* 
sergey.kouznetsov@gmail.com 
** 
d.koznov@spbu.ru 
 
 
Аннотация. В данной работе выполнена ревизия обобщенного алгоритма для суммирования 
произвольного числа перечислителей субоптимальных решений задач дискретной 
оптимизации. Исходные идеи этого алгоритма были предложены российским математиком 
И. В. Романовским. Однако к настоящему времени открылись перспективы применения 
концепции перечислителей для задач управления данными и машинного обучения. При этом 
важной оказалась именно операция суммирования нескольких перечислителей, что 
позволяет выполнять декомпозицию мультидоменных алгоритмов управления мастер-
данными. Также в работе представлены сложностные оценки для различных вариантов 
алгоритма суммирования произвольного числа перечислителей.  
  
Ключевые слова: субоптимальные задачи дискретной оптимизации, перечислители, 
граница Парето, управление мастер-данными, мультидоменные алгоритмы 
 
1. Введение 
 
В различных прикладных областях возникают задачи дискретной оптимизации, где требуется 
найти не только оптимальное решение, но и следующие    лучших решений, то есть решить 
субоптимальную задачу [1,2]. Отдельно стоит выделить активно развивающиеся отрасли 
биоинформатики, информационных технологий, и искусственного интеллекта, где приходится Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      71 
оперировать большими объемами данных из различных источников [3,4 ]. Для таких задач часто 
используют прием масштабирования субоптимальных задач, который понижает сложность 
алгоритмов, позволяя составлять искомые решения из решений более простых задач (меньших по 
количеству допустимых решений, числу параметров оптимизации, объёму обрабатываемых 
данных и т.д.).  
В [1,5] введено понятие перечислителей, операций с ними, а также показано как они могут 
использоваться для масштабирования. Одной из ключевых операций при этом является 
суммирование перечислителей, для которой в [4] представлен алгоритм для случая двух 
перечислителей. В прикладных задачах, использующих большой набор анализируемых данных, 
операция суммирования перечислителей позволяет объединять решения задач на разных доменах 
данных в искомое субоптимальное решение исходной задачи. Однако для этого требуется 
эффективная реализация суммирования большого числа (десятки и сотни) перечислителей 
доменов. Анализ подходов и поиск эффективной реализации операции суммирования 
перечислителей для большого числа слагаемых является целью данной работы. 
Статья структурирована следующим образом – рассмотрены алгоритмы попарного 
суммирования произвольного числа перечислителей, приведены оценки их алгоритмической 
сложности и потребления памяти (раздел 2). Далее предложен обобщенный алгоритм перебора 
решений субоптимальной задачи суммы    при    > 2 перечислителей на основе многомерной 
границы Парето, а также дана оценка сложности и потребления памяти (раздел 3). В заключении 
приведено сравнение представленных алгоритмов для разного количества слагаемых и значений 
субоптимальности. 
 
2. Суммирование перечислителей субоптимальных задач 
 
В данном разделе представлено два алгоритма суммирования перечислителей решений 
субоптимальных задач дискретной оптимизации для n > 2  на основе попарного сложения и 
изложена мотивация для поиска более эффективного алгоритма.  
Пусть имеется     > 2 и набор задач дискретной оптимизации             в определениях [4], где 
   ∈ 1 ∶    .  Тогда для любого такого    и соответствующего             обозначим через       значение 
субоптимальности задачи             . Для задачи                 , полученной суммированием задач             , 
значение субоптимальности определим как    = ∏          =1..   . 
 При суммировании    задач оказывается важным порядок суммирования задач               – от 
этого порядка зависит сложность алгоритма вычисления итогового перечислителя для                  . 
 
Алгоритм 1. Попарное суммирование. Рассмотрим следующий порядок сложения    
субоптимальных задач дискретной оптимизации.  
               = ∑                   =1
= (… (         1
+          2
) +          3
 ) + ⋯ +             ) … ).  
Пусть соответствующим образом складываются и перечислители этих задач. 
 
Замечание. Если решения субоптимальной задачи          1
, в большинстве своем, меньше, чем 
         2
, то средняя сложность алгоритма перебора решений задачи          1
+          2
 из [4] будет 
ниже, чем задачи          2
+          1
. При этом асимптотическая сложность останется той же. Это 
замечание вытекает из того, что в этом случае условие строки 13 алгоритма суммирования (см. 
листинг 1 в  [4]) будет выполняться в большинстве случаев, и, соответственно, алгоритм не будет 
выполнять шаги после 14-й строки, а значит раньше заканчивать свою работу. Однако 
асимптотическая сложность останется той же, поскольку можно построить такой «плохой 
сценарий», который обеспечит выполнение всех шагов алгоритма. 
 
Воспользуемся этим замечанием для модификации Алгоритма 1. 
 Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      72 
Алгоритм 2. Модифицированное попарное суммирование. Рассмотрим следующий порядок 
сложения    субоптимальных задач дискретной оптимизации. 
1. Отсортируем              в порядке возрастания начальных решений       0
, т.е. чтобы 
выполнилось       1
0
≤. . ≤          0
. 
2. Положим:                = ∑                   =1
= (… (            1
+                ) +             2
 ) + ⋯ +
                −1
) … ). 
Пусть соответствующим образом складываются и перечислители этих задач. 
 
Заметим, что обычно нет информации о всех решениях          1
 и          2
, но мы располагаем 
решениями    1
0
 и    2
0
. Из проведенных нами экспериментов на различных задачах и данных 
вытекает, что обычно     1
0
≤    2
0
, и, соответственно, решения задачи          1
, в большинстве своем, 
будут меньше, чем решения           2
1. Это наблюдение, а также замечание, приведённое после 
Алгоритма 1, влечёт, что Алгоритма 2 имеет меньшую среднюю сложность по сравнению с 
Алгоритмом 1. 
 
Возможны и другие модификации попарного суммирования.  Однако все они будут обладать 
существенным недостатком: для каждого попарного суммирования перечислителей запоминается 
контекст его выполнения – все вспомогательные структуры данных, счетчики и вычисленные 
решения задач-слагаемых, и итоговый алгоритм потребляет значительный объём памяти. 
Сформулируем это утверждение более строго .  
 
Утверждение 1. Асимптотическая сложность любого алгоритма попарного сложения     
перечислителей составляет О(   ∗    ), где    является значением субоптимальности итоговой задачи 
               .  Асимптотическая сложность потребления памяти такого алгоритма составляет 
   (   ∗    + 2
   −1
∗ |               |), где все вспомогательные данные итогового алгоритма обозначены 
как                 , а размер занимаемой ими памяти –  |               |. 
 
В качестве некоторого экспериментального подтверждения Утверждения 1 заметим, что при 
испытаниях на большом количестве слагаемых (   > 15) Алгоритм 1 и Алгоритм 2 некорректно 
завершались от переполнения памяти. Отметим, что для прикладных задач число перечислителей 
измеряется десятками и сотнями [4,6], поэтому целесообразно построить алгоритм, потребляющий 
память более эффективно.  
 
3. Обобщенный алгоритм суммирования перечислителей   
 
Важно, что не требуется сразу вычислять все субоптимальные решения для слагаемых             , 
но можно построить «ленивый» процесс перебора (перечислитель), который вычисляет только 
«следующее» субоптимальное решение нужного слагаемого, что уменьшит размер                . Это 
важное замечание для случаев небольших значений субпотимальности    задачи                . 
Это наблюдение, а также анализ вспомогательных структур алгоритма из [4] приводят к его 
обобщению в русле [5]: хранение                можно ограничить только индексами решений 
«вычисляемых для сравнения», то есть хранения обновляемой границы Парето для многомерного 
множества всех возможных комбинаций индексов решений слагаемых. Такой подход потребляет 
существенно меньше памяти, так как не хранит весь контекст, а лишь вспомогательные структуры 
для обсчета и обхода одной многомерной границы Парето. Представим этот алгоритм. 
                                                 
1
 Такое предположение обычно подтверждается на практике, если субоптимальные решения не имеют 
«разрывов». Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      73 
Введём ряд обозначений. Для списка задач             , где    ∈ 1 ∶     рассмотрим прямое 
произведение    =    1
 × … ×       отрезков натурального ряда       = 1 ∶       . Положим    0
=
{(1, … ,1)} ⊂    . Функцию уровней    0
∶    2
 × … ×       ⟶    1
  определим так: 
 
Для    = (   2
, … ,       )    0
(   ) = {
 1, если  ∀ j ∈ 2 ∶    имеем       > 1,          
     1
, если ∃ j ∈ 2 ∶    такой, что       = 1.
 
(1) 
Аналогично [4],    -е решение задачи             будем обозначать          =          (      0
), при этом уже 
вычисленные решения задачи             сохраняются и потом не вычисляются повторно, 
поэтому к ним возможен прямой доступ по индексу {         ,          } =       .        (   ), где          – это 
значение целевой функции    -го решения задачи             .  
 
Ниже представлен Алгоритм 3, который для     ∈ 1:    принимает на вход     1
, . . ,       , 
      −1
,       −1
 и выдаёт         ̅ ̅ ̅ ̅
,       ,       , то есть решение задачи                 , следующее по 
оптимальности. Отметим, что функции       являются обобщением аналогичной функции из [4,5], 
и их удобно задавать и хранить в виде массива. 
 
Алгоритм 3. Обобщенный алгоритм суммирования перечислителей. 
1      Вход:    1
, …    n
,       −1
,       −1
 
2            =       −1
,       =       −1
    
3 for each b  ∈       
4  for j ∈ 1 : n    
5   {      ,       } =       . get(b[j])  /* j -й элемент b ∈ R 
6      +=       
7  if       >    then  
8         =    
9         ̅ ̅ ̅ ̅
 = (   1
, . . ,       ) 
10         = b 
11    = strip (      ) /*       без первого элемента, с индексами 2 : n 
12       =       \ {      }  
13    =       (   ) 
14       (   ) =       −1
(   ) + 1  
15 for j ∈ 2 : n 
16     ′
=     ,    ′
   =    ′
   +1  
17  if (      (   ′
),    ′
) ∉       then        ∪= {(      (   ′
),    ′
)}  
18 for l ∈ 2 : n  
19     ′′
=     ,    ′′
   =       −1  
20  if (       (   ′′
) >    + 1) || (      = 1)  then 
21         ∪= {   + 1,    )} 
22      Вы хо д:       ̅ ̅ ̅ ̅
,       ,       
  
Докажем, что представленный алгоритм реализует          , т.е.       ̅ ̅ ̅ ̅
 является    -тым 
субоптимальным решением       задачи                . Для этого обобщим Лемму 3 из [4], следуя тем 
же обозначениям:     0
=    ,       =       −1
 \ {      }. 
 
Лемма. Множество        ,  выдаваемое алгоритмом 3, является границей Парето для 
множества       при    :  0 ≤    ≤ ∏          =1
j
. 
Доказательство. Для начала покажем, что алгоритм 3 строит множество       ⊆       , которое 
можно задать следующим образом: Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      74 
 
      = {(   ,    2
, … ,       ) |       (   2
, . . ,       ′
, . . ,       ) >       (   ), где 
      ′
=       − 1 | ∀    ∈ 2 ∶    ,    =       (   )}. 
(2) 
Доказательство (2) проведем индукцией по    .  Для    0
 (2) очевидно выполнено. Согласно 
предположению индукции будем полагать, что оно выполнено для       −1
. 
Приступая к построению множества       , положим его равным множеству       −1
(строка 2). 
Далее элемент       = (   ,    ) удаляется из       (строка 12), значение функции       будет отличаться 
от       −1
 только в    :       (x) =        −1
(   ) +1  и становится равным    + 1 (строка 14). 
Отметим, что в итоге в множество       войдут следующие элементы { (   ′,    ′
) |     ′
 =
(   2
, … ,       + 1, … ,       )  | ∀    ∈ 2 ∶    ,    ′ =       (   ′
)} (строки 15-17), поскольку значение       (   ) на 
шаге    увеличено на единицу, а согласно предположению индукции для       −1
 выполнено  
      (   ′
) ≤    <       (   ), поскольку (   ,    ) ∈        −1
.  
Поскольку элемент (   ,    ) удален из       , то для множества элементов {   ′′
 = (   2
, … ,       −
1, … ,       ) |        > 0, ∀    ∈ 2 ∶    }  выполнено       (   ′′
) >    + 1 значит элемент (   + 1,    ) должен 
войти в       , поскольку       [   ] =    + 1. Это условие и определяет вхождение элемента (   + 1,    ) 
в       , что реализовано в строках 18–21.  
Таким образом мы показали, что       удовлетворяет (2). 
Перейдём к доказательству утверждения леммы и проведём его индукцией по    . Для 
множества    0
 это утверждение очевидно, поскольку очевидно, что     0
⊂    0
. При этом    0
 
состоит из одного элемента (1, . . , 1), который доминирует все другие элементы    0
.  
Предположим, утверждение выполнено для множества        −1
 при    > 0. Множество        
получается удалением из        −1
 элемента       = (   ,    ), который входил в        −1
 (строки 3, 10). При 
этом элемент       также удаляется из        (строка 12), а в        добавляются только элементы 
из       −1
 (строки 17, 21), значит,        ⊆       . 
Для каждого    ∈ 2 ∶    рассмотрим    ′′
 = (   2
, … ,       − 1, … ,       )  |        > 0. При этом 
возможны два случая:       (   ′′
) =    + 1 или       (   ′′
) >    + 1. Случай       (   ′′
) <    + 1 
невозможен по построению       .  При этом будем полагать, что       > 1, поскольку если        = 1 , то 
в множество        на шаге    войдет элемент (   + 1,    ), и таким образом, очевидно, что        будет 
границей Парето для множества        .  
Случай 1.       (   ′′
) =    + 1 (строка 13). Это означает, что элемент (   + 1,    ), определяемый 
новым значением       (   ), не попадает в множество       в силу (2). Однако там содержится элемент 
(   + 1,    ′′
), и, тем самым, доминируются элементы множества {(   ,    )|       − 1 ≤       ,    + 1 ≤    } 
и элемент (      (   ′
),    ′
), который доминирует следующее множество {(   ,    )|       + 1 ≤       ,
      (   ′
) ≤    }.  Пересекая эти множества и принимая во внимание, что элемент (   ,    ) уже 
исключен из       , а множество       −1
 было границей Парето согласно предположению индукции, 
мы видим, что       = {      −1
∖ {(   ,    )}} ∪ {(       (   ′
),    ′
)} является границей Парето множества 
      . 
Случай 2.       (   ′′
) >    + 1. В этом случае в множество       войдет новый элемент (   + 1,    ) 
(строка 21). Осталось лишь проверить те элементы, которые им не доминируются, а именно 
   = {(   ,    )|       ≤       ,    =    }. Помним о том, что (      (   ′
),    ′
) ∈       ,  а значит, элементы  
{(   ,    )|       + 1 ≤       ,       (   ′
) ≤    } уже им доминируются. Тогда, принимая во внимание, что 
(   ,    ) уже исключен из       и       (   ′
) ≤    , получаем, что множество    ∖ {(   ,    )} доминируется 
элементом (      (   ′
),    ′
) , а он уже включен в       . Таким образом и в этом случае       является 
границей Парето множества       ∎ 
 
Теорема. Пусть                = ∑                   =1
 . Тогда Алгоритм 3 задает          , т.е.       ̅ ̅ ̅ ̅
 =       и  
       (   1
, . . ,       ) является перечислителем. Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      75 
Доказательство проходит аналогично доказательству Теоремы 1 в [4] поскольку применимы 
такие же рассуждения о переборе элементов многомерной границы Парето (строки 3–10), а то, что 
      ей является для всего множества индексов решений, еще не возвращенных на    − 1 
предыдущих шагах (       ) доказано в Лемме выше. 
Доказательство выполнения условия (2) определения перечислителя из [4] для           
несколько сложнее. В силу выполнения условия (1) для перечислителей-слагаемых  ∀      =
(   1
, . . ,       ) ∈       \{      0
} можно указать такой индекс    , что       =       (   ′
   ) и построить такое    ′
   , что 
   ′
   = {   1
, . . ,    j−1,
   ′
   ,       +1
, . . ,       }. Таким образом, элемент       оказывается достижим с помощью 
конечного числа суперпозиций          над значением    ′
   .∎ 
 
С точки зрения производительности важно, что нам удалось ввести функцию       , 
отображающую значения из    -мерного массива в отрезок, и поэтому нет необходимости тратить 
ресурсы на обход этого массива. Отметим важность эффективной реализации вычисления 
функции       для большого числа складываемых перечислителей. Хранение значений       в виде 
многомерного целочисленного массива неэффективно для больших    . Поэтому использована так 
называемая техника «ведерного хранения» реализации       в виде хеш-массива, в котором за счет 
подбора параметров (число «ведер» и хранимых в нем элементов) можно добиться константного 
времени поиска элемента [7]. Последнее наблюдение является ключевым для оценки  сложности 
Алгоритма 3 для определенных сценариев.  
 
Утверждение 2. Асимптотическая сложность Алгоритма 3 составляет О(   ∗    ). Асимптотическая 
сложность потребления памяти Алгоритма 3 составляет    (    ∗    + |               |). 
 
4. Заключение  
 
Выше представлены алгоритмы попарного суммирования произвольного числа 
перечислителей субоптимальных решений задач дискретной оптимизации, даны их оценки 
сложности и объема потребляемой памяти. Также представлен обобщенный алгоритм 
суммирования на основе пересчёта многомерной границы Парето, который потребляет 
значительно меньше памяти и эффективен при большом количестве слагаемых, а также при 
небольших значениях субоптимальности. 
Наши эксперименты показали, что Алгоритм 3 ожидаемо быстрее выдаёт решения для 
больших    > 10. Также он эффективен для поиска небольшого числа первых решений, т.е. при 
малых    . Однако для поиска всех решений и произвольном значении     Алгоритм 2 оказывается 
более эффективным при условии, что ему предоставлен достаточный объём памяти. 
 
Литература  
 
[1] Романовский И. В. Субоптимальные решения. Петрозаводск: Изд-во Петрозаводского 
университета. 1998. 
[2] Брумштейн Ю. М., Тарков Д. А., Дюдиков И. А. Анализ моделей и методов выбора 
оптимальных совокупностей решений для задач планирования в условиях ресурсных 
ограничений и рисков //Прикаспийский журнал: управление и высокие технологии. – 
2013. – №. 3. – С. 169–180. 
[3] Кузнецов С., Константинов А., Скворцов Н. Ценность ваших данных. Изд-во Альпина 
PRO, 2022. 
[4] Кузнецов С. В. Суммирование перечислителей в задачах дискретной оптимизации в 
контексте управления мастер-данными // Дифференциальные уравнения и процессы 
Управления. – 2023. – №. 4. – С. 42–52. Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      76 
[5] Романовский И. В., Кузнецов С. В. Обобщенный алгоритм суммирования 
перечислителей субоптимальных решений // Вестник Санкт-Петербургского 
университета. Математика. Механика. Астрономия. – 2005. – №. 2. – С. 74–87. 
[6] Marler R. T., Arora J. S. Survey of multi-objective optimization methods for 
engineering // Structural and multidisciplinary optimization. – 2004. – Т. 26. – С. 369–395. 
[7] Denardo E. V., Fox B. L. Shortest-route methods: reaching, pruning, and 
buckets // Operations Research. 1979. Vol. 27. P. 161–186.  Дифференциальные уравнения и процессы управления, N. 1, 2024 
 
https://doi.org/10.21638/11701/spbu35.2024.106     Электронный журнал: http://diffjournal.spbu.ru      77 
 
Summation of the enumerators in the discrete optimization problems 
 
Kuznetsov S. V.
 1,2*
, Koznov D. V.
 2**
 
 
1
 Unidata LLC 
2
 Saint-Petersburg State University 
 
*sergey.kouznetsov@gmail.com 
**d.koznov@spbu.ru 
 
 
Abstract. The publication presents an approach to the use of discrete optimization algorithms, in 
particular, the search for suboptimal solutions. The theory of enumerators, proposed by the famous 
Leningrad mathematician I.V. Romanovsky, and the operation of their summation, which is 
proposed to be used to create multi-domain suboptimal algorithms, are considered. The paper 
presents an efficient algorithm to sum enumerators based on the recalculation of the Pareto 
boundary. Motivations for using the proposed algorithm within the framework of a well–known 
task in the field of Master Data Management are given. 
 
Keywords: enumerators, suboptimal problems, discrete optimization, Pareto boundary, master data 
management, multi-domain algorithms. 
 
 
 
